<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Introduction on Paladnix Blog Site</title>
    <link>https://Paladnix.github.io/</link>
    <description>Recent content in Introduction on Paladnix Blog Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 27 Jun 2022 15:46:07 +0000</lastBuildDate><atom:link href="https://Paladnix.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>多棵树状数组处理区间问题</title>
      <link>https://Paladnix.github.io/posts/acm/bit-%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C/</link>
      <pubDate>Mon, 27 Jun 2022 15:46:07 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/acm/bit-%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C/</guid>
      <description>单点修改，区间求和 # 区间求和可以优化为前缀和之差。因此问题转换为如何求前缀和。
当我们对$a_i$ 做 加x 操作时，只需要在树状数组上add(i, x); 对于一个$j(j &amp;gt;= i)$， 我们执行getSum(j) 时，会求出所有小于等于j位置的修改的总和，因此也就获得了前x项的修改总和。这个问题就这样解决了。
区间修改，区间求和 # 对于一个区间整体+x的操作，我们的处理方式是add(L, x); 和 add(R+1, -x);,此时getSum(j) 求前缀和getSum(j)时得到的结果正是作用于（影响了）j 位置的总和。换言之，只得到了x对于j位置的贡献，并没有计算x对于一整段的贡献。
我们单独来看x的贡献，对于前j项和来说，x贡献了(j-i)次，因为每个位置都+x了。此时我们独立考虑+x和-x的影响，因此不需要关注x的真正持续范围，因为考虑-x的时候会反向抵消这部分贡献。
前x项和可以写成公式：$A_1 + A_2 + A_3 + \cdots + A_j + (j-i_1)x_1 + (j-i_2)x_2 &amp;hellip;$，这个式子前半部分是A的前缀和，是固定值，可以直接计算的到。对于后一半，我们做简单的合并同类项的处理：$j\cdot (x_1+x_2 +&amp;hellip;) - (i_1\cdot x_1 + i_2\cdot x_2 + &amp;hellip;.) = j\cdot getSum(j) - (i_1\cdot x_1 + i_2\cdot x_2 + &amp;hellip;.)$
那么对于$(i_1\cdot x_1 + i_2\cdot x_2 + &amp;hellip;.)$ 我们可以用另外一个树状数组来维护出来: add(i * x);</description>
    </item>
    
    <item>
      <title>ABC-256-F 题解</title>
      <link>https://Paladnix.github.io/posts/acm/atcoder/abc-256-f/</link>
      <pubDate>Thu, 23 Jun 2022 17:46:07 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/acm/atcoder/abc-256-f/</guid>
      <description>题意 # 已知A序列为一个整数序列，B序列是A的前缀和序列，C序列是B的前缀和序列，D序列是C的前缀和序列。
有两种操作：
单点修改A序列。 单点查询D序列。 分析 # 我们可以计算每个A对
对B的后缀序列每个都贡献$x$。 对C的后缀序列，每个位置j都贡献$(j-i+1)x$ 对D的后缀序列，每个位置j都贡献$\sum_{1}^{j-i+1} x$ 因此可以得到表达式：
$$
D_i = $$</description>
    </item>
    
    <item>
      <title>Lucky Number 题解</title>
      <link>https://Paladnix.github.io/posts/acm/atcoder/abc-255_e/</link>
      <pubDate>Thu, 23 Jun 2022 15:46:07 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/acm/atcoder/abc-255_e/</guid>
      <description>题意 # Lucky Number
对于序列A，S序列是A序列的相邻两项之和的序列: $S_i = A_i + A_{i+1}$, S序列已知
给定一个X序列，请你确定一个A序列，使得X序列中的数字出现的次数仅可能的多，输出最多的次数。
分析 # 我们可以很容易的写出A序列：
$$ \begin{aligned} A_1 &amp;amp;= A_1 \\ A_2 &amp;amp;= S_1 - A_1 \\ A_3 &amp;amp;= S_2 - A_2 = S_2 - S_1 + A_1 \\ A_4 &amp;amp;= S_3 - A_3 = S_3 - S_2 + S_1 - A_1 \\ A_5 &amp;amp;= S_4 - A_4 = S_4 - S_3 + S_2 - S_1 + A_1 \\ \end{aligned} $$</description>
    </item>
    
    <item>
      <title>skip list原理与实现</title>
      <link>https://Paladnix.github.io/posts/rocksdb/skip-list/</link>
      <pubDate>Wed, 25 May 2022 10:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/rocksdb/skip-list/</guid>
      <description>原理 # 跳表作为一个没有被正规教材收录的数据结构，在工业场景下的用途非常广泛，常常用来媲美红黑树等一系列平衡二叉查找树。其核心的原理是通过多级索引层层二分构建一个支持二分查找的有序链表。
有序链表无法进行二分查找的原因在于无法随机访问，一个完美的跳表应该类似一个平衡二叉树的模样。
我们通过间隔一个选一个点复制出来，构成一个一级索引，针对一级索引链表，再通过间隔一个的方式构建二级索引，以此类推，最多$$log_2 n$$层就可以只剩两个点，这就是一个极其类似平衡二叉查找树的结构。查询的复杂度必然也是$$$log_2 n$$$。
但是上述的结构在insert和delete的时候动态调整的代价非常大，甚至无法通过log级别的复杂度完成。因此在实现的时候，并没有按照这个完美的结构来实现。而是采用了一个随机化抽点的方式来构建索引。事实验证的效率是令人满意的。
顺带提一下空间复杂度，虽然复制了一些点，但是依然是$O(n)$的复杂度，计算方式非常简单。并且索引部分并不需要记录完整的数据，只需要记录用于比较大小的score即可，因此索引与数据节点之间的空间比起来微不足道了。
实现原理 # 我们定义最底层的链表是原始的有序链表，向上一层为一级索引，再上一层为二级索引，以此类推。
我们基于完美形态的跳表可以发现，一级索引的点数为$n$， 二级索引点数为$n/2$, 三级索引的点数为$n/4$, 换个角度来看，一个点出现在一级索引中的概率是1， 出现在二级索引中的概率是1/2， 出现在三级索引中的概率是1/4。因此在插入数据的时候，我们只要按照概率分布，随机出这个点需要出现在哪几级索引中，然后按照索引层去查找和插入即可。
如何随机出一个点需要被插入的索引层？直接看代码：
// 该 randomLevel 方法会随机生成 1~MAX_LEVEL 之间的数，且 ： // 1/2 的概率返回 1 // 1/4 的概率返回 2 // 1/8 的概率返回 3 以此类推 private int randomLevel() { int level = 1; // 当 level &amp;lt; MAX_LEVEL，且随机数小于设定的晋升概率时，level + 1 while (Math.random() &amp;lt; 0.5 &amp;amp;&amp;amp; level &amp;lt; MAX_LEVEL) level += 1; return level; } 代码的逻辑非常简单：</description>
    </item>
    
    <item>
      <title>python type</title>
      <link>https://Paladnix.github.io/posts/python/python-type/</link>
      <pubDate>Sat, 22 Sep 2018 13:47:12 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/python/python-type/</guid>
      <description>type 的普通用法 # type一般的用法使用来获取一个变量的类型，但是，type并不适合用来获取一个变量的类型。
想获取一个变量的类型，有其实类的实际类型要用isinstance
isinstance # class A: pass class B(A): pass isinstance(A(), A) # returns True type(A()) == A # returns True isinstance(B(), A) # returns True type(B()) == A # returns False a = 111 isinstance(a, int) # True python中有一种old-style class 这些类用type直接取得到的都是instance， 也就是所有的类实例都是一样的。在后来的new-style class中，得到的会有区别但是，依然不能很好的判断子类的问题。
type 创建一个类型 # 这个用法我看到的时候反正是一脸懵逼，莫非是用来动态创建类用的？
用法：
#type(classname,(parents,...),{attribute}) #第一个参数classname是类名,第二个是一个父类元组，没有可填空元组，第三个参数是类属性字典。 #!/usr/bin/env python # coding=utf-8 class XA(object): a = 1 XB = type(&amp;#39;XC&amp;#39;, (object, ), dict(a=3)) Xa = XA() Xb = XB() # Xc = XC() # syntax error， there is no such a class named XC， only XB as a llegal class name.</description>
    </item>
    
    <item>
      <title>python 多线程和异步</title>
      <link>https://Paladnix.github.io/posts/python/python-multithreaded/</link>
      <pubDate>Fri, 21 Sep 2018 13:38:39 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/python/python-multithreaded/</guid>
      <description>python 的多线程还有协程这种东西。
线程池 # 关于多线程的实现，各种语言基本上都是一样的。
一种是集成一个线程的基类，然后重写一个run()函数。这类写法比较好理解，非常直观就是创建一个线程交给操作系统。
因为每个线程都有确定的程序起点、执行顺序、程序终点。因此这个函数就是起点。
另外一种就略有区别，Java中就是实现一个接口，在python中没有接口就是直接传个函数去构造出一个线程。Java中的接口其实很不好理解，因为这个接口只是实现了一个逻辑在run()函数里， 实例化这个类的时候并没有创建这个线程，还要单独用这个类的实例去再实例化一个线程。然后在start这个线程。
无论是那一种，在底层都是一样的。就是把一段逻辑写进一个函数中，作为一个起点用来生成一个线程资源。而这个工作，都是基类Thread来实现的。
因此只要给Thread类一个程序入口就可以构造出一个线程了。
线程的启动和设定都很好解决。有一个问题就是创建线程也是要话费时间的。因此就有线程池的思想。
线程池的优点:
避免线程的创建和销毁带来的性能开销。 避免大量的线程间因互相抢占系统资源导致的阻塞现象。 能够对线程进行简单的管理并提供定时执行、间隔执行等功能。 两个单词区分一下：async（异步）、 sync（同步）</description>
    </item>
    
    <item>
      <title>cuda</title>
      <link>https://Paladnix.github.io/posts/others/cuda/</link>
      <pubDate>Fri, 21 Sep 2018 13:37:29 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/others/cuda/</guid>
      <description>任何事情都不是突然出现的，曾经有一段时间，关注了很多公众号，突然就发现有些框架和库突然就出现了并就非常热了。 但是后来渐渐发现，其实这个东西应该很早就出现了，只是那个时候还没有公众号做推力，只是在小范围内知名。 但是这突然的大热让我非常的惶恐，深深的感觉自己跟不上时代的脚步，当然实际上，我也确实没跟上。
NVIDIA 在2006年就推出了CUDA，而我知道这个东西，是在2017年。 用于使用GPU进行并行计算。使得普通搭载Geforce显卡的笔记本也具有大规模并行处理的能力。 传统的并行计算基于大规模集群的CPU进行，成本高，而使用GPU进行并行计算的成本就小很多。 CUDA的开发并不难，其提供了一个编译器，和一些C语言的库。我们使用C语言结合库，编写代码，然后使用nvcc进行编译，得到可执行文件，然后运行就可以了。 封装了对GPU的操作。
Ubuntu安装Nvidia # 主要的安装须知都在这个文档里说明了：Nvidia Cuda Installation for Linux
前期准备，下载cuda Toolkit
Disabling Nouveau
Create a file at /etc/modprobe.d/blacklist-nouveau.conf with the following contents: blacklist nouveau options nouveau modeset=0 Regenerate the kernel initramfs: $ sudo update-initramfs -u 重启，进入命令终端启动cuda。 直接Alt + &amp;lt;F3&amp;gt;就进入了。然后找到cuda开始运行。按照提示一点一点装就可以了.
重启。</description>
    </item>
    
    <item>
      <title>创业者</title>
      <link>https://Paladnix.github.io/posts/self/fight/</link>
      <pubDate>Mon, 09 Jul 2018 03:41:30 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/self/fight/</guid>
      <description>其实这一次算是第一次正式的作为一个创业者，在创业。
我这个人 # 我的性格里埋藏着创业者基因。我终究会走上创业的路。 这是很久以前，当我还是个中学生的时候就有了的心理准备。当我开始思考以后要做什么工作的时候，我总是看不到我在什么岗位上会有比较好的表现。我对自己的认知好像一直都还算准确，一般都会有点超出自己的实际能力吗，不过也都是努力一下或者说，运气好一点就达成的高度。 因此我常常会从一个独立的从业者角度去思考问题，因为找不到自己的位置。并且对于家里面的找个稳定工作的想法也有些本能的排斥，所以我其实一直都准备好了去创业。
刚上大学没多久，我在社团中的经历让我发现自己找不到一个合适的位置可能还有一个原因，就是我的实际能力在什么位置都有很多剩余。这些剩余会让我在考虑问题的时候超出我的岗位范围。一旦开始思考这些更大局一些的东西，就会感觉目前拥有的权利无法实践自己的想法，因此也不适合待在一个太小的位置上。 对市场经济学的了解、对心理学的把握和直觉、对基本规律的探察，等等这些，让我会思考很多，有思考，有结论，就会有决定，所以我应该是做决定的一个角色，否则会活着很压抑。
我不认为创业一定要搞个几百亿的上市公司才算是创业。我理解的创业是开辟战场。相比较进入一个竞争激烈的行业并在其中立足，我更倾向于去开辟一个新的战场。或许很多资本都想要新的战场，但是没有这么多机会。 我对自己的定位差不多是个破局者，因为思维具有一点点创造性，性格中有冒险精神，勇气和风险把握，还有点固执，追求完美。最重要的是，无所牵挂。
作为一个程序员，创业其实会简单点，因为自己可以做开发，这是笔不小的开销，省下了。 所以在学习计算机专业的过程中，我努力把自己打造成一个单兵作战能力很强的特种兵。学习使用各种装备，以期在需要的时候用最直接的方式解决需求。
上帝送给创业者的一脚飞踹 # 创业的念头真正形成是今年的4月份，这种感觉越来越强烈，但是仅仅是感觉到自己要创业了，但是并不知道要做些什么，所以有一点点的焦虑，想尽快的做完手头的毕业设计然后来思考这件重大的事情。 等到5月份的时候，一切之前的铺垫都将创业的方向指向了一个我最熟知的领域。我好像也暂时想不出什么其他的东西。那就朝这个方向去吧。
当方向确定以后，还是不知道具体怎么做，从哪开始，做什么？ 整天处于迷茫和乐观的辗转状态。这样又过了半个月，逐渐的放下了毕设的包袱，心情轻松很多，也更乐观了。仔细的分析了一下自己有什么，要付出什么。 结果很感人，就是自己什么都没有。除了不多的时间、开发能力、竞赛经验和知识。 足够了，这些东西不用，放着也是放着，用了，就算什么都没得到也不亏，至少自己的开发经验又得到了提升。
做好了心理准备，接下来就是找个东西开始干吧。 市场在哪？从哪下手？什么周期？
摆在我面前的选择，其实还是很少，甚至是没有选择，根本就没啥路能走。 思考了许久，掂量着徐州这个市场能不能受的了我的新模式。掂量来掂量去，也不确定。 时间就这么往前走，我选定了徐州这个市场，但是我不懂怎么打开它，我甚至还没有非常了解这个市场。我给自己定了个时间，6.4日，徐州邀请赛过后要解决这个问题。
我直到比赛结束了，我还是不知道我接下来这一步该往哪里下脚。我只知道我明天就得有答案，明天得去一中一趟。 怎么有答案？去一中做什么？找谁？怎么说？ 不知道。
那个傍晚和晚上，我站在徐州市中心，看着这个我生活了10几年的城市，太陌生了。 曾经我做为这个城市的一部分，在内部游走。现在我要站在这个城市的面前，打开他。忽然感觉这个城市太大了，根本无从下手。
我跟一些人讲了自己要创业，但是具体的创业方案，也都是含糊其辞，往往都是“等到。。。时候就知道了。”这种答案，我也跟这些人说我明天就要解决一些问题，要确定下来了。 或许就是这些dead line起的心理作用，让我没有像以前一样退缩。虽然我都不知道今晚要住哪，下一步该往东还是该往西走。曾经只敢打打嘴炮，真到要硬着头皮往前走的时候基本都会退堂鼓震天响。
找了个市中心比较便宜的宾馆，住下了。 下午比赛身体很不舒服，没睡好，被晒了一小时，特别困，已经无法思考了。肾结石也在今天突然痛起来。 勉强睡了半小时，受不了了。得去医院。 把自己收拾一下，不带多余的物品，出门，医院不远，穿过广场，对面就是。询问前台、挂号、做B超。。。突然特别的有礼貌，觉得自己跟这座城市有一点点不一样了。不像那么豪放了，倒是有很多苏州的从容和优雅。 从医院出来，大概也没那么疼了。华灯初上，徐州这座城市的节奏还是很慢的，毕竟故乡，触景生情。 大概是肾结石闹的，把精力转移了，没有过多的担心明天的事情，干脆鸵鸟心态，不管了，先逛逛以前常去的地方，真的很感慨。 把病历和检查单什么的都撕巴撕巴扔垃圾桶，手插裤兜走走吧。走着走着，当年高中的感觉又有点回来了，孤独、傲气、不屑，悲怆的英雄主义。
走了一圈，回到了宾馆，睡吧。努力了半天，十点多，还没睡着。 算了，刚好楼下KTV，唱歌去吧。 开了个房间，专心的唱歌了。
3点多，终于困意来了。睡到了10点。
醒过来的时候，才是真的崩溃。 这次是真的没法躲了，说这明天，明天已经到了，而且都10点了，上午基本做不了什么了，如果不赶快安排，下午也做不了什么了。 硬是在床上坐了1个小时。 要不算了，回苏州吧，徐州就这样，什么城市，什么市场，自己心理没点B数吗。。 不行，啥都是自己分析的，没有实地接触过，不能这么搞。
最后还是逼了自己一把，给高中班主任发消息，“老师，下午去学校找你。”
只要没了后路，剩下的就好办了。准备去吧！ 想了1个小时，也没斟酌出该怎么开口自己创业的事情，怎么打听怎么问。都快走到学校门口了，才想起来两手空空啊。 路边买了两个最大的西瓜，拎着上五楼，手指差点都断了。
来都来了，不知道怎么开口就不开吧，先叙叙旧。三心二意，有的没的。
有的时候，就是运气好。同办公室居然是信息学老师。剩下的事情，就顺理成章了。
1个小时，完全碰运气的一个小时，谈成了。
创业者的兴奋剂 # 那个时候我还不能理解，为什么总说：“创业者都是幸福的”。 这句话是到今天我才刚刚能理解。 今天晚上，收到消息，报名不理想，也就意味着，今年的规模很小，基本不赚钱。突然一下我感觉我的兴奋剂就断了，一下子跌出了之前一个多月的高昂的士气。
过去的这一个多月，我一个人，前端、后端、数据库、判题核心。夜以继日，根本不累好吧。什么是饿？什么是休息？不存在的。 我一天能在键盘上写13个小时代码，就是这么疯狂。 我系统的整理了react、redux、router、reduxApi这些前端的库，又搞了restful的jersey，然后是redis数据库。在此之前，我从未用其中任何一个写过完整的项目。从前到后，js、java、shell、node、redis。。。 这一个月，耗尽了我三年的工程知识，用尽了我在阿里学来的功夫，又自己打通了多少的小体系。我三年都在准备，结果三年的准备没抵过这一个月的成长。
创业者都是幸福的，你完全没有痛苦，那个希望给你夜以继日，给你不知疲倦，连调整状态都不需要，就是这么强劲。
创业者的乐趣 # 今晚听说不太理想，虽然短暂的跌出了兴奋状态，但是需要调整一下心态和战略，重新加入战局，继续战斗。 创业不是一锤子买卖，就是这样不断的把握市场，生生的撬开市场的脑袋。</description>
    </item>
    
    <item>
      <title>shadowsocks 搭建</title>
      <link>https://Paladnix.github.io/posts/others/shadowsocks/</link>
      <pubDate>Fri, 29 Jun 2018 16:59:05 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/others/shadowsocks/</guid>
      <description>正常的上网需要三个部分。
server local SwitchOmega shadowsocks server # 租一个境外的服务器vps，然后搭建如下：
sudo apt install git python python-pip pyton3 python3-pip pip install git+https://github.com/shadowsocks/shadowsocks.git@master # 编辑配置文件： # sudo vim /etc/shadowsocks.json { &amp;#34;server&amp;#34;: &amp;#34;149.28.194.217&amp;#34;, # 服务器IP &amp;#34;server_port&amp;#34;: 8964, # 服务器上的服务端口 &amp;#34;local_address&amp;#34;: &amp;#34;127.0.0.1&amp;#34;, # 本地地址 &amp;#34;local_port&amp;#34;: 1080, # 本地需要代理的使用的端口 &amp;#34;password&amp;#34;: &amp;#34;www1964878036&amp;#34;, # 密码 &amp;#34;timeout&amp;#34;: 300, # 超时时间 &amp;#34;method&amp;#34;: &amp;#34;aes-256-cfb&amp;#34; # 加密方法： aes-256-cfb, 还有一种比较快的：salsa20 } # 直接启动： ssserver -c /etc/shadowsocks.json # 后台运行： ssserver -c /etc/shadowsocks.json -d start # 停止服务 ssserver -c /etc/shadowsocks.</description>
    </item>
    
    <item>
      <title>再出发</title>
      <link>https://Paladnix.github.io/posts/self/self-2/</link>
      <pubDate>Mon, 25 Jun 2018 01:40:29 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/self/self-2/</guid>
      <description>永远都不要太乐观，也别放弃
最近一段时间作为一个完整的开发工程师来做一个项目，一方便希望能经过一个完整的项目的锻炼把自己的工程底子建立一下，总不能一直飘在算法上，还是要掌握程序员的最低生存本钱的。
这一次的工程算是一个比较熟悉的，依然是Online Judge，只是这次不再是以一个极客的思维来对待，而是以一个解决问题的工程师的身份。
曾经用极客的思维去考虑这些部分，心里想的是怎么造出更好的轮子。在这个过程中其实需要学习很多底层的东西，尤其是对于Judge核心的设计和实现是要很多关于操作系统的交互。
但是到最后也没能自己搞出来什么比较好的东西，只能说是搞了一些还不错的玩具出来了。同时对底层的一些机制有了个粗浅的理解。
我本质是非常喜欢打通基本的原理的，有些东西没有搞懂总是不太想去动手，怕自己走歪了路，搞得不专业了。这样的追求是我的喜好，并不能作为一个常态存在，因为毕竟学无止境，更多的时候应该是做一个工程师存在。工程师是要 能够非常高效且优质的组织资源去解决问题的，而不是纠结在底层的原理如何如何。当然越是经验丰富、知识扎实的工程师的组织能力越强。
这次我的主要尝试选择了两个我比较看好的，也处于中间状态的技术：
前端： react、redux、node 后端： jerey、tomcat、redis、mysql、mybatis 前后端完全分离的架构 这样的技术选择其实是面有点大的，基本涵盖了整个前后端，因此这个项目的周期中会遇到许许多多的实际问题。 主要的会表现在：
前端 # react体系的架构 项目结构的设计 UI操作 浏览器相关问题 异步请求 这其中前期已经基本能用起来的react体系，算是已经过了一关，后面的浏览器相关的异步请求让我感觉有点头大。 一方面用的不是传统的ajax，是新兴的fetch。在使用fetch的时候又使用了redux-api的库，这个库国内很少人使用，基本没有中文的文档也没有什么人踩坑的经验，所以在理解和使用的时候都很慢。 不过这个过程中也让我学会了怎么去接触一个新的库，其实看文档是一方面，更快速的方法是搭建起来，不断的输出一些东西，这些变量是什么，什么结构的，会比文档直观很多。这个也是在后期的理解的时候才想起来，所以导致前面的搞的还是很痛苦的。
但是现在面临着一些问题，搞得我多线作战很是迷茫。
问题是这样 ：
fetch原生的操作会让浏览器自动的补全content-type， 但是不知道为什么，使用redux-api库的时候就无法补全这个项，导致一些请求的请求头有问题，需要手动编写。尤其是在上传文件上。 其次后台选取的java强类型语言，对请求的type要求非常严格，如果使用的是浏览器自动生成的type，可能会不匹配。同时后台也可以使用更原始的方式，就是直接接收context的内容，得到一个request自己再操作，其实这是以前的javaweb的操作方式。 现在就面临了一个选择的问题，到底是后端做出让步还是前端做出让步？ 虽然都是我在写，但是面临这样结构改动还是很纠结。
~~ 出去吃了一顿饭。顿悟
转变思维 # 不存在能解决一切问题的框架，所以不能一味的寻求框架解决方案。完美主义的人会比较痛苦。
因为没有什么框架能解决你的所有问题，也不是什么问题都有正解的，所以要站的高才能获得好的设计。一定要站的足够高，如果不能高到技术之上，就高到需求之上，高到架构之上，才能在设计出合理的架构。
抽出框架最优越的特性，用来实现一些需求，其他并不适合用这种框架来解决的问题就不要再死守在框架上了。
问题迎刃而解。
有的时候就是要跟自己多讲讲道理，就明白了。可能这就是分裂的好处吧。不是一个人在战斗。</description>
    </item>
    
    <item>
      <title>apache2 配置多端口服务</title>
      <link>https://Paladnix.github.io/posts/web/apache2/</link>
      <pubDate>Mon, 18 Jun 2018 21:48:42 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/web/apache2/</guid>
      <description>多端口多服务配置 # 个人服务器和一些低访问量的服务，使用apache2比较方便。 安装完以后打开默认的页面会看到有个介绍：
/etc/apache2/ |-- apache2.conf | `-- ports.conf |-- mods-enabled | |-- *.load | `-- *.conf |-- conf-enabled | `-- *.conf |-- sites-enabled | `-- *.conf 这就是apache2的基本配置文件
1. apache.conf # 这个文件基本不用动，是apache的总配置文件。我只修改一项：
&amp;lt;Directory /var/www/&amp;gt; Options Indexes FollowSymLinks AllowOverride all # default is None, change to all. Require all granted &amp;lt;/Directory&amp;gt; 2. ports.conf # 这个文件用来添加监听的端口：
# If you just change the port or add more ports here, you will likely also # have to change the VirtualHost statement in # /etc/apache2/sites-enabled/000-default.</description>
    </item>
    
    <item>
      <title>ngrok服务端与客户端</title>
      <link>https://Paladnix.github.io/posts/others/ngrok/</link>
      <pubDate>Sat, 16 Jun 2018 23:19:50 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/others/ngrok/</guid>
      <description>自己搭建Ngrok服务器 # 使用平台：Ali云 Ubuntu 16.04 Go编译器版本： 1.9.1 依赖： gcc、cmake、build-essential、git 1. Ubuntu安装Go编译器 # wget https://dl.google.com/go/go1.9.7.linux-amd64.tar.gz tar -zxvf go1.9.7.linux-amd64.tar.gz mv go/ /usr/local/ # vim /etc/profile export GOROOT=/usr/local/go export GOPATH=$HOME/go export PATH=$PATH:$GOROOT/bin:$GOPATH/bin # save &amp;amp; exit vim source /etc/profile go version # 显示Go的版本即安装成功 2. 安装其他依赖 # sudo apt install -y git gcc cmake build-essential screen 3. 下载ngrok源码并编译 # git clone https://github.com/inconshreveable/ngrok.git ngrok cd ngrok # 生成ssl自签名证书， 需要被编译进最终可执行文件中 NGROK_DOMAIN=&amp;#34;tunnel.paladnix.top&amp;#34; # 注意域名换成你自己的 openssl genrsa -out base.</description>
    </item>
    
    <item>
      <title>编写Bash脚本</title>
      <link>https://Paladnix.github.io/posts/bash/bash/</link>
      <pubDate>Fri, 18 May 2018 15:45:40 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/bash/bash/</guid>
      <description>作为一个Linux用户，不会自己写Bash脚本，简直太讽刺了，跟windows用户有什么区别，用鼠标点一点。 使用Bash脚本来解放生产力非常重要。不要做重复性的无意义的劳动。
Bash 脚本头（shebang） # 这个东西汉语里叫&amp;quot;蛇棒&amp;quot;，难听。 以#! 开头的，在没有指定解释器的情况下，使用后面路径的解释器运行。
常用的bash命令解释器： #! /bin/bash
Command arguments # Variables About Example $# The number of arguments. while [[ $# -gt 0 ]] do &amp;hellip; done $1 The first argument. echo &amp;ldquo;$1&amp;rdquo;; KEY=&amp;quot;$1&amp;quot; $@ All arguments as a list. for i in &amp;ldquo;$@&amp;rdquo; shift Past one string of commands that splited by space. shift # one line </description>
    </item>
    
    <item>
      <title>tensorflow</title>
      <link>https://Paladnix.github.io/posts/others/tensorflow/</link>
      <pubDate>Thu, 12 Apr 2018 00:32:42 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/others/tensorflow/</guid>
      <description>引言 # Tensorflow究其本质还是一个编程框架，只是这个框架主要面向机器学习和深度学习领域。我们应该还是要使用学习框架的方法来学习他。
很多时候我们要先分清楚问题的主要矛盾是什么。 在很久以前，我学习视频剪辑。那个时候我对于视频剪辑一窍不通，好不容易安装上pr又要开始漫长的学习怎么使用。 我看了很多的视频和博客，教我如何使用这个软件，面对错综复杂的按钮和组合操作，我不知道什么东西在哪，有什么作用。当我明白了什么工具在什么位置的时候，我发现我依然不会做视频。 后来，我想到了，我从来就不懂如何剪辑视频，而不是不会使用这个软件。 如果我清楚的明白调整alpha通道会产生什么效果等一系列参数的作用，我自然就会明白的当前需要做什么，需要改变什么值，去找对应的按钮，而找对应的按钮只要很简单的搜索一下就可以了。 所以，软件并非是为了我这样的小白设计的，而是为专业的人设计的，因此我才会看着琳琅满目的按钮不知所措。
很多刚准备入门机器学习和深度学习的同学，大家的问题可能并不是不会使用Tensorflow这个框架，而是不会设计Model，不懂一个Model需要先做什么后做什么，在什么层次需要应用什么函数来达到效果。 换个角度来说，就算熟悉的掌握了Tensorflow的每个函数如何调用，也未必就能实现神经网络。 因此，Tensorflow做为一个框架，并不是让你对每个函数都了如指掌，而是当你想做什么动作的时候，知道框架中已经实现了这个功能，你知道要去寻找什么。而寻找对应的函数，就是很简单的问题了，然后再经过几次使用，你就完全可以记住了。
学习框架就是要理解它的哲学 # 框架为我们提供了一些功能上的便利，为了实现功能的通用性和可扩展性，框架需要一些辅助机制，来确保可扩展性和通用性。
Tensorflow这类算法的框架，相比较复杂的业务工程类框架要简单很多。
Tensor: 张量 flow ： 流
他的名字已经揭示了他的核心逻辑。Tensorflow 中的计算使用一个有向图(计算图)来表示。其中每个运算操作作为一个点，点与点之间连边，数据就是这里的Tensor，Tensor在其中流转，最终完成计算。
一个计算图描述了一个计算的流程，没个点可以有任意多的输入和输出。有一些边并不是用来流转数据的，而是用来依赖控制，用来保持数据在正确的时间被运算。
因此我们的代码中，大部分是在描述一个计算图，而当这个计算图被描述完毕后，需要触发一个Session来执行这个计算图。
我们不能事无巨细的讲解框架中的设计逻辑。这里我们简要介绍比较重要的几个元素，是深入学习之前必须先搞透的东西。
Variable # Variable是一类特殊的运算操作，每次执行计算图后，Variable中的数据tensor会被保存下来，同时在计算的过程中也会被更新，比如神经网络的系数，每次训练都会被更新，最后会被保存下来。
Session # TensorFlow执行计算图需要实例化一个Session类来执行。调用Session的run方法，他可以自动计算所需计算的节点并按照依赖顺序计算他们，并且每个Session持有一些资源， 比如Variable，在计算结束的时候，我们要关闭Session以减少开销。
小经验 # 学习框架有一些方法，是很多实践总结下来的经验，分享一下。
过程 # 学习框架的过程大致是这样的：
理解核心概念/理念 -------&amp;gt; 入门经典代码/项目 -------&amp;gt; 核心类的代码 （设计哲学） （加深理解） (这些代码会大体勾勒出整个框架的逻辑) | | V ----------&amp;gt; 更复杂的代码/项目 | （学习如何使用/最佳实践） | | | | | V |__________ 更多核心类的实现 (会让你对每个部分设计目的更清晰， 帮助你融会贯通) 方法 # 前期刚接触的时候，多看博客，开始接触代码后，学会用好源码。
注意！这里的源码并不代码，而是源代码中的注释！
框架的代码都是相对规范的，在核心的类中都有非常详细的注释，解释了该类的作用、调用方式、特点、注意事项等，还可以直观的看到参数的情况。很多框架的API文档其实就是这些注释换个地方给你而已。 因此与其看文档，有的时候源代码会更好用。当然你需要熟练的使用IDE和代码跳转。</description>
    </item>
    
    <item>
      <title>Tutorial of anaconda &amp; 原生虚环境</title>
      <link>https://Paladnix.github.io/posts/python/anaconda/</link>
      <pubDate>Wed, 28 Mar 2018 17:31:19 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/python/anaconda/</guid>
      <description>什么是conda？ # anaconda是一个用于科学计算的python发行版。其中预置了一些用于科学计算的库，诸如numpy等。
并且包含一个包管理系统，可以方便的安装相关的库。
我使用conda主要是搭建机器学习的环境。
Install # 在conda的download页面找适合自己的安装包下载，在Ubuntu上会得到一个bash脚本文件。 也可以使用命令：
wget https://repo.continuum.io/archive/Anaconda2-5.1.0-Linux-x86_64.sh 然后使用root权限运行就可以了。 在运行的过程中，会询问你一些设置方案，如安装的路径、是否要添加进入PATH等。
检查是否安装成功 # 使用命令：
python -V 出现：
Python 2.7.14 :: Anaconda, Inc. 说明安装成功
使用conda创建自己的开发环境 # 学过python的都知道，py的版本兼容实在太随意了。因此py为了解决同一台电脑上需要不同py环境的问题，设计了一个虚环境。也就是我们可以创建一个虚环境，然后进入这个虚环境安装我们需要的包，这些包的作用范围就是在这个环境中。
因此也就实现了环境隔离。 一般我们在开始一个开发的时候，都会先创建一个虚环境。
使用conda创建tenserflow训练环境 # # 创建名为:nlpcc-1.0 的虚环境 # 指定python版本为2.7, tensorflow版本为1.0的gpu版， # 需要安装anaconda conda create -n nlpcc-1.0 -c anaconda tensorflow-gpu=1.0 python=2.7 # 为当前环境安装包 conda install numpy # 升级包的版本 conda update numpy # 删除包 conda remove numpy # 列出当前环境的包 conda list # 删除一个环境 conda remove --name nlpcc-1.</description>
    </item>
    
    <item>
      <title>Vimium - Google-Chrome-Plugin</title>
      <link>https://Paladnix.github.io/posts/others/vimium/</link>
      <pubDate>Tue, 20 Mar 2018 17:34:37 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/others/vimium/</guid>
      <description> What&amp;rsquo;s this # Vimium 你可以认为这是一个Chrome下的快捷键设置集合。这个快捷键集合继承了Vim的快捷键方式，力图做到全键盘流畅使用浏览器。
How to use it # 这里介绍默认的快捷键设置，你也可以添加自己的快捷键。对于你的Chrome帐号，这些是会被同步的，也就是你在不同的电脑上使用登录了你的账户的Chrome浏览器都可以使用这个设置。
可以打开这个插件，看到下面这个图片。
快捷键 功能说明 j 向上滚动 k 向下滚动 h 向左滚动 l 向右滚动 gg 到达Top G 到达bottom d 向下滚动半页 u 向上滚动半页 r 重新加载这一页 yy 复制当前页的链接到粘贴板 p 在当前页打开粘贴板中的链接，如果复制的是文字直接使用默认搜索引擎搜索 P 在新的标签页做上一操作 gi 使当前焦点换到页面的第一个输入框中 f 显示当前页面所有可点击部分，并在当前页打开对应链接 F 在新的标签页打开 gf （没用过，也不知道有啥用，用来选择下一个结构?） o 出现一个输入框，用来打开history or bookmark 中的链接，备选与你输入的东西相匹配的 O In a new Tab b 同o差不多，只备选bookmark中的链接 B In a new Tab T 在你已经打开的Tab里面搜索，可以直接跳转 / 搜索 n/N 跳至下一个/上一个搜索到的点 H 历史后退 L 历史前进 J 跳到左边一个Tab K 跳到右边一个Tab t 打开新的Tab ^ 跳到上一次你停留的Tab x 关闭当前Tab X 重新打开关闭的标签页 </description>
    </item>
    
    <item>
      <title>Tutorial of Taskwarrior</title>
      <link>https://Paladnix.github.io/posts/linux/taskwarrior/</link>
      <pubDate>Tue, 13 Mar 2018 13:45:32 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/linux/taskwarrior/</guid>
      <description>Taskwarrior 是一款命令行的TODO应用，功能强大，且使用逻辑简单方便，命令行的操作非常适合程序员。 （基本上能在命令行解决的问题就不要用GUI， 能用键盘解决的就不要用鼠标。）
目前我使用到的功能有：
添加task 给task修改所属的project、截至日期 更改task的状态，如：start、done 修改task的priority 添加tags给task 给task添加task依赖关系 &amp;hellip; 基本使用 # 添加 task task add xxxx [project:xxx] [priority:xx] [due:xx] 修改task状态 task ID start task ID done 修改task信息
task ID modify [project:xx] [due:xx] [priority:xx] 其中due常用的选项有：
eom : end of month 添加tags
task ID modify +house +problem 其中有个特殊的tag是：next， 这回提升这个task的优先级。
task ID modify +next 添加依赖关系 task ID modify depends:OTHER_ID 命令格式 # task [filter] [command] [modifications | miscellaneous]
如果将Task比作一个类，可以把每个task都理解成一个实例。我们将实例存储在一个文件中，task就是用来处理这个文件的改动、信息筛选的命令。
filter-筛选器 通过一些条件，筛选出我们每次操作的对象。 # 筛选所有pending的task，并计数 # task status:pending count # 筛选所有tag是work的，并计数 # task +work count # 筛选所有tag不包含work的，并计数 # task -work count 如果有多个条件，可以使and、or来进行连接</description>
    </item>
    
    <item>
      <title>ACM-collection</title>
      <link>https://Paladnix.github.io/posts/acm/acm-collection/</link>
      <pubDate>Fri, 09 Mar 2018 10:46:07 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/acm/acm-collection/</guid>
      <description>汇总做过的题目：来源、类别、题意概括、难度等。使用&amp;lt;Ctrl&amp;gt; + F 的方式检索。
Title Link Tags Description Picking Strings CF 923-D 字典树 还没看 </description>
    </item>
    
    <item>
      <title>Lucene（一）</title>
      <link>https://Paladnix.github.io/posts/others/lucene-1/</link>
      <pubDate>Tue, 06 Mar 2018 11:21:33 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/others/lucene-1/</guid>
      <description>Lucene 是apache基金会下的一个项目，用于匹配搜索的库。可以方便的集成进入各种应用中，并在不同的应用场景下有不同的衍生子项目。是基于Java的全文索引引擎。</description>
    </item>
    
    <item>
      <title>git 进阶一</title>
      <link>https://Paladnix.github.io/posts/git/advanced-git-1/</link>
      <pubDate>Sun, 21 Jan 2018 03:20:12 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/git/advanced-git-1/</guid>
      <description>最近总是在沉迷游戏，而且笔记本太老了，开枪太卡。 这样下去太影响学习了。 决定组个台式机，顺畅的打游戏。
工作进度保存与恢复 # 这个功能主要针对的是工作区和暂存区，版本库是不需要保存的，因为他本身就是一种保存进度。
使用git stash 命令会将工作区和暂存区的状态进行保存。 其完整版的命令是这样的:git stash [save [--patch] [-k | --[no-] keep-index] [-q | --quiet] [&amp;lt;message&amp;gt;] ] 其中，-k 参数会保留当前的暂存区，默认会重置暂存区。 这个命令会将工作区和暂存区的内容都重置到上一次提交的状态！ 这个也很好理解，按照我们模块化开发的思路，当我们写某个东西写到一半的时候，突然需要中断，然后去写另外一个东西，这个时候，不能把这个一半的东西放到代码中，所以会被重置会上一个提交。
使用git stash list 命令可以查看已经保存的工作进度。
使用git stash pop [--index] [&amp;lt;stash&amp;gt;] 可以恢复进度，--index参数指暂存区也恢复，否则只恢复工作区。stash参数就是list中的选项，可以定点恢复，否则恢复最近的一次。
git stash clear
git stash drop delete the newest one.
git stash apply 恢复但是不删除。类似于pop;
git stash branch &amp;lt;branch&amp;gt; 基于进度创建分支。
需要注意的是，还没有被跟踪的文件是没有办法被保存的。
Git 忽略追踪 # 很多文件诸如编译出来的文件，我们不应该放在git仓库中，这个时候要避免这类文件被追踪到，我们可以写一个文档来标注这些文件。
在仓库的目录下写一个.gitignore 的文件，文件每一行写一条规则，对应匹配到的文件就会被忽略。这个文件的有效范围是包含其子目录的。
gitignore 语法 # #开始或空行都会被忽略 可以使用通配符， *, ?, [abc]等。 以/开头，表示要忽略的文件在本目录中，而不是在子目录中 以/结尾，表示忽略整个文件夹, 不以/结尾的，同名的文件和文件夹都忽略。 以！开头表示本文件或目录不忽略，尽管之前有相关规则匹配到。 如果我们将这个文件加入到版本库中就会被版本库共享，给这个文件自己加一个忽略规则就不会被加入到版本库。</description>
    </item>
    
    <item>
      <title>git 进阶</title>
      <link>https://Paladnix.github.io/posts/git/advanced-git/</link>
      <pubDate>Sat, 06 Jan 2018 00:28:07 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/git/advanced-git/</guid>
      <description>仓库概念 # 在git中，仓库的概念十分简单，也是最核心的概念之一。 仓库用一个文件夹来存储和描述，这个文件夹就在你项目的那个目录下，是个隐藏文件.git/。除此以外没有其他的位置存储这个仓库想关的信息。 这种仓库的概念非常的简约，会有一个问题，就是不小心删除的话就丢失了。因此，git的一般使用要至少进行多机备份仓库，这个备份是很简单的，在git的系统中，只是一个命令。
概念的简约，是Linus设计作品的一个特点，linux的操作系统的很多概念都非常简约。例如文件系统的概念，无论是文件夹还是设备，统一使用文件的概念去设计和使用。在这里，一个版本控制的单元使用仓库的概念，且没有那么多复杂的控制文件，就在一个小小的文件夹里，拷贝走也完全可以使用。
这种分布式仓库的概念中，没有主从关系，也没有中心关系，彼此是独立的，可以做仓库同步和融合，但是都是可控制的。
工作区 &amp;amp; 暂存区 &amp;amp; 版本库 # 这三个概念是git的核心逻辑。
工作区 ： 就是你的实际的目录和文件。 暂存区 ： 就是中间的一个过渡区，连接了版本库和工作区。 版本库 ： 就是实际存放各个版本和分支的地方。
其原理是这样的，暂存区维护一份目录树，没有实际的文件。这个目录树与工作区的目录树是不一样的。工作区的目录树是操作系统中文件系统的目录树。暂存区就是存了一些文件名，时间戳，文件长度等信息。
很多时候我们会有这样的经历，我想把一些密码设置的东西，或是笔记放在我当前的目录下，但是我并不想把这部分放到仓库中，因为我会把仓库共享出去的嘛。这个时候，这个文件是存在我的工作区的，但是并不在我的暂存区，由于仓库的目录树必须由暂存区的内容来写入，所以在版本库中也不会有。
当我们对一些问件做了修改之后，使用git status -s就可以查看我们的当前哪些文件被修改但是没有提交到暂存区。
使用git add XXX 可以将当前在工作区修改的部分提交到暂存区，这个时候暂存区的目录树会做出修改，更新相关文件的时间戳等信息。 同时，我们的文件内容会被写入到对象库中，生成一个新的对象。并且这个对象会有和ID，这个ID会被写入到暂存区的目录树中。
使用git commit 的时候，会把暂存区的目录树更新到版本库中对应的分支的目录树中。 这个时候才是真正的写到了版本库中。
使用git reset HEAD 的时候，暂存区的目录树会被版本库中的目录树覆盖，也就是还原到了上次你提交的版本。但是此时工作区的修改是不会受到影响的。
使用git rm --cache &amp;lt;file&amp;gt; 的时候，会直接把暂存区的目录中对应的文件删除，但是工作区不受影响，不加--cache会将工作区的一并删除。
使用git checkout 或 git checkout -- &amp;lt;file&amp;gt; 命令的时候，会用暂存区中的文件去替换工作区的文件。 也就是当你写一个东西，写着写着发现不好，需要去掉，但是你已经修改了很多个文件的很多个部分，手动删除不可能做到，你可以使用这个命令来把你工作区的内容回退到你之前提交到暂存区的时候的样子。 因此，选择合适的时机进行提交操作十分重要。要在自己的开发节点上及时add，及时commit。这样可以方便回退。
使用git checkout HEAD 或 git checkout HEAD &amp;lt;file&amp;gt;，会用版本库中的对应分支的文件来替换暂存区和工作区的文件，这个动作可以参考上面一条，都是十分危险的动作。
有了这三个东西， 会发现，你好像什么都可以得到。 你可以历史查看你每次提交的改动，每个文件的每次提交后的样子你都可以得到。你拥有了一个结构合理，体积很小，速度很快的，无所不知的版本控制系统。 优秀的设计！
Git 对象 # 贯穿在git的各个元素中，都有40位的SHA1字符串的ID。每个ID都标志了一个对象，每个对象其实都是一个文件。 在git仓库的/objects/ 文件夹下，有一堆两个字母命名的文件夹，打开这些文件夹，里面是一些38位字符命名的文件，所以就是这40位的用法。</description>
    </item>
    
    <item>
      <title>Linux 定时任务</title>
      <link>https://Paladnix.github.io/posts/linux/linux-timing/</link>
      <pubDate>Fri, 05 Jan 2018 01:20:02 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/linux/linux-timing/</guid>
      <description>很久以前就想找到一种定时执行任务的方法，下面介绍一种在Linux下通用的，也是最方便的方式。
cron # 这是Linux内核自带的一个定时执行任务的服务。默认是不打开，可以设置成开机自动启动。
要把cron设为在开机的时候自动启动，在 /etc/rc.d/rc.local 脚本中加入 /sbin/service crond start。
这是一个周期性执行某个程序的服务，与at不同，at是一次性的服务。显然这个服务更常用一些。 很多周期性的任务，如定期清缓存，写磁盘，做备份等等。
我用这个命令来自动更新我github.io上的博客代码。
crontab # 这是cron提供的一个命令，用来设定定时任务。 定时任务非常的简单，就是利用配置文件来描述什么时候执行什么动作，所以设定任务也就要写明白这些参数就可以了。
配置文件的基本格式 # 配置文件可以有很多个，存放在固定的目录下。服务启动以后会一起读取然后执行。
配置文件每行是一个定时任务的描述，包括6个字段：
分(0-59), 小时(0-23), 天(1-31), 月(1-12), 星期(0-7,0和7都是周日) 要执行的命令 举个例子：
0 8,22 * * 1-5 echo &amp;#34;Hello&amp;#34; // 在周一到周五的8点和22点的时候输出”Hello“ // // * 通配符 // 同一个字段多个值，用逗号隔开。 // 1-5表示一个区间 这个配置文件很好写，就不多举例子了。
启动服务 # sudo /etc/init.d/cron start // start sudo /etc/init.d/cron stop // stop sudo /etc/init.d/cron restart // restart crontab 用法 # 使用：
crontab –e : 修改 crontab 文件，如果文件不存在会自动创建。 crontab –l : 显示 crontab 文件。 crontab -r : 删除 crontab 文件。 crontab -ir : 删除 crontab 文件前提醒用户。 其中，-e是编辑当前用户的配置文件，默认是存放在/var/spool/cron/crontabs/目录下。 只要服务启动着，编辑保存这个文件，定时任务就设定好了，有的时候可能真正执行会有1-2分钟的延时。</description>
    </item>
    
    <item>
      <title>《Linux 编程实践教程》- 1</title>
      <link>https://Paladnix.github.io/posts/linux/linuxprogramming-1/</link>
      <pubDate>Tue, 02 Jan 2018 16:15:13 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/linux/linuxprogramming-1/</guid>
      <description>2018年恢复写博客的第一篇博客。
「·最近在看书，主要是Linux相关的书，尽管即将要进行NLP的研究生阶段，但是回首自己的本科计算机编程经历其实非常浅薄。这两年的积淀在常用算法和数据结构上有一些，在一些基础理论上有一些，但是距离成为一个程序员还有很大的距离。综合各种因素，我选择将Linux学习更透彻作为程序员的落脚点。这是我作为程序员的自我修养。·」
关于这本书 # 这是一本Linux的基础教材，2004翻译过来的。但是国内貌似很少用，作为了课外读物。
这本书的落脚点是编程实践。其中贯穿着Linux的一些原理和使用，以及编程思维。
包括：用户，文件系统，连接，事件驱动，进程通信，多线程，服务，协议等。以Linux的一些已经实现的功能为基础，进行讲解，再实现。 会涉及很多的编程细节的东西，这是上课不会讲到的。都非常的有意思。做到“知其然，知其所以然”。
本书的风格和套路 # 此书适合初学者，但是任何初学者的书都不是完全适合初学者， 有很多概念和细节都需要读者有些了解才能更好读懂。 我在读本书之前的一天读了一部分《Linux系统编程》。这是一个偏底层概念和细节的书，主要在文件系统，I/O，进程，内存，信号，时间上去为Linux系统编程打细节基础，看起来没那么有趣，因为细节太多，但是确实把文件和I/O的概念给我打通了。 有了这些基础再看本书的第一章，并实现其中的more实例就省力很多。此前一个月左右我看过这一章，但是在写代码的时候还是非常不能理解一些细节。
书中会给出全部的实现，但是并不是完整功能的实现，是一部分功能的完整实现。并将剩下的一些功能的实现作为扩展的作业。 在给出实现的时候，会讲相关的基础知识。
比如在第二章讲Who命令的时候，会先告诉你man命令怎么用，以及文档各个部分是什么，怎么去看相关条目，从man手册的那些部分获得什么信息等。
第一章：more命令的实现 # more命令比较简单的功能就是把文件的内容投射到终端上，并且可以向下翻页或翻行。要能从文件中读取也可以从管道中读取内容。
在Linux一切皆文件的设计理念下，要知道各种I/O都可以作为文件来使用，也就是可以用打开文件的方式来打开。无论是文件、管道、设备(键盘)、重定向数据，都可以作为文件来打开读取。
那么实现这样的功能就没有那么困难了。 整体逻辑就是：
打开文件 读取一定的行数 提示翻页或下一行，接受键盘动作 作出反应，重复。 代码中用到了终端设置接口termios.h，让用户输入的操作不被显示，不用回车，直接进入程序。 用到了与终端用文件交互的方式tty。
Code # #include &amp;lt;bits/stdc++.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;termios.h&amp;gt; using namespace std; const int PAGELEN = 24; const int LINELEN = 512; int see_more(FILE * cmd){ int c; printf(&amp;#34;\033[7m more? \033[m&amp;#34;); // 白色底色 while( (c = getc(cmd)) != EOF ){ if( c == &amp;#39;q&amp;#39; ){ return 0; } else if( c == &amp;#39; &amp;#39; ) return PAGELEN; else if(c == &amp;#39;\n&amp;#39;){ return 1; } } return 0; } void do_more( FILE * fp ){ char line[LINELEN]; int num_of_lines = 0; FILE * fp_tty = fopen(&amp;#34;/dev/tty&amp;#34;, &amp;#34;r&amp;#34;); // 一切皆文件，这个文件标志就是与终端交互。 struct termios initial_settings, new_settings; tcgetattr(fileno(fp_tty), &amp;amp;initial_settings); new_settings = initial_settings; // clflag 局部模式，只在本程序中有效。 new_settings.</description>
    </item>
    
    <item>
      <title>redux-api</title>
      <link>https://Paladnix.github.io/posts/web/redux-api/</link>
      <pubDate>Thu, 23 Nov 2017 14:55:37 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/web/redux-api/</guid>
      <description></description>
    </item>
    
    <item>
      <title>webpack</title>
      <link>https://Paladnix.github.io/posts/web/webpack/</link>
      <pubDate>Tue, 21 Nov 2017 00:21:50 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/web/webpack/</guid>
      <description></description>
    </item>
    
    <item>
      <title>less 笔记</title>
      <link>https://Paladnix.github.io/posts/web/less/</link>
      <pubDate>Mon, 20 Nov 2017 12:36:39 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/web/less/</guid>
      <description>作为CSS的一种扩展语言，使得CSS开发更便捷。
变量 # less中的变量使用@开头。
// LESS @color: #4D926F; #header { color: @color; } h2 { color: @color; } /* 生成的 CSS */ #header { color: #4D926F; } h2 { color: #4D926F; } 甚至可以用变量名定义为变量:
@fnord: &amp;#34;I am fnord.&amp;#34;; @var: &amp;#39;fnord&amp;#39;; content: @@var; --&amp;gt; content: &amp;#34;I am fnord.&amp;#34;; 请注意 LESS 中的变量为完全的 ‘常量’ ，所以只能定义一次.
字符串嵌入 # 变量可以用类似ruby和php的方式嵌入到字符串中，像@{name}这样的结构:
@base-url: &amp;quot;http://assets.fnord.com&amp;quot;; background-image: url(&amp;quot;@{base-url}/images/bg.png&amp;quot;);
作用域 # LESS 中的作用域跟其他编程语言非常类似，首先会从本地查找变量或者混合模块，如果没找到的话会去父级作用域中查找，直到找到为止.
引入文件 # 你可以在main文件中通过下面的形势引入 .less 文件, .less 后缀可带可不带:
@import &amp;#34;lib.</description>
    </item>
    
    <item>
      <title>react 设计概念</title>
      <link>https://Paladnix.github.io/posts/web/react-2/</link>
      <pubDate>Sun, 19 Nov 2017 15:12:18 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/web/react-2/</guid>
      <description>react是一个前端库，着力在创造新的前端渲染的工作模式。 react单个可以做为开发库来单独使用，但是一般我们会将其与其他的相关库一起使用，在使用的时候，基本的react概念是不变的，只是在某些环节发生一些变化。
react 组件的生命周期 # 对于一个react的组件，其生命周期决定了其思维方式。 一个组件什么时候产生实例，在什么时候调用什么函数，决定了这个组件在什么时候做什么动作。
react严格的定义了组件的生命周期，分别是装载过程，更新过程，卸载过程。我们重点是要清楚，在装载和更新的过程中，react组件都要做哪些动作。
装载过程 # 当组件第一次被装载的时候，一次被调用的分别是：
constructor componentWillMount render componentDidMount 这里我们使用的是ES6语法的方式来创建组建，所以有一些老的函数就没有被用到，也就不用再提了。
contructor # 并不是每个组件都需要构造函数，当有构造函数的时候，一定要先执行父类的构造函数。
class Sample extends React.Component{ contructor(props){ super(props); this.state = {foo: &amp;#39;bar&amp;#39;}; this.onClickSubmitButton = this.onClickSubmitButton.bind(this); // this.onClickSubmitButton = ::this.onClickSubmitButton; } } 在构造函数中，我们要：
给内部数据初始化，也就是赋值state。 将函数绑定this，否则内部使用的数据会是错的，绑定以后使用的数据就是本组件中的数据。 componentWillMount &amp;amp; componentDidMount # 这是一组函数，分别在render之前和之后调用。 WillComponent这个函数其实有点多余，因为所有在这里做的事情我们都可以在构造函数中做，因此基本不会用到这个函数。 DidMount 就是在render函数过后调用，此时页面已经渲染出来。 在这个函数的执行时间上，还是比较有文章的。
举个例子，组件A有三个子组件B，B都有实现这个函数，在A的render函数中，会执行B的render函数，但是当一个B的render函数执行完后，并不立即执行这个B的DidMount函数，而是等所有的B的render函数被调用完毕后才一起调用。当然也是按顺序的。 由于此时已经渲染出来，所以我们也就可以获得DOM树上的节点。因此我们可以在这时候请求服务器去填充数据。这在我们使用其他的一些前端库的时候比较方便。例如在使用jQuery的时候，jQuery只能对已经存在的元素进行操作，所以此时正是调用jquery的时候。
render # 但凡React组件都要实现这个函数，因为这个函数在Component中没有默认的实现。
render函数并不直接操作渲染，而是返回一个JSX语法的描述。最终的渲染动作由react来做。如过没有什么要渲染就可以返回一个null或者false。
render应该是一个纯函数，只接受state和props并产生返回值，没有其他任何的副作用。
更新过程 # 要实现交互，就需要更新：
componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate 在父组件发生Update调用render函数的时候，子组件就会经历更新过程。
componentWillReceiveProps # 这个函数在使用this.setState更改数据的时候不会被调用。因为这个函数根据新props的值来计算是不是要更新内部状态state。更新内部状态使用setState，因此不会产生循环调用。 这个函数接受一个参数， 新传进来的nextProps。</description>
    </item>
    
    <item>
      <title>mobx - redux的优秀替代品</title>
      <link>https://Paladnix.github.io/posts/web/mobx/</link>
      <pubDate>Sat, 18 Nov 2017 14:29:49 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/web/mobx/</guid>
      <description>在使用react做大型开发的时候，我们习惯使用redux来做数据管控。但是redux实在是太过繁琐，流程很长，不利于快速开发。 mobx是redux作者非常推荐的一个替代产品。
基本概念 # 与redux的长流程，严管控不同，mobx采用一种更直接的方式，和更自动化的方式管理应用的数据。
状态驱动页面更新 # 应用的state也就是其中的数据，就是应用此时所在的状态，状态的改变驱动页面的改变，这是共识，问题就是怎么设计使状态的改变驱动页面更新。
在mobx中，数据将被监视，当数据发生变化的时候，mobx会自动的知道哪些部分需要被刷新，而不需要程序员来指明更新什么。
应用的状态分成两种， 一种是数据本身组成的基本状态。还有一种是在数据基础上计算得出的衍生状态。在下面我们会讨论这些。
observable # 对于需要被监视的数据，就将他用注解的方式注明，需要被监视。
import { observable, computed } from &amp;#34;mobx&amp;#34;; class OrderLine { @observable price = 0; @observable amount = 1; @computed get total() { return this.price * this.amount; } } 就这样简单的就将一个变量纳入mobx的观察体系中。 被观察的可以是几乎所有的javascript的数据结构，但是，对于对象，建议一律转成map来观察，因为对象只会观察此时有的字段，对于未来新添加的字段需要手动加入观察， 但是map就可以将添加进来的新key一并纳入观察。
observer # 有了被观察的，就要有观察者， 这里的观察者会是前端的组件。通常来说，每个组件都应该是可以观察自身数据的，响应式的应用。 一个观察者，会在数据发生变化的时候自动更新自己的视图。
import {observer} from &amp;#39;mobx-react&amp;#39;; @observer class TimerView extends React.Component { render() { return (&amp;lt;button onClick={this.onReset.bind(this)}&amp;gt; Seconds passed: {this.props.appState.timer} &amp;lt;/button&amp;gt;); } onReset () { this.</description>
    </item>
    
    <item>
      <title>react-router tutorial</title>
      <link>https://Paladnix.github.io/posts/web/react-router-dom/</link>
      <pubDate>Fri, 17 Nov 2017 23:40:11 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/web/react-router-dom/</guid>
      <description>这是一个react router的V4版本。被广泛使用， 非常流行。
Installation # react router 被包含在三个包中： react-router, react-router-dom, react-router-native. 你几乎不会直接安装react-router这个包，因为这是一个核心包，提供的是基础的react应用的路由库。 另外的两个分别提供了特殊的使用环境，前者是浏览器端， 后者是在react-native中。他们都完全包含react-router这个包中的内容。
npm install --save react-router-dom
The Router # 在多页应用中，路由的设计尤为重要。 在react应用中，其实不存在真正的多页应用，而是使用一些浏览器操作来使得单页应用具备多页应用的功能。所谓的多页应用，应该是当你输入一个固定的链接时，得到的页面应该是一致的，并且具备后退的功能。但是在react应用中，页面并不会完全重新加载，而是以特殊的方式来组织，做局部加载，实现多页面的效果。
在浏览器应用中，我们使用的是&amp;lt;BrowserRouter&amp;gt;和&amp;lt;HashRouter&amp;gt;组件。当我们的请求的网站是一个动态的页面（Know how to respond to any possible URI）的时候，我们使用前者；如果是个纯静态的页面，我们使用后者。很明显我们大多数使用前者。
History # 每个router组件都有一个history的对象，用于记录浏览的记录，用于保持跟踪。 关于这一部分，暂时还没有研究。待研究。
Rendering a &amp;lt;Router&amp;gt; # &amp;lt;BrowserRouter&amp;gt; 只允许一个子组件的存在，所以跟react一个尿性的，我们可以将我们的应用封装成&amp;lt;App \&amp;gt;的形式来使用。 For example:
import { BrowserRouter } from &amp;#39;react-router-dom&amp;#39; ReactDOM.render(( &amp;lt;BrowserRouter&amp;gt; &amp;lt;App /&amp;gt; &amp;lt;/BrowserRouter&amp;gt; ), document.getElementById(&amp;#39;root&amp;#39;)) The App # 在&amp;lt;App&amp;gt;中，我们就可以开始做布局的工作，我们可以不直接添加我们的路由体系，直接在&amp;lt;App&amp;gt;组件中添加一些组件。当我们添加我们的路由体系的时候，每个路由信息，都由一个&amp;lt;Route&amp;gt;组件来组织。
&amp;lt;Switch&amp;gt; &amp;lt;Route exact path=&amp;#39;/&amp;#39; component={Home}/&amp;gt; {/* both /roster and /roster/:number begin with /roster */} &amp;lt;Route path=&amp;#39;/roster&amp;#39; component={Roster}/&amp;gt; &amp;lt;Route path=&amp;#39;/schedule&amp;#39; component={Schedule}/&amp;gt; &amp;lt;/Switch&amp;gt; 其中， &amp;lt;Switch&amp;gt;组件用于列表匹配，从上到下依次匹配，直到匹配成功退出。</description>
    </item>
    
    <item>
      <title>ubuntu-core</title>
      <link>https://Paladnix.github.io/posts/linux/ubuntu-core/</link>
      <pubDate>Wed, 15 Nov 2017 20:34:05 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/linux/ubuntu-core/</guid>
      <description></description>
    </item>
    
    <item>
      <title>树莓派 - 入坑指南(1)</title>
      <link>https://Paladnix.github.io/posts/others/raspberrypi/</link>
      <pubDate>Wed, 15 Nov 2017 20:00:05 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/others/raspberrypi/</guid>
      <description>我手里的是pi3。
基础概念 # 树莓派作为一个微型电脑，基本具备冯诺依慢体系结构，其单机唯一不具备的就是硬盘，也就是我们插进去的tf卡。 除此以外，这用的是一个amd架构的处理器，所以在安装系统的时候我们需要选择支持amd架构的操作系统。
树莓派没有开关， 换句话说，通电就是开，断电就是关。但是在关机的时候不能直接断电，要先停止操作系统才行，也就是先关机再拔电源。
他可以做为一个性能不高的微型电脑，但是我们一般不将其作为个人电脑使用，而是用来运行一些程序使之成为实现特定功能的处理中心。 在此之前，我们要实现一个特定功能的产品或是设备，我们需要特别定制一个主控板来运行我们的程序，这些主控板具有特殊性，无法重用，并且设计成本高。 在有了这个微型电脑以后，其计算能力比一般板载处理器的性能要好，使用的是标准的冯诺依曼体系结构，使用的操作系统也以linux为主，因此可以运行几乎所有程序。 是一个低成本，可复用，灵活的硬件设备。同时其集成的网络模块、蓝牙模块，等，更适合改造成一个物联网设备的控制核心，对于实验和创新实践非常适合。
安装操作系统 # 如果你不需要界面，可以安装Ubuntu Core。如果你需要界面，可以安装Ubuntu Mate。
因为这两种都是linux系列的操作系统，我使用起来比较顺手，所以没有使用官方的那个系统。不过这都不重要。
在安装Ubuntu Core这里有详细的安装过程。 如果你是ubuntu用户的话，下载下来镜像文件，直接右击用Disk manager writer 打开就可以写入TF卡，就算是安装好了。
开机 # 安装好系统就装到板子上，然后通电。 这个时候你可能需要先接一个键盘和显示器， 因为等一下有直接操作的部分。
开机后会正常的加载操作系统，随后会出现让你连接网络的部分。 你可以用有线连接，也可以开无线，不过我的板子开无线开不开，所以只能先用有线网。
随后就会开机成功，让你用ubuntu one的帐号登录。 集体操作过程在上面的页面中有：
申请帐号 将你的电脑的ssh key上传到ubuntu one网站上 在树莓派上验证帐号。 验证成功。 此时树莓派会给你他的内网地址和帐号，你用你的电脑远程登录就可以了。
吐槽 # 就这一点， 我第一次拿到树莓派以后捣鼓了30多小时。
这个过程会出现：
内存卡写入系统树莓派加载不了，重新写。 不知道什么问题加载到一半卡住不动，重新写。 打开了错误关机，损坏数据，重写。 无线模块打不开，找网线。 。。。。 随后你获得的是通往新Ubuntu的大门。
Ubuntu Core是一个更新概念的操作系统组成方式。其系统本身跨平台，其应用打包方式跨平台，也就是snap。 既然你有意接触了新的事物，就别眷恋过往，勇敢的尝试新的东西，什么学习曲线陡峭，都不是问题。</description>
    </item>
    
    <item>
      <title>使用react开发的优秀实践</title>
      <link>https://Paladnix.github.io/posts/web/react-1/</link>
      <pubDate>Wed, 15 Nov 2017 14:10:15 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/web/react-1/</guid>
      <description>如果想用react开发功能丰富，易于代码管理，易于扩展维护的项目，我们最好使用react的一整个体系。当然你单独使用react的部分也是可以的，写一些简单的应用也非常方便，没有必要把这个体系用上。
这篇文章作为入门的一篇略深一些的介绍，在全面学习之前我们至少要知道我们学的每个部分是做什么，为什么要在这里用这个。所以本文不讲一些代码的细节，而是从整体上把握这个技术栈，帮助你快速理解整个体系。
总结 # 一个比较好的实践是使用: react + redux + router, 来实现复杂的应用。 其中， react 承担了前端渲染控制的功能，redux承担了数据流转的控制功能，router则实现了路由控制的功能。
这三项，基本上可以保证我们做出的项目，结构清晰，易于维护。 在初学这写东西的时候，可能会觉得比较痛苦，因为你需要记住太多的东西和条条框框来开发，这好像限制了你的自由发挥，但是对于一个大型应用来说，或者即便是小应用，没有清晰的结构，就连你自己可能都看不懂自己的代码，后期维护的时候就基本上没有多少好体验了。
真正优秀的作品，都是在严格的限制下完成的，因为人的思维不应该去思考那些复杂的页面组成的逻辑关系，而是在实现自己的业务逻辑和计算算法上，那些结构，按照一个科学的方式来做就好。而react正是提供了这样一个科学的流程和方式。
react # 总的来说，在前端渲染方面，react非常出众， 一般我们将前端渲染的部分交给react来做。 react使用虚拟DOM的方式，来管理渲染。并且将一个页面分成多个组件进行管理，我们一般将组件按功能分开。当页面发生变化的时候，由react来决定哪里需要渲染，哪里不动，react来操纵浏览器的渲染。 与jQuery相比，更进一步， jQuery是将浏览器的一些操作封装出来，提供一组新的调用函数。但是react已经将浏览器的相关接口完全封装，并且屏蔽在react内部，提供了一种更自然和智能的方式来满足我们的需求。我们直接和react打交道，剩余的事情由react去和浏览器做。
react这个框架可以运行在浏览器端，也可以运行在服务器端， 我们称之为Universal渲染，这里的服务器端，就是Nodejs的平台了。我用的基本上都是浏览器端运行。只要将react的脚本发送到浏览器进行执行就可以了。 初的渲染是后端的事情，有了ajax后前端也可以进行渲染了。但是前端渲染会有个问题，就是搜索引擎不友好，因为搜索引擎并不会去跟js代码交互，只会爬取静态页面，所以使用后端渲染十分重要。这关乎你的网站被检索到的可能性。
基本构造 # react的逻辑很简单，一切都是组件。一个页面是由多个组件堆砌而成，每个组件之间互相隔离，仅通过数据交互，而数据交互的接口是固定的。所以对于一个组件内部来说，与外界是完全隔离的。 一个组件包括，样式和数据。数据我们通过请求服务器去获得。 每个组件通过提供一个render函数来返回这个组件，这个render函数只能返回一个元素。如果有多个元素需要被包起来成为一个元素返回。 组件之间可以是嵌套关系，这个和类的概念有点像，在一个类中可以包含另一个类作为自己的成员。也就是方便我们做组件封装，功能划分。
当我们写完一个react应用后，可以通过npm start的方式启动起来，当我们在浏览器访问对应的地址时，默认访问index.js, 所以我们的应用最终在这里组织起来。
ES6 &amp;amp; Javascript &amp;amp; JSX # 在写应用的时候，我们使用JSX 语法来写，JSX以ES6为基础，react提供了JSX解释器。在写完以后，JSX语法的代码会被编译成JS代码，最终在浏览器中运行的是Javascript的代码，关于webpack等工具，我暂时没有去学习，因为react提供了一个创建react应用的脚本，能够一键创建好这些配置文件，所以我就暂时直接使用了。
npm install --global create-react-app
这个命令就可以安装这个脚本，然后我们执行： create-react-app myapp, 就可以创建一个文件夹， 里面已经配置了一个简单的react应用。 然后我们进入这个文件夹，使用npm start就可以启动服务。 start的过程中，代码就会被编译，并打包成webpack中配置的打包形式。
如果此时我们改变代码，这个页面会动态更新。
react 原生的数据控制 # 在react中，数据主要有三个载体，分别是state、prop、context。其中state是组件内部状态数据，prop用于层层传递，context可以跨层传递。
react要实现各个组件独立，并且具有统一的结构，最重要的就是控制数据。在JS这种弱类型的语言中，这一点很好实现，重点就是设计一个接口形式。 react中的组件，都有两个变量，一个是prop， 一个是state。 其中，state是描述组件内部数据的，prop是对外的接口。也就是说，别人传过来的数据，会存在prop中。同时，prop是不可变的，组件自己不能更改prop的值， 只能改变state的值。
这种数据控制的方式，比较原始，从接口统一的角度来看挺好的，也符合基本的思维方式。 但是这种控制方式也存在很多问题，不用去深究这个框架的细节，我们也可以提出很多问题：
每个组件之间的数据冗余问题，很多数据统计的模块，该怎么存储数据？ 复制一份出来？当要更改数据的时候，是不是还要传参给另一个组件通知他改变数据？</description>
    </item>
    
    <item>
      <title>阶段性总结</title>
      <link>https://Paladnix.github.io/posts/self/self-1/</link>
      <pubDate>Fri, 27 Oct 2017 00:07:31 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/self/self-1/</guid>
      <description>从九月以来，我做的事情和状态在这里总结一下。
值得xx的事 # 九月份我忘记了我在做一个什么事情，好像是一个项目。
我从阿里回来苏州以后，先是5号要考科目三，于是就练车到了5号。 在5号过后，我在准备保研的事情，打印材料，复习一下C语言。这期间看了一多半的《C和指针》。然后貌似我还看了一个什么的文档，记不起来了，我操这记忆力。
保研是在什么时候，貌似是在18号。然后就是等待结果。 我当时确实在忙一个什么东西。 然而找了半天并没有找到什么记录，我草，可能是被续掉了吧。害怕害怕。。。
然后去了一趟北京，回来了。然后打打网络赛，然后收拾心情回家过了个国庆。 从国庆回来，然后开始尝试Node， react，做兼职。一直到去沈阳比赛。在沈阳打了个金牌回来，心情还不错。 去沈阳比赛回来就接了NOIP讲课的锅，到了现在。
总之，这两个月过的异常的快，而且也异常的忙。突然从实习生回到学校里，没有了主业，也没有了方向。然后又突然从中科院的研究生回到了苏大的研究生，整个心境也就不一样了。
这是一段心态转变的时间。之前总是有一点毕业生的感觉，所以做事的效率非常的额低，一点都没有实习工作时候的那种紧迫。过了几天好日子。休息够了，也给了自己一个大坑。整个人都清醒了起来。
接下来要做的事情 # 这个接下来应该有长期有短期。
短期来看 # 最近15天，我需要做的是NOIP和React并行，暂且将一些系统瞎搞的事情放一下。 然后OJ也要能运行，让对接的老师来尝试。
再稍微长一点，可以借助这次NOIP的机会调整一下自己竞赛的思路，重新规划一下自己的知识点。重点转移到看白书上来，要形成一点章法。
中期来看 # 最近三个月我的主要精力还是两个方面，一个是竞赛，一个是react和python的兼职。 两个的量都不小，我的键盘灵敏度也被我调的非常高，这样可以在一定程度上督促自己加快速度，保持兴奋。
对于react和py，都需要系统一点的来搞。就以这个项目为基础吧。
除了主流的技术，还有一些顺带的技术流： Git，Github，Node。
长期一点 # 在上面两个能够处理好的情况下，继续处理一点系统的工作工具。
这个真的很麻烦。
待续&amp;hellip; # </description>
    </item>
    
    <item>
      <title>ES 6</title>
      <link>https://Paladnix.github.io/posts/web/es6/</link>
      <pubDate>Sun, 08 Oct 2017 23:33:40 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/web/es6/</guid>
      <description>历史 # ECMA是个组织，国际标准化组织。 Javascript诞生于1996年，比我略小9个月。由Netscape公司研发，也就是曾经的网景公司。 次年开源交付给ECMA组织进行标准化，力图打造一个国际通用的语言。随后，ECMA发布了国际浏览器脚本语言标准，名称为ECMAScript，实际上就是Javascript的国际标准版。 由于商标等多种原因，名称为ECMAscript，而不是javascript，但我们基本上认为是一个东西。
前者是标准，后者是标准下的实现。
标准是个啥 # 所谓的语言标准，每个语言都有。 在语言不断发展的过程中，会给语言添加一些语法特性，比如以前js是不支持class的，在ES6的标准中就支持啦。
这些标准每年都会变化，不断的有人提案新的语法特性，经由审核实现后发布。
ES6的发布有什么好处？ # 让js真正成为一个可以开发大型应用的语言。 不面向对象的程序设计，在开发逻辑复杂的大型企业级应用的时候非常鸡肋，超高的开发周期和人力投入，复杂的耦合关系，而且极难进行维护。 ES6引入了很多的面向对象的语法，以及函数编程的内容，使得js可以hold住大型开发的复杂度。
但是ES6的class在ES5的时候就是可以实现的，只是语法上很别扭，跟传统的面向对象的语法差异很大，让人学起来很懵逼。
语法细节 # 在细节的内容，推荐一个开源的书，所谓开源的书，就是有电子版的网站可以看，印刷版的要买。
详细参考</description>
    </item>
    
    <item>
      <title>Codeforces 855-C 树形DP</title>
      <link>https://Paladnix.github.io/posts/acm/cf855-c/</link>
      <pubDate>Tue, 26 Sep 2017 01:07:28 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/acm/cf855-c/</guid>
      <description>题意 # 给一颗树， 每个结点可以标记一个type。 一共有m种type，分别是1-m。 其中有一种特殊的type，编号为k，要求：
在这棵树中，最多出现x个type为k的点。 每个type为k的点，其相邻的点type必须小于k。 问，给定以上数据，求树的标记种类数有多少。
数据范围： n &amp;lt;= 1e5, x &amp;lt;=10, m &amp;lt;=1e9
分析 # 这是一个典型的树形DP，DP的维度应该至少是3维。
Dp[i][j][z] 表示： 以i为根的子树，用掉z个k时的种类数。 其中对于根结点的type选取，分三种情况，
0：type &amp;lt; k (type &amp;gt;=1 ) 1：type = k 2：type &amp;gt; k (type &amp;lt;= m) Dp表示内容确定以后，就要来找转移方程了。 这种组合种类的问题，只要分清楚哪些量之间是相乘的关系，哪些量是相加的关系就好办了。
思考一种普遍的情况，对于一个根节点和其儿子节点之间的关系，以及儿子之间的关系。 可以确定的是，各个儿子之间的关系是相乘的关系。因为儿子之间是没有约束的，不直接相连就没有type &amp;lt; k的约束。所以每个子树内的排列种类是直接乘到贡献中的。
然后就是儿子与父亲节点的关系。 讨论一下，如果父亲的取值是0类型，也就是type &amp;lt; k。 对于任何一个儿子都可以任意选择type，并且这些选择之间是相加的关系。选择之和与父亲的选择种类之间是相乘关系。
总上，父亲与儿子、儿子与儿子之间都是相乘的关系，儿子内部是相加关系。
这个时候我们可以选择将父亲先放在一边，先合并各个儿子。最后把合并后的儿子与父亲合并。
为什么不能直接把儿子合并到父亲上呢？
因为对于一个固定的z来说，其对应的情况是z个k在所有子树中的全排列种情况。这些排列又是相加的关系，很显然我们不能去求这个排列，复杂度太大。
我们要在处理每个儿子的时候，将其对不同的z的贡献都存起来，这个我们可以做到。
以下的代码以根为0时举例，其他两个情况一样。
for(int j=0; j&amp;lt;=x ;j++){ for(int z = 0; z &amp;lt;= x; z++){ if(l+z &amp;gt; x) continue; Dp[u][0][j+z] += ta[0][j] * (Dp[v][0][z] + Dp[v][1][z] + Dp[v][2][z]); } } ta[0][j] 记录的是在当前儿子之前的所有儿子中，使用了j个k时，所有的种类数。 其中，Dp[u][0][j+z] 记录的是对于当前儿子结点v，使用了j+z 个k时，所有的种类数。</description>
    </item>
    
    <item>
      <title>Effective C&#43;&#43; 读书笔记</title>
      <link>https://Paladnix.github.io/posts/c&#43;&#43;/effectivec-1/</link>
      <pubDate>Sat, 23 Sep 2017 21:31:44 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/c&#43;&#43;/effectivec-1/</guid>
      <description>从北京回来，决定花三天时间把这本书看掉。有两个原因，第一个是我希望主要精通的语言还是选择C++，因为其功能强大，且速度快；优秀的程序员就应该精通C++才可以。其次是在即将要学习的机器学习和深度学习的领域中，C++是后期算法工程化的重要一环。
如果是看完这本书，我觉得三天就够了。如果是精研每个细节就要花个一周了，我决定先快速的get到重点的内容，在接下来写代码的过程中再实践出来。
本书架构 # 这本书被冠以盛名，源自于其内容的独特性、优质性。 书中不是详细介绍C++的各种特性，而是从大量的工程经验中思考c++编写代码的优秀习惯。
本书全局来看，由55条准则构成。这55条准则被由浅入深的分成了8个模块，还有一个杂项模块作为第9个模块。 下面我就这些准则和书中的内容做个整理。
1. 让自己习惯C++ # View C++ as a federation of languages # C++ 今天已经是一个多重范型编程语言，同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式的语言。 因此这是一个语言的联邦，几乎各种语言的编程模式都可以在C++中得到体现。 最主要的是，做到这些并且保持着速度。
Prefer const, enum, inline to #define # 主要就是讲了#define的种种缺点。 从我自身的使用上来说，简短的单文件程序中，使用define还是可以的，但是看别人的代码中就非常的困难了。因此我自己也是不倾向于使用define来定义一些东西。
常量： 对于常量我们可以使用const来定义，而不是使用define。这样不仅安全，而且编译后的代码更少。 define的一个比较严重的问题就是作用域的问题，其并不重视作用域，在编译的时候，对此后的内容均有效，除非遇到undefine。但是一个常量是可以有作用域的限制的。 除了使用const还可以用enum来定义一个常量，
class Game{ private: enum{ NumTurns=5 }; } 这样就定义了一个5的代名词，但是并不会被取到地址，也不会被改变。如果使用者企图调用这个的地址会在编译时就被报错，而不是像const那样在运行时报错出来。
函数 很多人会define一个小函数，来达到函数的作用又减小了函数调用的开销。但是这样写，一个是不直观，容易错；还有就是括号要很多，也容易出错。用inline是一样的效果。
Use const whenever possible # 关于const的语法的细节，可以参考之前的相关的内容。 使用const可以避免很多错误，与上面一样，这些错误很可能会发生在运行时。但是如果你适当的用了const，就会在编译的时候被避免。
CLASS a, b ,c; if( a*b = c) 内置类型会编译报错没有问题，但是对于自定义的类型，就会出现意想不到的错误。
确保使用的变量都被初始化了 # 这里有一个很有趣的东西，叫做冒号表达式，没错，就是那个冒号表达式。与一般的赋值初始化不同的是，冒号表达式更快速。
class A{ Som a, b; A(Som _a, Som _b){ a = _a; b = _b; } A(Som _a, Som _b):a(_a), b(_b){} } 对于第一种写法，需要先调用每个类的默认构造函数，随后进行复值。但是默认构造函数就浪费了。 对于第二种，直接调用其copy构造函数，所以更快。</description>
    </item>
    
    <item>
      <title>一个决定</title>
      <link>https://Paladnix.github.io/posts/self/myheart/</link>
      <pubDate>Wed, 20 Sep 2017 21:39:35 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/self/myheart/</guid>
      <description>终于我还是follow my heart.
今天下午，我找了我的准未来导师&amp;ndash;刘偲老师，简单的聊了一下。然后，我决定不留在这里&amp;ndash;中国科学院信息工程研究所。
推免的面试，各个学校基本接近尾声，没有什么机会去别的学校再试试，我选择留在苏州大学NLP组。
当张民老师问我为什么的时候，让我说出两个不留在研究所的理由。我脑子里只有一个，我不喜欢这里。
这是一个很重要的决定，对任何人来说。并且对很多人来说，我的这个决定都是脑子进水了。
计算机是我的爱好 # 上半年选择学校的时候，我就没想去投学校，直接投了研究所。 我希望自己的研究生生活能够花的有意义，去学习更多的更深的东西，虽然我也知道全是靠自己，但是可能研究所的人更靠谱吧。我希望研究所的高要求能让我更有压力不去浪费时间。
做自己喜欢的事，是人生最幸运的事，我很幸运。 其实无论在哪里，自律都是第一要素，我不该去利用其他人的要求去压制自己的懒惰，我应该从自己的性格中剔除懒惰，才能持续发展。
我生命中有一个很重要的人，一个让我钦佩的，活生生的人&amp;ndash;张冉，我的初中同学都了解那是怎样的人。平台从来不是限制他的因素，够优秀，并且足够自信自己会优秀。我没有他那么厉害，但我觉得在自己喜欢的事业上，我可以做到。
我需要一个环境 # 来到研究所两天，我很不适应。环境真的不容乐观，北京又在严打，各类餐馆被关停，吃的很差，住的地方也出了点问题，交通也很不方便，工位的空调也很不好，泰坦显卡的发热量又很大，我几乎隔20分钟就要洗一次脸才能静下来，耳机已经完全不管用了。 很多人会觉得怎么这么矫情，如果在以前，这绝不会让我选择离开。 我很不喜欢这个环境，不适合我静下来做事情。 对于编程和算法这类工作来说，环境是最重要的基础。在理工楼101，我可以从早上11点坐到凌晨3点去写代码。也不会有人来打扰我。（要跟女朋友道歉，来找我还会被我凶）
在来这里之前，我觉得中科院的环境应该非常好吧，毕竟是国家重点实验室。 但是很不幸，我还是太天真了。学生的生存条件并没有那么得到重视，我以为这里应该以人为本，本来就没有多少人，就更该把环境搞好才行吧。我的师兄们只好每人一个风扇，甚至两个，一个给机器一个给自己。 从他们跟我聊天的语气中，我听到很无奈，习惯就好。我也很佩服他们，环境这么差，还要做很多工作。
在这样的环境，我很难保证自己的情绪不会影响自己做事情，所以我要慎重的考虑这个因素。
我很担心未来三年的处境 # 在一开始，导师跟我提出几点要求：
要花时间。 要服从安排。 在信工所的两天里，我看到的这些人，都很苦恼，一点都不快乐。 选择来这样的地方不该是非常喜欢这份事业的吗？这样的样子很奇怪。 花时间，对我来说，时间除了睡觉，就是在电脑前面了。不成问题。 但是服从安排，我就很没底了。毕竟听到很多人都说自己的导师如何压榨自己。 同时我又从师兄那里听到些不太好的东西。
对于我来说，我比较耿直，这些事情，对我来说很重要。 如果因为某些事情让我做东西很不开心，我绝对做不好，并且还浪费大量的时间。 听说有一个很厉害的师兄因为跟老师在一些任务上搞的不愉快被外派到其他学校交流去了。
我想，如果有这样的事情，我应该也会闹的不愉快吧。 我怀着对技术的赤诚，不想成为廉价的劳动力。
血里有风 # 我要的是自由的精神。
来过北京几次，我从未喜欢过这里。用今天认识的人的话说，对他来说，这里没有任何生活的气息。 这里是政治中心，在中国，我永远不想沾边的东西。 这里是经济中心，在这里，少有真诚。 &amp;hellip;
人生很短暂，三年很漫长。 做技术的人，应该都是我这样子。不耻那些偷奸耍滑，不屑那些争名夺利，用自己的能力换取自己应得的那份。 世界虽然很复杂，很坏。 但是我终将面对的，是我自己。并且实时面对的，也都是我自己。 活着，不为谁，为了自己开心。仅此而已。
在苏大会不甘心吗？ # 并不会。 其实我选择的是张民老师和苏州。
跟张民老师有很多接触，这个被苏大挖过来的NLP国内前沿学者，带着苏大的NLP排进了前5名。为人非常直接，可能是因为工作太多的缘故，惜时如金，绝不废话。 在我找他的时候，再三跟我说，你要考虑清楚，中科院的研究生跟苏大的研究生含金量不一样的，苏大保一个中科院非常难的，你有这个机会千万别傻。
刘偲老师也是CV圈比较厉害的，张民老师也是NLP圈很顶尖的。在这一维度，其实并没有什么区别，学校虽然差异很大，但是我毕业以后只能靠自己的能力。
所以关键是我自己，我愿意用三年的时间，在苏州学习，而不是北京。
人生是自己的，我应该为自己负责。</description>
    </item>
    
    <item>
      <title>awk - Linux文本处理大杀器</title>
      <link>https://Paladnix.github.io/posts/bash/awk/</link>
      <pubDate>Thu, 07 Sep 2017 17:44:07 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/bash/awk/</guid>
      <description>awk 已经不是一种命令了，而是一种语言。用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。
在最开始，我的文本处理方式就是写一个c语言去读文件然后在处理完输出来。刚开始学程序的时候觉得自己很厉害的样子。这样做过几次以后就发现并没有这么好用，因为每次都要写一个很麻烦。
在后来就是学习用脚本来处理。
关于Linux命令，推荐一个小站点，写的东西都还非常细致。
命令形式 # awk [options] &amp;#39;script&amp;#39; var=value file(s) awk [options] -f scriptfile var=value file(s) 命令选项
-F fs fs指定输入分隔符，fs可以是字符串或正则表达式，如-F: -v var=value 赋值一个用户定义变量，将外部变量传递给awk脚本 -f scripfile 从脚本文件中读取awk命令 脚本模式和操作 # awk的脚本主要由模式和操作组成：
模式 # /正则表达式/：使用通配符的扩展集。 关系表达式：使用运算符进行操作，可以是字符串或数字的比较测试。 模式匹配表达式：用运算符~（匹配）和~!（不匹配）。 BEGIN语句块、pattern语句块、END语句块 操作 # 操作由一个或多个命令、函数、表达式组成，之间由换行符或分号隔开，并位于大括号内，主要部分是：
变量或数组赋值 输出命令 内置函数 控制流语句 awk脚本的基本结构 # awk &amp;#39;BEGIN{ print &amp;#34;start&amp;#34; } pattern{ commands } END{ print &amp;#34;end&amp;#34; }&amp;#39; file 一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被单引号或双引号中，例如：
awk &amp;#39;BEGIN{ i=0 } { i++ } END{ print i }&amp;#39; filename awk &amp;#34;BEGIN{ i=0 } { i++ } END{ print i }&amp;#34; filename 工作原理 # 第一步：执行BEGIN{ commands }语句块中的语句； 第二步：从文件或标准输入(stdin)读取一行，然后执行pattern{ commands }语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕 第三步：当读至输入流末尾时，执行END{ commands }语句块。 BEGIN语句块 在awk开始从输入流中读取行之前被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中。 END语句块 在awk从输入流中读取完所有的行之后即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它也是一个可选语句块。 pattern语句块 中的通用命令是最重要的部分，它也是可选的。如果没有提供pattern语句块，则默认执行{ print }，即打印每一个读取到的行，awk读取的每一行都会执行该语句块。</description>
    </item>
    
    <item>
      <title>node nodejs npm 傻傻分不清楚on Ubuntu</title>
      <link>https://Paladnix.github.io/posts/web/node/</link>
      <pubDate>Tue, 29 Aug 2017 11:03:13 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/web/node/</guid>
      <description>在学习angular的过程中，要安装Node，但是我在ubuntu上用一些方法安装的版本都太低了，而且还有node、nodejs这两个东西交替出现，让我很是怀疑人生。
决定扒一扒这鬼玩意儿的前世今生。倒要看看你葫芦里装的是什么逼！
ubuntu 下的Node与Nodejs # 首先这两个我认为是一个东西的两个发展阶段，在最开始的时候，名字叫做nodejs，后来升级改版以后就变成了node。
在某个版本之前，我们安装的都是nodejs。命令行中使用的也都是nodejs。后来可能作者们要开始装逼了，于是决定把丑爆了的js去掉，因为js在一些工程师的眼中很垃圾，所以不能让别人认为node也很垃圾。事实上js确实有很多缺陷，但是并不影响它一统前端，甚至进一步掠夺市场进驻后端，甚至现在在无联网领域成为香饽饽。
js在进步，同时node也在进步，喜欢用js这样用起来比较便捷的工程师也越来越多，所以，未来的流行语言里，js应该也有重要的一席之地，所以我要学会它。
js的细节不在这篇文章的讨论范围之内，我还是比较关心这个node到底是个什么神通广大的东西，让这么多程序员都不淡定了。
Node是个啥 # 官方解释：nodejs是一个平台, 它构建在chrome的v8引擎之上,能简易的构建快速,可扩展的网络应用程序&amp;hellip;
害怕，口气还真是很大。关键是人家说的是网络应用程序哎！不是前端，也不是server，而是网络应用程序。 其本质就是一个网络应用程序喽，所以必然有两个的东西非常重要，一个是网络，一个是应用程序。
下面分几个小点
V8引擎，名字很帅哈。这个引擎其实就是javascript的解释器，将代码解释成本机可以运行的机器代码。
openssl是个开源的，安全套接层协议。其将数据加密和通信加密算法直接实现在协议中，使得数据离开你的机器时就是加密的，直到目的地才进行解密。是安全通信领域应用最广的一个开源项目。这部分详细的内容会在接下来的文章中详述。Node本身是集成了这个openssl项目的。
事件驱动的非阻塞io模型。 这个是其作为应用程序的一个特征。所谓事件驱动，就是一个异步的处理机制。整个程序通过订阅相应的时间消息，来出发相应的动作。 实现这个功能的主要技术就是libuv， 其前身是linux中的libev。Node重写了这个库并在windows上做了相应的实现，所以node是个可跨平台的运行的程序。
以上就是Node的几个重要的特点，了解了这些特征就能进一步了解其原理。下面在选择一些东西来记录一下。
libuv # nodejs 其实就是 libuv 的一个应用而已。
你自己写程序也可以集成libuv进来, 这样你的c++程序就有了消息循环了. 不再是简单main函数了. 你可以订阅系统的事件, 然后当事件发生时, 系统会调用你的回调函数, 就跟windows上的button click事件一样方便. 而且是跨平台的哦. 是不是很酷. 你几乎可以订阅所有的系统事件, 比如socket事件, 文件读写事件等等.
nodejs简单的说只是把javascript解释成c++的回调, 并挂在libuv消息循环上, 等待处理. 这样就实现了非阻塞的异步处理机制(non-blocking I/O model).
那么为什么是javascript而不是其他的语言. 很简单, 因为javascript的闭包. 这非常适合做回调函数. 因为我们一般都希望当回调发生时, 它能记住它原来所在的上下文. 这就是闭包最好的应用场景.
小结 # Node其实就是一个平台，在这个平台上运行的是javascript语言。你可以使用它来实现很多东西，不仅仅是server端的服务程序，也可以写一个窗口的软件程序等等。 Node与python、JVM其实都是一类东西。
ubuntu 安装最新的Node和npm # npm是Node的包管理器。就像是我们的apt对于debian的概念一样。
ubuntu维护的源大多是LTS版本的，但是node的发展速度很快有很多新特性在新的版本中。所以很多时候稳定版本并不能满足我们的需求。下面就介绍一下最新版本的怎么安装。
安装npm # 先用ubuntu库中的资源安装一个低版本
sudo apt install npm 此时我们npm -v发现版本是3.</description>
    </item>
    
    <item>
      <title>CORS Cross-Origin Resource Sharing</title>
      <link>https://Paladnix.github.io/posts/web/cors/</link>
      <pubDate>Mon, 21 Aug 2017 17:52:41 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/web/cors/</guid>
      <description>有一种痛，叫做就是想让你多学习一点东西。
这个知识点，来源于一口还没找到源头的大黑锅。而我不能背这个锅，并且要找到一个人来背锅。
Introduction # 在之前的sso文章中，有提到过一个问题，就是cookie的不能跨域的问题。 出于安全考虑，浏览器会限制从脚本内发起的跨域HTTP请求。例如，XMLHttpRequest 和 Fetch 遵循同源策略。因此，使用 XMLHttpRequest或 Fetch 的Web应用程序只能将HTTP请求发送到其自己的域。为了改进Web应用程序，开发人员要求浏览器厂商允许跨域请求。
针对跨域的解决方案有很多，比如：flush、JSONP、ifame、xhr2等，但是都有很多弊端，我觉得CORS比较有前途。
这个解决方案已经被几乎所有的主流的浏览器支持了。浏览器内置了这种解决方案，所以对于前端的工程师来说就是透明的，当前端使用ajax发起一个跨域请求的时候，浏览器自动使用这个方案来处理。但是这个方案需要浏览器和服务器共同支持才可以。
今天主要的使用是依靠XMLHttpRequest来实现。这是一个js的对象，负责与服务端进行动态数据交互。
发起一个XMLHttpRequest请求 # 原生的请求形式。
&amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; //XmlHttpRequest对象 function createXmlHttpRequest(){ if(window.ActiveXObject){ //如果是IE浏览器 return new ActiveXObject(&amp;#34;Microsoft.XMLHTTP&amp;#34;); }else if(window.XMLHttpRequest){ //非IE浏览器 return new XMLHttpRequest(); } } // 调用getFile方法 function getFile() { var img_Container = document.getElementById(&amp;#34;img_Div&amp;#34;); var xhr = createXmlHttpRequest(); xhr.open(&amp;#39;GET&amp;#39;, &amp;#39;http://oss.youkouyang.com/1.jpg&amp;#39;, true); xhr.setRequestHeader(&amp;#39;Content-Type&amp;#39;, &amp;#39;image/jpeg&amp;#39;); xhr.responseType = &amp;#34;blob&amp;#34;; xhr.onload = function() { if (this.status == 200) { var blob = this.response; var img = document.</description>
    </item>
    
    <item>
      <title>apache curator</title>
      <link>https://Paladnix.github.io/posts/others/curator/</link>
      <pubDate>Fri, 18 Aug 2017 17:45:34 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/others/curator/</guid>
      <description>&amp;ldquo;Guava is to java what Curator is to Zookeeper&amp;rdquo;.
Start # Curator之前介绍过一些，是一个使用流式API方式实现的Zookeeper的Java客户端。
Get a connection # connection的实例(CuratorFramework)是用工厂模式分配的(CuratorFrameworkFactory)，对于一个zk集群，你只需要一个连接的实例。 同时你可能会用到的是RetryPolicy 去设置失败重试的参数，一般你会这样使用：
RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3) CuratorFramework client = CuratorFrameworkFactory.newClient(zookeeperConnectionString, retryPolicy); client.start(); 客户端需要显式的start并且在不用的时候显式的close.
在链接成功以后就可以直接操作对应的集群。并且，如果在执行操作的过程中出现了连接错误，curator的manage会自动重新尝试操作。
分布式锁 # 不可以对某个路径下的节点进行上锁：
InterProcessMutex lock = new InterProcessMutex(client, lockPath); if ( lock.acquire(maxWait, waitUnit) ) { try { // do some work inside of the critical section here } finally { lock.release(); } } </description>
    </item>
    
    <item>
      <title>synchronized 同步锁</title>
      <link>https://Paladnix.github.io/posts/others/synchronized/</link>
      <pubDate>Fri, 18 Aug 2017 15:45:11 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/others/synchronized/</guid>
      <description>synchronized # 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； 修饰一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； 修饰一个类，其作用的范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象。 代码块加锁 # 一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞。我们看下面一个例子：
/** * 同步线程 */ class SyncThread implements Runnable { private static int count; public SyncThread() { count = 0; } public void run() { synchronized(this) { for (int i = 0; i &amp;lt; 5; i++) { try { System.out.println(Thread.currentThread().getName() + &amp;#34;:&amp;#34; + (count++)); Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } } } public int getCount() { return count; } } 调用的方式如下：</description>
    </item>
    
    <item>
      <title>java wait一种线程通信方式</title>
      <link>https://Paladnix.github.io/posts/java/javawait/</link>
      <pubDate>Fri, 18 Aug 2017 14:44:10 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/javawait/</guid>
      <description>在一个异步改同步的工程中，有两种方式，一个是轮询，一个是中断。这里介绍一下中断的操作。
在看这一部分之前你可能先要看下一篇文章，关于synchronized同步锁的问题。下面会用到。
如果你的Java程序中有两个线程——即生产者和消费者，那么生产者可以通知消费者，让消费者开始消耗数据，因为队列缓冲区中有内容待消费（不为空）。相应的，消费者可以通知生产者可以开始生成更多的数据，因为当它消耗掉某些数据后缓冲区不再为满。
wait # Object类中相关的方法有两个notify方法和三个wait方法： 因为wait和notify方法定义在Object类中，因此会被所有的类所继承。 这些方法都是final的，即它们都是不能被重写的，不能通过子类覆写去改变它们的行为。
wait()方法使得当前线程必须要等待，等到另外一个线程调用notify()或者notifyAll()方法。 线程调用wait()方法，释放它对锁的拥有权，然后等待另外的线程来通知它（通知的方式是notify()或者notifyAll()方法），这样它才能重新获得锁的拥有权和恢复执行。
要确保调用wait()方法的时候拥有锁，即，wait()方法的调用必须放在synchronized方法或synchronized块中。
与sleep不同的是sleep不会释放锁。
notify # notify()方法会唤醒一个等待当前对象的锁的线程。如果多个线程在等待，它们中的一个将会选择被唤醒。这种选择是随意的，和具体实现有关。(线程等待一个对象的锁是由于调用了wait方法中的一个)。
被唤醒的县城也并不是直接就能执行，而是要进入到正常的线程竞争过程中。
同样的你notify方法也要放在synchronized方法或者synchronized块中执行。
正确的使用 # 除了要在同步的基础上使用以外，在书《Java并发实践》中，作者提出一定要在循环中使用wait。正确的代码应该是下面的样子：
// The standard idiom for calling the wait method in Java synchronized (sharedObject) { while (condition) { sharedObject.wait(); // (Releases lock, and reacquires on wakeup) } // do action based upon condition e.g. take or put into queue } 在while循环里使用wait的目的，是在线程被唤醒的前后都持续检查条件是否被满足。如果条件并未改变，wait被调用之前notify的唤醒通知就来了，那么这个线程并不能保证被唤醒，有可能会导致死锁问题。
这两个函数都是对于某个对象来说的，这个对象一定是一个多线程共享的对象。是同步，是利用锁的机制进行同步的。
在生产者消费者的概念中，就是对产品的队列进行共享，所以wait()和notify()都是queue的动作，同时锁也是对于queue来说的。</description>
    </item>
    
    <item>
      <title>C 函数指针</title>
      <link>https://Paladnix.github.io/posts/c&#43;&#43;/funcp/</link>
      <pubDate>Thu, 17 Aug 2017 20:36:22 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/c&#43;&#43;/funcp/</guid>
      <description>C语言有了函数指针以后，就算是完整了，构建了这个世界。
先来看三个例子：
A) char * (*fun1)(char * p1,char * p2); B) char * *fun2(char * p1,char * p2); C) char * fun3(char * p1,char * p2); 最后一个很好理解，fun3是函数名，函数返回一个char*。 中间个是返回一个二级指针，本质与最后一个没有什么区别。
在第一个中，其实就是函数指针了，fun1是个函数指针，这个函数返回一个char*。
函数指针其归根结底是一个指针，所以他是可以赋值的。如下的一个函数指针：
int (*p)(int a, int b) = NULL;//初始化为 NULL 如果我们要给 p 赋值的话，我们就应该定义一个返回值类型为 int ，两个参数为 int 的函数：
int add(int a, int b) { return a + b; } p = add;//给函数指针赋值 经过上面的赋值，我们就可以使用 p 来代表函数：
p(5, 6);//等价于 add(5, 6); printf(&amp;#34;%d\n&amp;#34;, p(5, b)); 当然这并不是主要的用法，最主要的用法是用作回调函数。</description>
    </item>
    
    <item>
      <title>cpp lamda &amp; for_each</title>
      <link>https://Paladnix.github.io/posts/c&#43;&#43;/cpp-1/</link>
      <pubDate>Thu, 17 Aug 2017 17:49:11 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/c&#43;&#43;/cpp-1/</guid>
      <description>既然学习了java的lamda表达式，当然要来顺便学习一下C++的实现。
lamda # C++11 有了对lamda表达式的支持。基本的形式有下面几种：
|&amp;mdash;&amp;ndash;| | [capture] ( params ) mutable exception attribute -&amp;gt; ret { body } | | [capture] ( params ) -&amp;gt; ret { body }	| | [capture] ( params ) { body }	| | [capture] { body }	|
[capture]: 需要用到的外部变量 [a,&amp;amp;b] a变量以值的方式呗捕获，b以引用的方式被捕获。 [this] 以值的方式捕获 this 指针。 [&amp;amp;] 以引用的方式捕获所有的外部自动变量。 [=] 以值的方式捕获所有的外部自动变量。 [] 不捕获外部的任何变量。 [&amp;amp;, x] x显式地按值捕获. 其它变量按引用捕获 [=, &amp;amp;z] z按引用捕获. 其它变量按值捕获 (params): 函数的参数, 无参数括号可以省略。 mutable: 修饰符说明 lambda 表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获对象的 non-const 方法。 exception: 说明 lambda 表达式是否抛出异常(noexcept)，以及抛出何种异常，类似于void f() throw(X, Y) attribute: 用来声明属性 几个例子：</description>
    </item>
    
    <item>
      <title>Java lamda 表达式</title>
      <link>https://Paladnix.github.io/posts/java/lamda/</link>
      <pubDate>Thu, 17 Aug 2017 16:27:43 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/lamda/</guid>
      <description>本文大部分来自该博客，有些是自己的写代码的经验，觉得作者写的很清晰，非常棒。
1. 什么是λ表达式 # λ表达式本质上是一个匿名方法。让我们来看下面这个例子：
public int add(int x, int y) { return x + y; } 转成λ表达式后是这个样子：
(int x, int y) -&amp;gt; x + y; 参数类型也可以省略，Java编译器会根据上下文推断出来：
(x, y) -&amp;gt; x + y; //返回两数之和 或者
(x, y) -&amp;gt; { return x + y; } //显式指明返回值 可见λ表达式有三部分组成：参数列表，箭头（-&amp;gt;），以及一个表达式或语句块。
下面这个例子里的λ表达式没有参数，也没有返回值（相当于一个方法接受0个参数，返回void，其实就是Runnable里run方法的一个实现）：
() -&amp;gt; { System.out.println(&amp;#34;Hello Lambda!&amp;#34;); } 如果只有一个参数且可以被Java推断出类型，那么参数列表的括号也可以省略：
c -&amp;gt; { return c.size(); } 函数接口 # lamda表达式是什么？它不是一个object，而是一个函数接口。 在java8中引入的新特性，函数接口。定义如下：一个接口，如果只有一个显式声明的抽象方法，那么它就是一个函数接口。
也就是你生命一个接口，这个接口只有一个显示的抽象函数，那么这个函数其实就是lamda表达式本身。你可以写个类来实现它，然后在传入lamda表达式的位置传入这个类的实例，效果与lamda表达式是一样的。 这个接口可以使用一个注解来注解出来:@FunctionalInterface。
你可以用lamda表达式为一个函数接口赋值：
Runnable r1 = () -&amp;gt; {System.</description>
    </item>
    
    <item>
      <title>ZooKeeper</title>
      <link>https://Paladnix.github.io/posts/others/zookeeper/</link>
      <pubDate>Thu, 17 Aug 2017 10:06:34 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/others/zookeeper/</guid>
      <description>暂且将恼人的Tomcat放在一边，来解决新的问题，并学习新的玩意儿。
Zookeeper 是啥 # 动物园管理员，分布式服务就像是一个动物园。
Zookeeper是一个开源的分布式应用程序协调程序，为分布式应用程序提供一致性服务。 在分布式计算的应用中，最令人头疼的就是分布式锁的问题。同时各种同步问题也很让人崩溃，Zookeeper就是封装可一些算法，保证了其分布式服务的一致性，作为很多分布式服务的基础服务程序。
ZooKeeper 的设计原理 # 官方称之为鸟瞰：
第一段在百度百科上。 在特性上面，zookeeper有这样几个特点。
使用文件系统的结构来存储数据。 数据在用户的角度来看，是以类似与unix文件系统的方式来组织的，所以其定位方式是使用路径来定位数据。但是与文件系统不同的是，每个结点都可以存储数据，没有文件夹和文件的区别概念。
高并发低延迟。 存储的数据在每一个zookeeper服务节点上都是一样的，所以读数据只要连接一个服务器直接读取就可以。数据的大小被限制在1M以内。
高可用，自动故障转移。 这个是其设计的精髓之一，下面重点会讲。
下面概要的讲一下运行的逻辑。
选举 第一个，非常重要的步骤就是选举，在集群上部署完zookeeper以后，他们便开始执行选举流程，使用选举算法Fast Paxos作为基础。选举会产生一个leader。
客户端与server 当有客户端与一个服务器建立连接的之后，他们之间会维持一个tcp连接，客户端会给服务器发送心跳请求，告诉服务器自己还在线。如果一个server监测到一个客户端断线了，就会在本地清除相关的数据。而客户端会重新去找一个server建立连接。
写请求 在客户端读取数据的时候只要在其对应的服务器上读取就可以了。当其要写数据的时候，server会将这个写请求转发给leader服务器，leader将这个写请求统一发给每一个server进行写数据操作，当确认有严格的大于一半的server都写入成功以后，就算是写请求成功，再返回给原server，由原server返回成功给客户端。
重新选举 leader会给server之间保持通信，通常就是所说的心跳。leader通过心跳来确认server是否存活，同时，server也可以确认leader是否存活，如果leader挂了，servers就会重新进行选举，然后再提供服务。
通知 watcher是zk比较特殊的设计，允许一个或多个客户端绑定多个节点数据。当zk上的数据发生变化的时候能够通知到相应的客户端。这个设计就可以用来做很多的应用啦。redis数据库同样也有提供这样的消息发布与订阅的功能，不过那个是特意实现的一个功能给应用使用的。
实现上的诸多细节 # 在听之前的老司机分享的时候，他们探讨了很多实现细节上的问题，感觉实现这样的一个分布式系统还是非常有挑战的。
比如，如果写请求进行中leader挂掉了怎么办，数据tcp丢包了怎么办。如何同步数据等等。有空很想看看其实现方式。
使用 # (这里补充一下服务器版的安装。与使用)
最主要的使用途径还是通过客户端程序来访问zk。客户端有Java、python、lua、Go等。 我用java，所以。。
maven # &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.zookeeper&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;zookeeper&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.5&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 不过，这个有一点低端，所以我使用另外一个客户端的实现：curator。也是一个开源的zk客户端的实现，封装层次更高，所以操作更简便。
Curator框架提供了一套高级的API， 简化了ZooKeeper的操作。 它增加了很多使用ZooKeeper开发的特性，可以处理ZooKeeper集群复杂的连接管理和重试机制。 这些特性包括：
自动化的连接管理: 重新建立到ZooKeeper的连接和重试机制存在一些潜在的错误case。 Curator帮助你处理这些事情，对你来说是透明的。 清理API: 简化了原生的ZooKeeper的方法，事件等 提供了一个现代的流式接口 (提供了Recipes实现： 如前面的文章介绍的那样，基于这些Recipes可以创建很多复杂的分布式应用.这部分不明白，待补充)。
Curator框架通过CuratorFrameworkFactory以工厂模式和builder模式创建CuratorFramework实 例。 CuratorFramework实例都是线程安全的，你应该在你的应用中共享同一个CuratorFramework实例.
工厂方法newClient()提供了一个简单方式创建实例。 而Builder提供了更多的参数控制。一旦你创建了一个CuratorFramework实例，你必须调用它的start()启动，在应用退出时调用close()方法关闭.
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.curator&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;curator-recipes&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.7.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 这个版本的API 是流式的API，也就是。。用的时候一句话里有一串的调用，不断的点操作符。 for 一个zample: client.</description>
    </item>
    
    <item>
      <title>tomcat Server.xml及其启动顺序</title>
      <link>https://Paladnix.github.io/posts/web/tomcatserver/</link>
      <pubDate>Wed, 16 Aug 2017 15:25:20 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/web/tomcatserver/</guid>
      <description>欲仙又欲死。阿里巴巴真是一朵大奇葩。 一个写死的回调地址就能浪费我两天的时间去搞，还没有搞定。此坑绵绵无绝期。 一个sso的回调地址，写死的，要强行将应用部署到ROOT里中去。
在tomcat中有一个配置文件经常被用到，conf/server.xml。这个配置文件描述了如何启动tomcat server。 tomcat是servlet的容器，也就是能够运行servlet的一个程序。作为一个http服务的程序，可以监听端口，处理请求等。
配置文件结构 # &amp;lt;Server&amp;gt; &amp;lt;Listener /&amp;gt; &amp;lt;GlobaNamingResources&amp;gt; &amp;lt;/GlobaNamingResources &amp;lt;Service&amp;gt; &amp;lt;Connector /&amp;gt; &amp;lt;Engine&amp;gt; &amp;lt;Logger /&amp;gt; &amp;lt;Realm /&amp;gt; &amp;lt;host&amp;gt; &amp;lt;Logger /&amp;gt; &amp;lt;Context /&amp;gt; &amp;lt;/host&amp;gt; &amp;lt;/Engine&amp;gt; &amp;lt;/Service&amp;gt; &amp;lt;/Server&amp;gt; 对我们来说，内层的Service才是有操作意义的部分。主要的部分简介如下：
元素 说明 service 提供服务的主体，默认的名字是Catalina Connector 客户端与服务端之间的连接，包括端口，协议版本，超时时间，等。 Engine 请求的处理机，接收和处理Connector的请求， 与host的联系比较大 Context 表示一个应用 host 表示一个虚拟主机 Tomcat Server处理一个http请求的过程 # 假设来自客户的请求为：http://localhost:8080/wsota/wsota_index.jsp
在这里有一幅图我觉得非常清晰的说明了这个过程，但是其本身跟这个毫无关系。
请求被发送到本机端口8080，被在那里侦听的Coyote HTTP/1.1 Connector获得 Connector把该请求交给它所在的Service的Engine来处理，并等待来自Engine的回应 Engine获得请求localhost/wsota/wsota_index.jsp，匹配它所拥有的所有虚拟主机Host Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机） localhost Host获得请求/wsota/wsota_index.jsp，匹配它所拥有的所有Context Host匹配到路径为/wsota的Context（如果匹配不到就把该请求交给路径名为&amp;quot;&amp;ldquo;的Context去处理） path=&amp;quot;/wsota&amp;quot;的Context获得请求/wsota_index.jsp，在它的mapping table中寻找对应的servlet Context匹配到URL PATTERN为.jsp的servlet，对应于JspServlet类 构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet或doPost方法 Context把执行完了之后的HttpServletResponse对象返回给Host Host把HttpServletResponse对象返回给Engine Engine把HttpServletResponse对象返回给Connector Connector把HttpServletResponse对象返回给客户browser Context # 来看最重要的Context， 一般我们为每个应用做的定制化的东西都是依靠这个来做的，就比如我们要把war包部署成一个默认的应用。</description>
    </item>
    
    <item>
      <title>Java Json And Object</title>
      <link>https://Paladnix.github.io/posts/java/javajsonandobject/</link>
      <pubDate>Tue, 15 Aug 2017 20:20:44 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/javajsonandobject/</guid>
      <description>在写RESTFul风格的接口的时候最经常使用的就是Json和对象的互换。 今天记录一下阿里巴巴开源的FastJson的使用方式。
FastJson号称最快的Json解析工具包。有幸听了作者的分享会，并且在前几天的转正答辩的时候，他作为我的面试官之一。花名很奇特，叫高铁，可能这就是FastJson为什么这么快的原因吧。
在听分享会的时候，惊叹于其将一个小小的工具包中运用了如此多的优化方式。他曾是阿里安全团队的一元，对于Java底层非常了解，并且一些算法能力也很强，更是运用了产生式编程的神奇方式编写了这个工具包的某些部分。
package # 这是开源的工具，听闻，据说是阿里对Java社区做的最大贡献了。
import com.alibaba.fastjson.*;
maven: # &amp;lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2.36&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; Example # 其对于json的操作都是在几个静态类中进行的。 举几个常用的例子来说名用法：
将Json文本数据信息转换为JsonObject对象，通过键值对获取值 # private static void json2JsonObject() { //一个JsonObject文本数据 String s = &amp;#34;{\&amp;#34;name\&amp;#34;:\&amp;#34;xxx\&amp;#34;}&amp;#34;; //将JsonObject数据转换为Json JSONObject object = JSON.parseObject(s); //利用键值对的方式获取到值 System.out.println(object.get(&amp;#34;name&amp;#34;)); } 将Json文本数据转换为JavaBean # 需要注意的是，Json文本信息中的键的名称必须和JavaBean中的字段名称一致。
private static void json2BeanM2() { String s = &amp;#34;{\&amp;#34;id\&amp;#34;:\&amp;#34;xx\&amp;#34;,\&amp;#34;city\&amp;#34;:\&amp;#34;xxx\&amp;#34;}&amp;#34;; //一个简单方便 的方法将Json文本信息转换为JsonObject对象的同时转换为JavaBean对象！ Weibo weibo = JSON.parseObject(s, Weibo.class);//Weibo类在下边定义 System.out.println(weibo.getId()); System.out.println(weibo.getCity()); } Map类型的数据转换为JsonString # Map&amp;lt;Integer, Object&amp;gt; map = new HashMap&amp;lt;Integer,Object&amp;gt;(); map.</description>
    </item>
    
    <item>
      <title>Java HttpClient</title>
      <link>https://Paladnix.github.io/posts/java/javahttp/</link>
      <pubDate>Tue, 15 Aug 2017 20:07:20 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/javahttp/</guid>
      <description>来记录一下Java 发起Http请求的方法。
这里使用的是org.apache.http包中的一些封装工具。
首先实例化一个client： CloseableHttpClient httpclient = HttpClients.createDefault(); 然后来实例化一个URIBuild： URIBuilder builder = new URIBuilder(url); 如果Http请求带有参数，就设置在uri中： builder.setParameter(key, value); 实例化一个Httpget/Httppost: HttpGet httpget = new HttpGet(builder.build()); HttpPost httppost = new HttpPost(builder.build()); 你可以设置请求的Header： httpget.setHeader(&amp;#34;Accept&amp;#34;, &amp;#34;application/json&amp;#34;); // 接收json数据格式 发送请求： CloseableHttpResponse response = httpclient.execute(httpget); 查看请求结果： if (response.getStatusLine().getStatusCode() == 200) { String content = EntityUtils.toString(response.getEntity(), &amp;#34;utf-8&amp;#34;); } 更多设置可以直接补全出来看。</description>
    </item>
    
    <item>
      <title>Cookie</title>
      <link>https://Paladnix.github.io/posts/web/cookie/</link>
      <pubDate>Mon, 14 Aug 2017 23:02:35 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/web/cookie/</guid>
      <description>由于Http协议本身是没有状态的，每个请求都要建立新的连接。Cookie就是为了弥补这方面的不足而设计的，主要用来跟踪会话。
会话 # 跟同一个机器中的同一个应用在一段时间内的通信交互，我们可以认为是一个会话(Session)。 会话与会话之间需要被隔离开。
形象的理解 # Cookie就像是你的一张证明，并且，你跟不同的对方打交道用的是不同的证明。你会把这个证明带在身上，你可以在证明上写东西，对方也可以在上面写东西。在有需要的时候，双方都可以打开这个证明来看看里面的内容。 其本质其实就是一个键值对形式的文本信息。
在控制台中，输入命令：alert(document.cookie) 就可以看到你与当前页面应用之间保存的cookie内容。 手机上的浏览器一般不支持cookie。
跨域 # cookie是以域名作为单位的，同一个域名共享一个cookie。不同域名之间不能操作对方的cookie。 这里就是sso主要要解决的难点。
跨域设置Cookie有几种实现的方式，其中最方便的就是使用jsonp的方式来实现。
jsonp 跨域 # 在JQuery中使用ajax可以处理同一域名下的重定向请求。但是其处理不了跨域名的重定向。
也就是在同一个域名下进行重定向，ajax使得重定向对用户来说是透明的。但如果是跨域的，ajax就会报错。</description>
    </item>
    
    <item>
      <title>sso 单点登录</title>
      <link>https://Paladnix.github.io/posts/web/sso/</link>
      <pubDate>Mon, 14 Aug 2017 10:57:24 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/web/sso/</guid>
      <description>每天要接N多个需求，我也是很怀疑人生。本是在集群运维组干着运维系统开发，却被隔壁存储数据库组拉着每天做些数据结构思考题，虽然到现在我已经积攒了很多个思考题没来的及思考了。今天又来了个自己组的一个月前的bug要搞定。
多应用服务下，实现单点登录，多点信任的方案。
SSO的基本概念 # 在wiki上的解释非常清晰，比其本身的名字(Single Sign-On)更清晰：在一个多应用但彼此独立的系统上，只要进行一次登录就可以在不同的应用中获得信任。就是你在淘宝登录一下，然后你在咸鱼、tmall、阿里云等等网站上都不用登录了，就可以直接被识别出来，不过是在一定时间长度内。
基本问题 # 实现这个系统有两个问题：
用户数据统一 系统内信息统一 首先就是你的一个用户名和密码在每个应用上都能登录。其次就是在你登录以后其他的应用都能获取到这个登录信息。
解决这个问题的主要思路就是建立一个公共的缓存，所有的应用都去这里提取用户的信任信息。有了公共缓存以后，问题的核心又转移到了客户端。因为客户端（这里就是指浏览器）在访问每个应用的时候所带有的信息是不一样的，所以你去缓存中也提取不到这个信息了。主要解决的就是如何让客户端在访问同一个系统中的不同应用的时候带有一个相同的ID信息。
Cookie # 这一部分的具体细节可以看下一篇博客。
SSO的基本流程 # 在网上看到了很多实现方式的分析，还有人要步步深入，循序渐进。我觉得这个模型还是比较简单的，所以就直接来聊聊这个模型就可以了。
我们模型要解决的问题是：跨域名的单点登录。 问题主要使用的技术就是Cookie。
主要流程 # 本机客户端也就是浏览器，发起一个请求到目标应用的服务器。 服务器判断你没有登录，因为你没有携带任何的凭证信息在你的Cookie中。 于是给你返回一个302，302就是一个重定向的返回代码，并且与之匹配的还有一个参数也会被返回过来，就是重定向的目标地址。同时还携带了这个服务器自己的URL地址，也就是你最终要访问的那个。 浏览器接收到302和参数以后，自行发起一个到重定向地址的请求。请求中有一个参数，就是原目标地址。 链接上这个地址，并且这个页面一般就是个登录页面。登录完成以后，这个第三方的服务器会在你的Cookie里写一个TokenId，并且也返回给你一个302。这次重定向的目的地是你真正要访问的地址。 你的浏览器接受到这个参数就再一次发起请求，并且在Cookie中带有了一个TokenID。 目的服务器验证成功，登录成功。 对于上面的过程中有几个东西要解释一下。
302 # 这是HTTP的一个状态码，表示暂时性的重定向到另外一个地址上去访问。在浏览器收到这个状态码的时候就去请求新的URL。
在php代码中，我们写&amp;lt;?php header(&amp;quot;Location:http://ip/path/&amp;quot;); ?&amp;gt;就是返回一个重定向302的状态。基础知识很重要。
在下一篇Cookie中，也有这方面的内容。
如何认证 # 我自己用php写了一个简单的模型。还是比较简单的。 下面就按步骤介绍一下：
修改本地hosts # hosts作为你的联通网络的第一个路由表，你可以做一些修改，比如给自己的电脑绑定n个不同的域名。 当然这个域名只在你的路由表中，所以只在你的电脑上管用。不过没关系，我们用这种方法模拟出了一个跨域名的环境。
ubuntu下hosts文件：/etc/hosts
在其中添加：
127.0.0.1 baiyan.a 127.0.0.1 paladnix.b 然后我们编写下面的几个php文件来模拟整个过程，文件位置在/var/www/html/sso/下。
过程 # 首先我们去访问：http://baiyan.a/sso/hello.php
&amp;lt;?php if( ($_GET[&amp;#39;uuid&amp;#39;]== &amp;#39;&amp;#39; || $_GET[&amp;#39;uuid&amp;#39;]!=553) &amp;amp;&amp;amp; ($_COOKIE[&amp;#39;uuid&amp;#39;]==&amp;#39;&amp;#39; || $_COOKIE[&amp;#39;uuid&amp;#39;]!=553 )){ header(&amp;#34;Location:http://paladnix.b/sso/log.php?call_back=http://baiyan.a/sso/hello.php&amp;#34;); } else{ setcookie(&amp;#39;uuid&amp;#39;, $_GET[&amp;#39;uuid&amp;#39;], time()+3600); echo &amp;#34;Hello &amp;#34;.</description>
    </item>
    
    <item>
      <title>每天读点Spring(2)--Start</title>
      <link>https://Paladnix.github.io/posts/java/spring-2/</link>
      <pubDate>Sat, 12 Aug 2017 19:02:40 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/spring-2/</guid>
      <description>在本章中，作者开篇就讲到，学习一个新的开发工具最难的就是不知道从哪里入手，尤其是Spring这样有很多选择的框架。但是幸好在这本书中是简单的，下面介绍一些必要的基本知识。
这就是很人性的化的写技术书籍的方式，透露出考虑之周到。 我觉得很多时候，国内的教育体制总是要用比人家多的时间去学会一个东西。很多人看到老外中学成绩都很差，到了大学才开始学习。但是仔细想一下就会发现不太对劲，为什么人家学习的深度比我们还深呢？明明没有我们的基础好，也没有我们花费的时间多啊。
我觉得很大一部分原因是国内的教材有问题。很多教材都是非常的笼统的介绍一个东西是什么，然后就搬上一大堆理论出来证明。但是让人看了很费劲，因为我不一定就具备了看懂这个知识的基础能力，可能我要先去了解一下什么东西再来看这个会效果更好。在我看的很多国外工程师写的文档或者是书中，都有这样的设定，要么会给出在你继续往下看之前你需要去了解的知识清单，要么就直接把需要的知识写在正式内容之前。这是一个非常负责的行为，在人家眼里是很正常的事情，在我们这里可能就是不在我的工作范围中。就像初中上高中的时候，初中老师说这个你们在以后上高中就知道了，高中老师说，你们应该在初中就学过了。有些老师会讲，这些老师的学生就会很轻松的就掌握这部分东西。
不要觉得什么都要别人告诉你很low，学习就是一个这样的过程，你需要别人不断的告诉你一些东西，那些已经被解决的问题不是你主要要解决的问题，而是你要快速掌握的理论。你在学车的时候如果碰到一个什么都不教，直接让你把车开起来上路的师傅，你就会说：“如果我什么都知道还要来学嘛？”，就是这个道理。
国内很多作者纯粹就是急于求成，这些看似不是自己的责任的事情就不做，默认你会。然后把那些确实是核心的问题官方的表述一下，就算是写完了一本技术著作。很不厚道，我作为学生非常鄙视这样的人。
需要具备的知识 # 也不能算是知识，是关于Spring的一些更细节的信息，和设计。
理解Spring的包 # 这部分介绍了Spring是由哪些模块构成，你可以按照自己的需求选择使用那些模块，并介绍了每个模块的基本功能。
在Spring4.0.2发行版中一共有20个包。每个模块的包名格式如下，以aop为例：spring-aop-4.0.2.RELEASE.jar
Jar File Description aop 如果你要用到AOP功能，或是你用到的Spring的其他模块用到了这个功能，你就需要把这个包添加进你的项目中 aspects 如果你用到了AspectJ AOP的功能就要包含这个包（Aspectj是Eclipse出的一个AOP的编程框架，Spring 兼容了它） bean 包含了所有用来实现Spring控制bean的类，其中很多类也都支持Spring的bean工程模式，例如解析xml和注解的类 context 这个包给Spring core提供了很多扩展能力，Spring的很多功能都依赖于此，并且实现交互的脚本语言也是集成在其中的 context-support 这个包有扩展了context的功能，例如邮件支持、模板引擎例如Velocity、FreeMaker，此外还有很多作业的执行和调度，例如CommonJ(计时器)和Quartz(作业调度)都打包在这里。 core 这是你必须包含的包，其中的类被用在很多其他的包中，并且有一些全局工具你也可以用在自己的代码中 expression 这个包是支持Spring Expression Language的，是一种强大而简洁的装配Bean的方式 instrument 这个模块包括Java虚拟机的引导(翻译有待确认)？当你在使用AspectJ时需要使用这个包 instrument-tomcat JVM Bootstrapping in the tomcat-server jdbc 数据库链接操作相关 messaging 是基于消息的应用相关的，以及支持STOMP消息文本协议 orm 扩展了JDBC，支持ORM框架，诸如Hibernate、JDO、JPA oxm 支持Object/XML Mapping (OXM) test 提供了强大的单元测试的功能，紧密集成了JUnit tx 支持分布式事物操作 web web功能的核心，支持了文件上传，参数解析等 web-mvc 支持MVC模式的web web-portlet 门户网站服务器部署支持（Not know） websocket 支持Java API for WebSocket（Not know） 随后讲了你可以用maven获取这些，就像你不知道maven一样</description>
    </item>
    
    <item>
      <title>每天读点Spring(1)--Introduction</title>
      <link>https://Paladnix.github.io/posts/java/spring-1/</link>
      <pubDate>Fri, 11 Aug 2017 19:04:41 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/spring-1/</guid>
      <description>Java如果没有Spring，绝不会这么流行。 Spring将很多Java的设计模式框架化，使得Java的开发效率得到很大的增长。
想系统的学习一下Java，但是又要与工作接轨，所以就选择了Spring这个中间的角色来开始学习。我学习的教材主要是英文版的《Pro Spring 4》，这本书在CSDN上有pdf版本，不是影印版，非常优质。 为什么不用中文的呢，一个是因为中文的书中在Introduction上就写得不好，无法从宏观上去解释这个框架的精髓，这个很致命，想比较外文版的读物，虽然偏长了一些，但是很对概念能够很清晰的表述，对于我这样的技术新人来说很重要。另一个原因是，本身的英语能力没有场景去使用，看看英文的技术专业书籍，有利于英语能力也更有利于以后看英文的代码注释。
每天坚持看一点，是个很难的工作。
What is Spring. # 在第一章中对Spring这个项目本身做了一些介绍。包括这个项目是在Java一片火热的情况下诞生的，并且诞生至今非常的优秀等等。
我觉得最重要的是，作者解释了什么是轻量级这个问题。
所谓轻量级并不是代码量很少也不是代码的框架设计很简单，而是一种传达除了Spring这个框架自己的思考哲学，就是让Java项目变得轻量化起来。
随后介绍了Spring项目的两个最重要的技术基础，IOC(控制反转)或者在文中着重讲述的DI(依赖注入)的说法。在前面的文章中我已经介绍过这个概念，在设计模式上属于工厂模式的一种实现。还有一个就是AOP(面向切面编程)，也有人理解为面向方便编程。
除了这两个重要的技术基础以外，介绍了Spring框架本身有非常多的方便的设计，兼容非常多的东西，在数据交互、xml、交互式脚本语言等方面都做了很多的工作，并且引起Java标准基金会的注意，影响了基金会的很多标准的制定等。
介绍就是要这样，从宏观上去提纲挈领的介绍一个事物。</description>
    </item>
    
    <item>
      <title>实习转正答辩</title>
      <link>https://Paladnix.github.io/posts/self/alibaba/</link>
      <pubDate>Fri, 11 Aug 2017 16:05:42 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/self/alibaba/</guid>
      <description>今天下午进行了实习转正答辩，有很多经验总结下来。
走进工作岗位的几个阶段 # 首先第一个是实习生面试，这个在每年的春招的时候会进行，也就是我进入阿里巴巴进行的第一次6轮面试。那个面试的经历想比较今天的经历其实是比较简单的。
通过面试以后就算是一个试用期实习生了，大概会经历一个多月左右。实习生的试用期会做一些工作，并且这也是实习转正答辩的主要内容。
如果通过了实习转正答辩，那就是正式的实习生了，我也是最近才知道的，原来这个实习转正是从试用期实习生转到正式的实习生，可见整个工作的流程是比较复杂的，压力也不小。
在实习的后期跟你签了三方协议也只是一个录用意向的协议并没有法律效力。
在你实习结束以后正式入职还有一段试用期，时间一般跟你的签约年限有关。签的时间长试用期也就相应的长。
转正答辩的几点经验 # 在此次转正的答辩准备过程中，我觉得自己准备的比较好，但是忽略了一些情况，导致最后的发挥并不是很好。 这是经验的问题，因为接触的面试官不太多，所以在遇到某些问题的时候就脑子短路了。经验真的很重要，不同的面试官的关注重点都不一样，所以要不同的策略去应对。
本次在做答辩的之前，我自知自己的工程功底不强，所以在准备做的工作的同时，还做了多一手的准备，那就是我最擅长的算法方向。打算以此作为自己的优势去提升自己在工程深度上的不足。 毕竟我是刚入行Java的新手，做工程一定不如很多一直做工程的人，另一方面自己这一个月接触的项目虽然多，但是并没有什么太深度的难点，所以也没有机会去解决，也就没有什么工作的亮点可以展现。
我在工作的过程中自己学习了redis数据库中两个我认为比较有意义也比较有特点的算法，在我的博客中也写过。我通过这两个算法说明一个问题，就是数据库的发展方向可以脱离原本的通用解决方案，转为为特定场景设计实现算法来解决特定问题。
用这样具有前瞻性的眼光来凸显自己的价值。
这个方案在我做完ppt以后被我的师兄提出了没有意义。但是我坚持保留了这个东西。 随后在跟我的主管预汇报的过程中，主管表示很好，突出自己的优势而且这个思考很有价值。我觉得，这就是不同级别的人思维格局吧。东西就在那里，你能看到你才有可能拿到，看不到永远也拿不到。
答辩的时候，其中一个人是FastJson项目的作者，这就是没有意料的地方。我以为会是一个偏管理+一个偏工程+一个hr的阵容。但是这个偏工程的又有点偏算法，面试官熟算法倒不是什么问题，关键是我们的算法认知不同。这就非常的尴尬。
在第一个算法之后他问了一些算法的细节，尤其是在算法的最终实现是字符串还是int值的问题。 因为我本身是搞ACM的算法竞赛，这个竞赛的重点在于利用思维模型去解决问题，而不是去研究最底层的实现中节省掉的int和char之间的空间差距。当然我不是说这些东西不重要，当然重要。只是我并不去实现这个算法，所以也就没有去研究在实现的细节上是什么方式。另一方面，学习这个算法本身就不是我的工作范围，所以就没有时间去深究。 我只是想透过这个算法去发现数据库的最新发展方向。但是被面试官过于深入的带偏进入这么工程细节的问题是我没想到的。
这就是面试中的一个常见的问题：
同一个事情，关注点不同 # 我关注的是算法带给我的发展认知，面试官关注的是这个算法你有没有学的很深，有没有学到落地。 这很显然不是自己想去探讨的方向，所以这个时候要么你真的落地了，要么就要及时引导面试官到你的方向上去。但是最好的选择就是问不倒，无论你问什么我都能答出来，是最好。
如果要在这个时候引导其实是不好引导的。因为面试官本身以为自己难住你了，你强行避开这个问题就会被打上学艺不精的标签。你还必须得正面的、恰到好处的回答这个问题。
怎么回答这个问题呢，就要敢想，随机应变开始跟面试官讨论。比如面试官问你为什么不用int编码，这个时候你就要有个折中的回答，一般就要根据现实需要来选择存储的实现方式。随后千万不要贸然的回答问题，一定要把这个问题问的足够细以后再选择性的回答。在问问题的时候也要引导到你擅长的方向。当你说出根据不同的场景会有不同的实现方式的时候，就给了自己提问的主动权，就反问面试官你想比较他们两个之间的哪个方面，是解析时间上、计算上、存储上、取数据上等。然后不断的细化到一个用基础理论可以解决的问题，你就完成了完美的反杀。
一般计算机上的实现总是这样的，在时间和空间上取舍、在存数据速度和取数据速度上取舍、在计算方式上取舍。所以这样的问题总是能够曲线来回答的，千万不要慌。然而当时我就慌了，回答不是很完美。
有些面试官其实就是丢个问题给你，他自己也没有思考很多。所以当你开始跟他讨论的时候，把这个问题抛给他，如果他也没想清楚具体要问你什么，你就可以开始引导了。如果你熟悉算法的计算效率问题，那就往时间效率上引，你熟悉数据存储的东西就往存储上引。实在没有什么擅长的问题就跟他来这么几个来回，他也不会给你个差评的。往往有些时候深入下去，面试官本身也不擅长了，也就不深究了。
扩展出来问你 # 当你提到一个东西以后，面试官往往会扩展出来问你一些东西，问你既然懂这个你懂不懂其他的相关的啥啥啥。
这也是比较棘手的问题，事实上你也真的没有机会或时间去学习扩展那么多，毕竟你才学习了这几年，又要宽度又要深度是很难的，同样你也不能就直接避开这个问题。
对于这个问题，其实就没有上面的那么好扭转，你只能打打心理战。毕竟扩展的知识有哪些，你不知道也没办法把问题细化到可以理论解决的地步。我推荐的做法是变成一个弱者。去请教对方，这个东西还有哪些扩展，自己可能精力有限，或不是专业搞这个，就没有覆盖到那些。对方如果是个门清儿的专家，回答了你，你就赚了，你还有个好学的印象。如果对方也不懂就诈诈你，那他也就不会在这个问题上继续了。自己不会的东西，别人也不会也不会就给你差评的。
没见过的名词一定要问一下 # 然后在实现的细节上我们简单的交流了一些，他提到了前缀树。
尼玛，后来我才知道这个前缀树是字典树的别名，而且是20年前的名字。我说我不知道，我知道后缀树。后缀树的复杂度是字典树的10倍，但是这个面试官不知道。。。很遗憾这个问题又GG了。
所以遇到相关领域你没听说过的东西，就不太可能。面试官问出来的问题一定不会非常深入的东西，都应该是你至少听说过的东西。更何况我一个搞算法的怎么会没听过一种树结构呢？
这个时候应该就是叫法不同，问一下这个东西有没有什么别名，或是实现方式是什么。应该很快你就知道这个东西是什么了，即使不是很清楚，从一些信息中也能知道个原理大概，跟面试官简单吹吹还是可以的。
问我既然是学算法的，有哪些你会的不是教科书上的算法 # 这个问题，我草。我被问蒙了，我怎么知道哪个算法不是教科书上的算法啊！你说哪个不是书上的？ 然后这个问题我就跟没回答一样，说了一点疑惑和解释他就继续下一个了。
其实，面试官本身想问的问题，重点不是教科书。而我抓错了重点。他事实上是想问你有什么算法是一般人不会的，而你会。再换句话说，是他不会而你会的。
这样理解这个问题以后，尼玛，这不正中我下怀了。这简直就是装逼时刻，此时不装逼更待何时，打比赛的那些神奇算法名字往外扔就是喽，我特么能给你说一下午。
然而，我当时没有反应过来。失策失策。。。
总结了一下，一向唬得住面试官的我为什么犯这么低级的错误呢? 我认为就是被前面的几个问题给问虚了。几个出乎意料下来，整个人的气场都下来了。下面就开始被各种蹂躏。
所以，一定要不能虚，虚个蛋蛋。
一个堂堂金牌爷，总有你会他不会的东西，虚个蛋！就算他问的问题你不会，这又怎么了。要自信，老子又不干你的工作，干嘛会你的那套。况且我今天不会我明天就会，不行嘛！ 在此基础上，做到态度好，技术硬，来者不惧，能屈能伸。忽悠个面试官还是小菜一叠。</description>
    </item>
    
    <item>
      <title>Java 多线程实现异步调用</title>
      <link>https://Paladnix.github.io/posts/java/java-5/</link>
      <pubDate>Thu, 10 Aug 2017 16:53:28 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/java-5/</guid>
      <description>异步调用最主要的特点就是调用方并不等待函数的结果，而是继续进行下面的动作，函数自己去完成相应的过程。在函数完成以后将结果以某种方式返回给调用者。
实现异步的方式有很多，在前端的技术中使用的最多，这里我记录一下Java项目的内部自己异步调用某个函数的方式。
角色 # 在异步调用中，有三个角色，分别是消费者、取货凭据、生产者。对应的就是调用方、数据返回方式、执行函数。
举小蛋糕的例子非常好理解，订蛋糕、蛋糕店给你个取蛋糕的收据，或者也可以给你送到某个地方、蛋糕店生产蛋糕。
消费者 # 首先来看一下调用方的代码应该怎么写。
public class Customer { public static void main(String[] args) { System.out.println(&amp;#34;main BEGIN&amp;#34;); CakeShop host = new CakeShop(); Cake cake1 = host.request(10, &amp;#39;A&amp;#39;); Cake cake2 = host.request(20, &amp;#39;B&amp;#39;); Cake cake3 = host.request(30, &amp;#39;C&amp;#39;); System.out.println(&amp;#34;main otherJob BEGIN&amp;#34;); try { Thread.sleep(2000); } catch (InterruptedException e) { } System.out.println(&amp;#34;main otherJob END&amp;#34;); System.out.println(&amp;#34;cake1 = &amp;#34; + cake1.getCake()); System.out.println(&amp;#34;cake2 = &amp;#34; + cake2.getCake()); System.out.println(&amp;#34;cake3 = &amp;#34; + cake3.</description>
    </item>
    
    <item>
      <title>spring-shell</title>
      <link>https://Paladnix.github.io/posts/java/spring-shell/</link>
      <pubDate>Thu, 10 Aug 2017 13:59:53 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/spring-shell/</guid>
      <description>这是一个spring框架提供的编写shell命令的一个工具，能够让你用spring的编程模式编写命令支持在shell运行。
看一下这个工具的框架是怎么样的。documentation地址。
核心组件 # spring shell 的最核心的组件是三个：plugin model、built-in commands and converters。
Plugin Model # 插件模块我理解的就是将你写的命令加载进去。你的每个jar模块都要包含一个文件：META-INF/spring/spring-shell-plugin.xml。这个文件会在shell启动的时候被加载并生成Spring的上下文。 在这个文件里你需要定义你的命令相关的类。当然你也可以用spring的扫描功能去自己扫描一个包，然后自己将相关的类进行加载。
这个文件可以写成这样：
&amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:context=&amp;#34;http://www.springframework.org/schema/context&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd&amp;#34;&amp;gt; &amp;lt;context:component-scan base-package=&amp;#34;org.springframework.shell.samples.helloworld.commands&amp;#34; /&amp;gt; &amp;lt;/beans&amp;gt; 这里官方的文档说：所有的类都是用同一个类加载器加载的，所以建议提供一个类加载器进行隔离。
这些命令是Spring组件，使用@Component注解进行划分。例如，HelloWorldCommands类的示例应用程序是这样的
@Component public class HelloWorldCommands implements CommandMarker { // use any Spring annotations for Dependency Injection or other Spring // interfaces as required. @CliCommand(value = &amp;#34;delete-group&amp;#34;, help = &amp;#34;delete group&amp;#34;) public String deleteGroup(@CliOption(key = {&amp;#34;id&amp;#34;}, mandatory = true, help = &amp;#34;The id of &amp;#34; + &amp;#34;the group&amp;#34;) final String id) { ClientResponse response = RestClient.</description>
    </item>
    
    <item>
      <title>状态机编程</title>
      <link>https://Paladnix.github.io/posts/java/status/</link>
      <pubDate>Wed, 09 Aug 2017 15:32:16 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/status/</guid>
      <description>状态机是一种程序设计模式。
这种设计模式适合在一些场景下使用，比如一个任务可能拆开成不同的部分去做，这些动作可能是异步的也可能是同步的，这个时候我们用一个for循环来搞就会很麻烦，最重要的是很丑。
我们希望能做成事件驱动的程序，这个时候一个很好的设计模式就是利用状态机的思路来写。
问题特征 # 一个处理流程中一些部分都可以是异步的，并且每个步骤都有可能失败。
其实最主要的就是这个问题可能失败，所以我们希望在我们将失败的原因搞定以后，再次启动这个程序的时候可以继续从上一次失败的地方继续执行而不是将原来的操作进行回退，然后再重新跑一遍。
状态机编程 # 使用状态机的设计模式可以让程序直接跳到当前状态所处的位置，继续执行。
其实是很简单的，我们给我们的每个步骤都设计几个状态，最常见的状态就是start、success、faild等。
并且在一个状态结束以后会去回调一个函数去更改相关的事件的状态。将事件的状态保存在一个诸如数据库或是什么东西上。
这种设计思路可以应用在很多场景下，比如一个用户的行为会触发一个后台流程，后台要在做完这个流程以后再把结果返回给用户。如果等待程序返回就会浪费很多时间，很可能中间的某个环节失败了，这样的话又要重新来搞一次。
如果用状态机的设计模式，行为触发状态机的一个点，然后由状态机做后续的出发，等到收集到所有事件都成功以后再给用户返回个结果就可以了。同时用户也可以将这个请求做成异步的，不必等待程序的返回值。
对于状态机编程的事件，有一个最重要的一个就是事件的触发是由于状态的改变来触发的，所以只要我们去更改一个事件的状态我们的这个动作就算是做完了，至于触发的动作什么时候做完我们不管，会有一个状态标识的方式的。
思路就是这样的，具体的实现代码以后写其他的东西的时候再贴吧。</description>
    </item>
    
    <item>
      <title>随想-关于语言的一些感受</title>
      <link>https://Paladnix.github.io/posts/c&#43;&#43;/c/</link>
      <pubDate>Tue, 08 Aug 2017 16:41:48 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/c&#43;&#43;/c/</guid>
      <description>以前觉得C语言很菜，因为连面向对象都没有，一本C语言的书也就200页撑死了。
后来学习了C++，一本书动不动800页，多则1500多页，我以为C++很屌。
后来我接触了Java，发现这个语言虽然用的人很多，但是，很不优美，是一个非工程师可以用的东西。我还是觉得C++很屌。
再后来我接触了python，我觉得这个语言的作者是个奇葩，不过确实很多工具很方便，这个就是个功能偏强大的玩具了。但是确实很厉害，开发速度飞起来。不过我还是觉得C++很屌。
后来接触了bash脚本，哎，这个语言很有趣，但是很鸡儿菜，写起来别别扭扭的，就像搭积木一样，还不能搭太高。不过我还是很喜欢它的，但是我还是觉得C++很屌。
然后用起了php，虽然也是菜鸡儿，但是真的很直白嘛，是个人都能懂。所以C++还是屌。
最近用起了Javascript。我操！这语言特么有毒，乱七八糟的问题，虽然应用范围越来越多，但是还不那么优美，还是C++比较屌。
然后我发现了一个神奇的现象，Linux用C语言写的，mysql用C语言写的，各种驱动C语言写的，各种网关C语言写的，redis也是用C语言写的。为啥?
这说明了，特么的C语言才是最屌的。短短200页就道尽C语言精髓，短短200页就构建起了这个世界的一半基础。C语言有的除了指针，就是指针，再花哨一点的就是有函数指针这个大杀器。
那些说什么C语言指针难用应该都是傻逼吧。真正的程序员，指针就是万能的上帝之手好嘛！
至于C++，很强是实话，能驾驭C++的程序员也很强，这是大实话。但是，能驾驭C++的不多，这就很尴尬了。要对象有对象，要指针有指针，要动态绑定有动态绑定，要多态有多态。。。但就是出了Bug不太好找，没办法，就有点失宠了，不过说到底还是因为人菜！语言是好语言，所以C/C++最屌！
不要跟我说什么生产力，老子不Care！我不管！我就是喜欢，走不动道了。</description>
    </item>
    
    <item>
      <title>Redis 深度学习(1)</title>
      <link>https://Paladnix.github.io/posts/redis/redis-1/</link>
      <pubDate>Tue, 08 Aug 2017 16:13:44 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/redis/redis-1/</guid>
      <description>如果人生没有看过一个数据库的源码，那与咸鱼有什么区别。
准确的说，我所会写的代码都是从别人那里看来的。但是我所会写的代码就那么点儿，实在不怎么拿得出手。刚好遇到这个源码只有2万多行的纯C语言的数据库项目，怎么都得读读，否则不敢说自己会写代码。
Redis 简介 # 在之前有一篇关于redis的简介和安装的文章，所以就不从宏观上介绍了。
与memcached相比有下面这几个特点：
Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 Redis可以实现主从复制，实现故障恢复。 Redis的Sharding技术： 很容易将数据分布到多个Redis实例中 GitHub地址
Redis是单线程的，运行在CPU的一个核上。所以在线程的思路上整个程序是很清晰的。我主要从代码中学习一些网络编程的方法，C语言数据结构的写法，内存操作。
在redis4.0.1中一共有600多个文件，包含了C文件、bash脚本、Lua脚本、tcl脚本，额，，还有一些没见过的东西。太菜了，连文件后缀都没见过。
但是这些并不都是redis的代码，在src/文件夹中可以看到只有120多个c文件，这些才是核心。600多个是包含了一些测试文件和单元测试等等。
Redis的数据结构 # redis对外提供的数据结构在上一篇中也都介绍过，这里带着介绍一下其内部实现的方式。</description>
    </item>
    
    <item>
      <title>HyperLogLog 基数估计算法</title>
      <link>https://Paladnix.github.io/posts/redis/hyperloglog/</link>
      <pubDate>Mon, 07 Aug 2017 18:57:08 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/redis/hyperloglog/</guid>
      <description>在redis中还有一个很奇怪的部分，Hyperloglog。看到这个东西后我的第一反应跟大多数人一样，这个日志的东西是干什么的？
然而这并不是日志，而是一个十分高深的玩意儿，他的主要功能是估算诸如一个集合中的不同元素的个数，也就是基数估计。
这个算法号称用1.5Kb内存为十亿对象计数。
下面就来看一下这个算法，其实我也没有完全搞懂这个算法的所有细节，就简单的介绍下就好了。
背景 # 我们有很多场景，需要计算一个MultiSet的基数，如统计网站的访问IP数量等。
传统做法 # 在传统的做法中，我们可以开辟一个数据表每次累加出来。但是这个开销无论从时间上还是空间上，当数据量变大以后会变得十分巨大。随着一个参数的增长所以整个系统的参数都应该在上升，也就是说整个数据库系统都在面临巨大的压力。这个时候如果还这样做就很不明智了。
BitMap # 后来就聪明点了，这个应该就是程序员想出来的。
就是把每个IP映射到一个内存bit上，出现了就置1，没出现就是0。然后统计一下个数就可以了，抑或一下嘛。但是这个在空间上只做了个常数优化，搞过ACM的都明白，常数优化不算优化。
Linear Counting # 这个算法就是一个有一定数学基础的程序员搞出来的。
将IP映射到m个内存bit上去，然后还是统计1的数量，但是用最大似然估计的方式来估计总数的大小。这个在数学上是说的通的。
算法要求映射函数符合均匀分布，那么当基数很大的时候可以用正态分布逼近二项分布，正态分布的期望的最大似然估计是样本均值。所以我们就用这个最大似然估计来统计这个基数。
但是这个理论在很多情况下会有很大的误差，并且其对于m的要求很多，所以其空间复杂度也没有优化到哪里去。
LogLog Counting # 这个时候你应该懂标题中的LogLog是什么意思了吧，并不是日志的意思，而是算法复杂度。
这个算法对于Hash函数有下面几个要求：
H的结果具有很好的均匀性，也就是说无论原始集合元素的值分布如何，其哈希结果的值几乎服从均匀分布（完全服从均匀分布是不可能的，D. Knuth已经证明不可能通过一个哈希函数将一组不服从均匀分布的数据映射为绝对均匀分布，但是很多哈希函数可以生成几乎服从均匀分布的结果，这里我们忽略这种理论上的差异，认为哈希结果就是服从均匀分布）。
H的碰撞几乎可以忽略不计。也就是说我们认为对于不同的原始值，其哈希结果相同的概率非常小以至于可以忽略不计。
H的哈希结果是固定长度的。
以上对哈希函数的要求是随机化和后续概率分析的基础。后面的分析均认为是针对哈希后的均匀分布数据进行。
这个算法的基础是伯努利试验以及其推论。
伯努利试验是说：一次实验的结果只有发生和不发生两种，重复做这个实验，直到结果发生为止，记录下实验的次数。
然后讲与我们这个算法的联系。 算法的思路前面还是差不多，先把每个元素都Hash到一个固定长度的二进制串。那么这些二进制串最高位1的位置就符合这个定义。每个串都是一个伯努利过程，最高位1的位置就是第一次事件发生的试验次数。
回到理论本身，理论本身并没有给出解决这个问题的结论。但是在其一些推论的公式中隐含了我们要求得的基数，也就是伯努利过程的数量。
由两个问题引出这个公式：
进行n次伯努利过程，所有投掷次数都不大于k的概率是多少？ 进行n次伯努利过程，至少有一次投掷次数等于k的概率是多少？ (公式回头补，页面不支持latex很鸡肋)
这两个公式我们考虑极限情况的时候，就会发现，n就在2^k附近。这个就做为n的粗略估计。
下面就是要做偏差修正了。</description>
    </item>
    
    <item>
      <title>关于实习-alibaba Middle Ware</title>
      <link>https://Paladnix.github.io/posts/self/internship/</link>
      <pubDate>Fri, 04 Aug 2017 19:14:43 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/self/internship/</guid>
      <description>阿里巴巴中间件团队是一个技术水平非常强的团队。
首先想谈一谈，实习本身，我对实习的认识。
作为一名技术向的学生，实习的经历是十分重要的。如果有机会，最好从大二的暑假就开始出去实习。事实上无论你是什么方向的学生，实习都是非常重要的。
实习有这么几个目的，这几个目的也是我在选择实习单位的重要考虑因素。
体验未来几十年的工作生活。 了解业界的真实现状。 学习新的技术。 检验自己的能力。 指导自己未来的路。 下面就具体的展开来说一说，个人见解。
体验未来的工作生活 # 这真的是最最重要的事情，因为你未来将有40年的时光在工作的状态，在你真正要走进这段时间之前能有一个实习的机会去体验这样的生活会让你做好很多准备。
在上学的时候特别渴望工作，觉得上学很无聊，也很不自由，也没有收入。但是从我听说的同学的工作经历，我看到的阿里巴巴杭州西溪园区的1万名员工的生活状态，我觉得实习的这重意义很重要。 不同的公司，不同的岗位，不同的同事，上级，城市&amp;hellip; 这些因素会让工作之间产生巨大的差异，你要在这段时间想清楚一些事情。
你要在什么样的岗位工作 你想跟什么样的人共事 你要在什么样的城市 &amp;hellip;.
而这些事情有一些原则，是我觉得在这些问题中很重要的东西。
第一，一定要做一件你喜欢的工作。如果你做什么事情不开心，做什么都没有意义。这个工作不是非你不可，但是你自己的心情只是你自己的。至于心情好才能工作好这样的东西，谁都懂的大道理就不用我多说了。我想说的是，当你心情不好在工作的那段时间，在以后的你看，是极大的罪恶，对自己生命的美好时光的罪恶，所以一定要把自己的时间用来做让自己开心的工作。
第二，一定要跟聪明人共事。因为与不聪明人共事会导致你工作的不开心。
第三，要在一个有交流的队伍里工作，后面会讲到为什么。
当你体验过后，就会明白自己想要的工作到底是什么样子。 这也是马云在前两年回应阿里校招大规模缩减时所说的：”我们想要的是清楚自己要什么的人，那些还不清楚自己的要什么的人让他们去其他地方搞清楚再来吧。“
了解业界的真实情况 # 都说学校学习的东西与现实脱轨，那么到底现实是什么样子，这就是最真实的现实了。至于学校教的东西怎么样，下面也会讲到。
但是了解业界真实情况并不是为了回答上面这个传闻，而是要清楚的明白自己所学所做的东西是否是正确的方向，
举个例子，我所在的存储事业部是阿里的重要数据库的开发运维团队。其使用的数据库技术与我在大学接触的数据库技术有何差异？差异很大，但是我在大学学习的东西并非被淘汰，也并非没有用处。阿里的业务规模决定了其数据库的并发抗压能力到了业界的顶尖水平，这一点是在学校以及其他公司所见不到的，在这些技术的发展上确实与以前我所认识的数据库差距很大，包括数据库集群这些东西我都是没有接触过，也没有老师有这方面教学的尝试。对此我只能表示很遗憾。还有就是我学习数据库的时候Nosql这种数据库已经被阿里应用出来了，而我们只是简单的了解了一些。
这些都是学校学习的不足。但是必须得说，学校中学习的数据库原理等课程是必须掌握，极其重要的，是这些技术的基石。所以学校的课程并没有脱离现实，只是我们可能更担忧自己跟不上技术潮流，其实没有必要，基础的知识是必须掌握的。
那么知道了业界的现实，也知道了工作的要求，在以后的学习中就不会在去问：我该学底层技术还是上层应用。当然都要学，都要会。那么应该先学那个？有时间就多学学底层，时间少至少要会应用。
学习新的技术 # 这就是在工作中的需要了，而不是自己的主观能动。 在工作的岗位上一定需要学习新的技术才能完成任务，所以这一点不必多解释。
但是需要说的是，如果仅仅学习了完成工作的那些，就浪费了这个好机会。
什么机会呢？应用场景。
以前的学习，更多是在知识层面，现在的学习是依托于现实需求，有机会在这个应用场景中学习。在用中学往往有更好的效果，所以要更深入一些，更广泛一些。更何况你周围有一群相关技术的专家可以请教。
这里就要讲一下上面提到的，要在一个有交流的队伍中工作。
这个时候就要想一下，实习的共作给你提供了最有价值的的东西是什么？除了以上我们讲到的这些和工资以外，就是你周围的人。
你周围的那些前辈给你简单的聊一聊的东西，都有可能需要别人很长时间才能获得，那些是可遇而不可求的&amp;ndash;经验。这个东西你能获得的越多，你要走的弯路就越少，对于一个在浩瀚技术点迷茫的人来说，可以节省好多时间。学习经验的代价比学习任何知识的代价都高，所以学技术不是最重要的，学经验才是真正要做的事情。
检验自己的能力 # 这个能力当然不是你曾经学到的东西，而是你的适应能力与学习能力。
新的环境，新的模式，新的技术。这些都在检验你的适应与学习能力，这决定了你换下一个工作之前要做的准备。
换工作是一个很正常的事情，各种原因。一但当你需要换工作的时候，你是否有足够的底气去换就决定了你是否能解决面临的困境。一个依靠长期业务经验工作的人，是底气不足的，一个能快速掌握新的工作技巧的人是很容易做到快乐工作的，因为你可以走嘛。当然如果是个人原因不适合工作，去哪也没用。
指导自己未来的路 # 接触了很多人，很多技术，很多经验。你就清楚的知道自己要去工作还是读书，是要去哪里工作去或是哪里读书。在未来的几年应该如何度过。
我的实习经历 # 面试 # 在偶然的机会碰到辅导员，让他给我参考一下简历，刚好他有在阿里工作的同学，就帮我做了内推投递。本以为内推会很轻松就进去，后来才知道，几乎大家都是内推，没什么区别。
面试一共6轮，5轮技术面试+hr面试。很吓人，确实是国内面试流程最长的公司之一了。
第一轮面试开始以后我就意识到自己贸然用阿里的面试来做第一次面试不是什么明智的选择。因为我根本就没有任何准备，包括自我介绍。
自我介绍是每次都要做的，因为每次都是不同的人。
面试的技术问题偏基础知识，操作系统原理，计算机网络，数据结构，数据库，算法，编译原理等。还会问一问你做过的项目等。
面试的过程有什么经验？不存在的，好好学习，多思考。
在hr面试的时候，会考察你的价值观和性格等，决定你是否适合这个团队，当然也会问一下你的未来打算。
入职工作 # 入职那天，有60人左右，10几个学生，2个本科生。还好，我跟他们聊的挺起劲。
加入团队的第一天晚上集体聚餐，团队有17个人左右，反正都是土豪，要么就是在成为土豪的路上。什么3套房产专业房产中介业余工程师的老司机，一套400万房产追尾修车灯6万的道爷。。。
每月团建出去吃饭，桌游这些是大多数公司标配，没啥好说。
工作的内容我也没挑，听安排，反正都是搬砖。但是工作第一天就给了我3个项目和三台服务器让我部署上去，我真的很绝望。
工作前期不是Java就是python，要么就是把一个python项目重写成java的。作为一个只会Java语法不会python语法的我，更绝望了。
到了现在，后端接口也要写，前端页面也要做。心很累。羡慕某为的某谈同学每天可以打打游戏就完成工作还可以领奖金。更羡慕某软的同学每天吃吃零食按时下班回家开黑。</description>
    </item>
    
    <item>
      <title>SpringMVC</title>
      <link>https://Paladnix.github.io/posts/java/springmvc/</link>
      <pubDate>Wed, 02 Aug 2017 10:41:35 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/springmvc/</guid>
      <description>本文是我的学习过程，但是我认为学习过程中并不适合写给别人看。所以本文只是一个临时的笔记，待以后进行深入整合。
SpringMVC与Spring的关系是什么? SpringMVC是依托Spring框架开发的一个Web MVC框架，天生与Spring集成，也就是使用了Spring的依赖注入和切面编程。
上一篇中讲解了Web.xml，这是Java Web的基础，也就是Servlet容器的工作方式，那个也作为本文的基础。
SpringMVC整体可以看成是一个Servlet，事实上它就是一个Servlet。我们配置web.xml来启动这个Servlet，然后这个Servlet来负责处理每个请求。每个处理请求的类都是我们遵照SpringMVC的格式来写的类，由SpringMVC这个框架来调用完成整个请求的处理。
与原本粗放的原生Java Web的开发模式相比，做了一个聚合。原本是每个请求你都写一个Servlet去处理，在web.xml中配置好一个请求与处理类的映射关系，由容器来完成调用。然后SpringMVC是分担了容器的压力，将容器的工作交给他来做，它利用Spring框架的依赖注入的特性，以及bean的工厂模式重新实现后端的实际处理流程。
有好处也有坏处，我也不太清楚这样做的具体目的是什么，可能会有性能上的提升，因为毕竟工厂模式等特性的加入会提升一些性能和开发便利。坏处感觉也挺明显，首当其冲就是学习栈又深了，还不是深了一个单位是好几个单位。加入了新的配置等，开发过程的脑力成本又增加了。
多说也没用，也是要以后逐步深入才能参透其中的奥妙。
maven 配置项目 # 命令行使用mvn构建项目很简单。
mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-webapp -DarchetypeVersion=1.0 -DgroupId=com.demo -DartifactId=demo -Dversion=1.0 生成的目录如下：
. ├── pom.xml └── src └── main ├── resources └── webapp ├── index.jsp └── WEB-INF └── web.xml 配置一下项目所需依赖关系pom.xml:
&amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&amp;#34;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;com.demo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo&amp;lt;/artifactId&amp;gt; &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;name&amp;gt;demo Maven Webapp&amp;lt;/name&amp;gt; &amp;lt;url&amp;gt;http://maven.apache.org&amp;lt;/url&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;jdk.version&amp;gt;1.8&amp;lt;/jdk.version&amp;gt; &amp;lt;spring.version&amp;gt;4.3.9.RELEASE&amp;lt;/spring.version&amp;gt; &amp;lt;jstl.version&amp;gt;1.2&amp;lt;/jstl.version&amp;gt; &amp;lt;servletapi.version&amp;gt;3.1.0&amp;lt;/servletapi.version&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.8.1&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>web.xml</title>
      <link>https://Paladnix.github.io/posts/web/web/</link>
      <pubDate>Tue, 01 Aug 2017 20:59:50 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/web/web/</guid>
      <description>其作用就是配置一个web程序的基本功能。容器在启动一个web项目的时候先读取这个配置文件，在配置文件读取无误后开始按照配置启动剩余的服务。
加载顺序 # &amp;lt;context-param&amp;gt; -&amp;gt; &amp;lt;listener&amp;gt; -&amp;gt; &amp;lt;filter&amp;gt; -&amp;gt; &amp;lt;servlet&amp;gt; 容器会创建一个ServletContext，整个项目都会共用这个上下文。而&amp;lt;context-param&amp;gt;的内容以键值对的形式存在这个上下文中。 然后对读取&amp;lt;listener&amp;gt;，并实例化listener类，并初始化。 listener类中会有contextInitialized(ServletContextEvent args)初始化方法，启动Web应用时，系统调用Listener的该方法，在这个方法中获得：
ServletContext application = ServletContextEvent.getServletContext(); context-param的值 = application.getInitParameter(&amp;#34;context-param的键&amp;#34;); 得到这个context-param的值之后，你就可以做一些操作了。 举例：你可能想在项目启动之前就打开数据库，那么这里就可以在&amp;lt;context-param&amp;gt;中设置数据库的连接方式（驱动、url、user、password），在监听类中初始化数据库的连接。这个监听是自己写的一个类，除了初始化方法，它还有销毁方法，用于关闭应用前释放资源。比如:说数据库连接的关闭，此时，调用contextDestroyed(ServletContextEvent args)，关闭Web应用时，系统调用Listener的该方法。
所以归根结底，这个&amp;lt;context-param&amp;gt;就是用来存一些配置数据的地方。
比如：定义一个管理员email地址用来从程序发送错误，或者与你整个应用程序有关的其他设置。使用自己定义的设置文件需要额外的代码和管理；直接在你的程序中使用硬编码（Hard-coding）参数值会给你之后修改程序带来麻烦，更困难的是，要根据不同的部署使用不同的设置；通过这种办法，可以让其他开发人员更容易找到相关的参数，因为它是一个用于设置这种参数的标准位置。
web-app # 根元素，不用多说
display-name # 应用的名称，这个在tomcat的维护信息中会出现。
session # &amp;lt;session-config&amp;gt; &amp;lt;session-timeout&amp;gt;120&amp;lt;/session-timeout&amp;gt; &amp;lt;/session-config&amp;gt; listener # &amp;lt;!--****************************监听器配置*********************************--&amp;gt; &amp;lt;!-- Spring的log4j监听器 --&amp;gt; &amp;lt;listener&amp;gt; &amp;lt;listener-class&amp;gt;org.springframework.web.util.Log4jConfigListener&amp;lt;/listener-class&amp;gt; &amp;lt;/listener&amp;gt; &amp;lt;listener&amp;gt; &amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-class&amp;gt; &amp;lt;/listener&amp;gt; 监听器用来监听各种事件，比如：application和session事件，所有的监听器按照相同的方式定义，功能取决去它们各自实现的接口，常用的Web事件接口有如下几个：
ServletContextListener：用于监听Web应用的启动和关闭； ServletContextAttributeListener：用于监听ServletContext范围（application）内属性的改变； ServletRequestListener：用于监听用户的请求； ServletRequestAttributeListener：用于监听ServletRequest范围（request）内属性的改变； HttpSessionListener：用于监听用户session的开始和结束； HttpSessionAttributeListener：用于监听HttpSession范围（session）内属性的改变。 listener类是实现了以下两个接口中任何一个接口的简单java类：javax.servlet.ServletContextListener或javax.servlet.http.HttpSessionListener，如果想让你的类监听应用的启动和停止事件，你就得实现ServletContextListener接口；想让你的类去监听Session的创建和失效事件，那你就得实现HttpSessionListener接口。
有两种为应用配置listener的方式：
使用@WebListener修饰Listener实现类即可。 在web.xml文档中使用&amp;lt;listener&amp;gt;进行配置。 在下一节配置spring的加载类的时候会给出例子。
spring相关配置 # 配置spring，必须需要&amp;lt;listener&amp;gt;，&amp;lt;context-param&amp;gt;如果有就去加载配置的路径，没有就默认是/WEB-INF/applicationContext.xml。
&amp;lt;!-- spring config --&amp;gt; &amp;lt;!-- if this node is not exist, --&amp;gt; &amp;lt;context-param&amp;gt; &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;/WEB-INF/spring-configuration/*.</description>
    </item>
    
    <item>
      <title>git实战指南</title>
      <link>https://Paladnix.github.io/posts/git/git/</link>
      <pubDate>Tue, 01 Aug 2017 16:18:03 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/git/git/</guid>
      <description>今天在往公司的gitlab上push项目的时候死活无法push上去，总是显示没有权限。报错信息上显示sshkey的问题，但是我在github上面都是好好的，搞了半天，我都翻出里git的配置文件改了好几遍都没有用，总之就是个垃圾。。。，后来我放弃了git协议，使用http协议手动认证身份就可以了。傻逼的错误信息如下：
sign_and_send_pubkey: signing failed: agent refused operation Permission denied (publickey). fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. 虽然体验不是很好但是用到了很多以前没有机会用的命令，实践出真知，今天就来总结一下实战中的git是怎么玩的。
安装 # $ sudo apt install git 配置config # 在终端直接输入以下命令：
$ git config --global user.name &amp;#34;John Doe&amp;#34; $ git config --global user.email johndoe@example.com 这个一般我们安装好就会配置一下，这个是全局的配置，如果你的项目中没有自己的配置就会使用这个配置。关于git的配置，你可以用如下的命令查看都有那些信息：
$ git config -l 这会列出全局+当前目录下的git仓库的信息。如果你所在的目录不是个git仓库就只列出全局的配置信息。 当你不加-l的选项的时候，就会列出config常用的选项，其中有一些选项可以用来修改配置信息。这个当你需要用的时候自己在终端看一下就可以了。
其中也告诉我们，git的配置可以每个项目都有一个配置，这个配置就在你的仓库.git/文件夹下的config文件中。全局的配置在~/.gitconfig文件中。
ssh key # 在终端生成一个ssh key的命令如下：
$ ssh-keygen -t rsa -C &amp;#34;e-mail@xxx.</description>
    </item>
    
    <item>
      <title>angular</title>
      <link>https://Paladnix.github.io/posts/web/angular/</link>
      <pubDate>Mon, 31 Jul 2017 17:32:01 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/web/angular/</guid>
      <description>Angularjs 和Angular2 的区别，就像雷锋和雷峰塔的区别。 笑尿了。
我是跟着它的官方文档学习的，文档还是比较健全的，也很细致。地址：[Quick Start](npm install -g @angular/cli)
AngularJS 与 Angular2 # 关于二者的区别，可以肯定的是angular2一定更好。
在细节上，先来说一下angular的特别之处。
其诞生于09年，提出了双向绑定等新特性的概念使得它一出现就被追捧。然而由于09年移动端还没有大规模出现，所以其不支持移动应用的使用。并且其数据绑定使用的是扫描的方式，性能瓶颈很难突破，所以被更适应时代的angular2代替是历史的必然。
所以angular2就拥有了这些它的小弟做的不好的特性。 性能快，支持移动应用开发等。其实现的方式也有很大的区别，所以就出现了雷锋和雷锋塔的区别。
直接来学习angular2的使用 # 首先在什么都不懂的时候先来构建一个实例应用打个招呼：
以下的部分需要：node 6.9.x and npm 3.x.x 及以上。这部分可以去看我的node相关的文章。
Step 1. Install the Angular CLI globally.
npm install -g @angular/cli Step 2. Create a new project
ng new my-app Step 3: Serve the application
cd my-app ng serve --open 你可以看到效果，现在我们来看文件目录。
你的应用需要的内容都在src文件夹中。其他的文件都是用来支撑这个应用的框架代码。下面我们看一下src文件夹的结构：
src # File Purpose app/app.component.{ts,html,css,spec.ts} 定义组件。HTML模板，CSS，Unit Test。这是一个root组件 app/app.module.ts 声明应用如何装配 assets/ 静态资源 environments/ 存放你应用在不同环境下的配置文件。例如在开发环境还是在发布环境 index.</description>
    </item>
    
    <item>
      <title>vue</title>
      <link>https://Paladnix.github.io/posts/web/vue/</link>
      <pubDate>Mon, 31 Jul 2017 17:31:56 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/web/vue/</guid>
      <description></description>
    </item>
    
    <item>
      <title>react 初探-一些基础概念</title>
      <link>https://Paladnix.github.io/posts/web/react/</link>
      <pubDate>Mon, 31 Jul 2017 17:31:49 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/web/react/</guid>
      <description>（这一篇写的很杂，因为自己也是没有章法的断断续续的看了react的东西，所以内容没有组织好。勉强有个认知就好了）
前端的技术现在发展的其实相对简单了很多，但是我觉得这才是正常的前端，以前的前端发展的太混乱，光是屏幕适配的问题就要搞出很多的工作量。而且以前的前后端的耦合过大，使得前端想发展也不发展不动，不过设计总是在进步，异步请求的普适催生了新的前后端设计模式，使得前后端完全解耦成为可能，前端的事情在前端搞定，后台的事情在后台封装掉。前端发展到今天主要就是接下来我要学习的几个js的框架，利用js实现动态的数据绑定，以及异步的请求，所有的前端操作都在封装在前端，开发的脑智压力开始下降，所以现在的全栈也并不是太难。
这样前端框架会用的人一般都比较多，因为学习栈比较浅，很多人自学一天就可以了。所以相对的资料也就非常完善，网上的学习教程编写教学例子也很方便，所以在这里我主要就是偏理论一些的认知，其背后的设计实现等。
简介 # React是Facebook出品的一款开源框架，虽说是开源，但是其在标准的BSD协议后添加了一些条款，使得现在很多公司并不敢使用这个框架了，其添加条款中说明，如果使用该开源项目的产品威胁到facebook的商业产品，facebook有权起诉该产品。不过没有并那么可怕，因为貌似想威胁到也不太容易。
React这类框架主要的注意力放在的是用户的交互界面上，最突出的就是内容的动态绑定，内容变化后的高效刷新。并且屏蔽了DOM。
React使用的是JSX语法，是一种将js与html混合编写的语言。
Javascript # 在学习使用这个框架之前，必须对Javascript有所了解，因为这是一个Javascript框架。对于这部分了解的就直接跳过去看JSX的语法部分。
这门语言传说是被人误解最深的语言，确实貌似大家的学习路线都没有关注过这个东西，以为就是前端脚本搞着玩的语言，但是其语言还是有很多优点并且应用的场景正越来越多。
JavaScript 是一种面向对象的动态语言，它的语法来源于 Java 和 C，所以这两种语言的许多语法特性同样适用于 JavaScript。需要注意的一个主要区别是 JavaScript 不支持类，类这一概念在 JavaScript 通过对象原型（object prototype）得到延续。另一个主要区别是 JavaScript 中的函数也是对象，JavaScript 允许函数在包含可执行代码的同时，能像其他对象一样被传递。
类型 # Number（数字） String（字符串） Boolean（布尔） Symbol（符号）（第六版新增） Object（对象） Function（函数） Array（数组） Date（日期） RegExp（正则表达式） Null（空） Undefined（未定义） 等
更多基础的语法不冗余重复了。
Javascript对象 # 如果你知道Json的全称，你就理解了这个东西：JSON(JavaScript Object Notation, JS 对象标记)。一个符合Json协议的字符串可以直接解析为Javascript对象。
对于Object的成员访问可以使用链式访问：
var obj = { name: &amp;#34;Carrot&amp;#34;, &amp;#34;for&amp;#34;: &amp;#34;Max&amp;#34;, details: { color: &amp;#34;orange&amp;#34;, size: 12 } } obj.details.color; // orange obj[&amp;#34;details&amp;#34;][&amp;#34;size&amp;#34;]; // 12 下面的例子创建了一个对象原型，Person，和这个原型的实例，You。</description>
    </item>
    
    <item>
      <title>FFT 快速傅立叶变换</title>
      <link>https://Paladnix.github.io/posts/acm/fft/</link>
      <pubDate>Sat, 29 Jul 2017 13:36:44 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/acm/fft/</guid>
      <description>快速傅立叶变换是离散傅立叶变换的加速版。 傅立叶的一个用途是用来计算多项式乘法。先讲一下多项式乘法。
多项式乘法 # 多项式有两种表示方法：
系数表示法 # $$A = a0 + a1x^1 + a2x^2 + &amp;hellip; + anx^n$$
点值表示法 # A ={ (x1, y1), (x2, y2),...,(x3, y3) } 点值表示法相当与用点值来求得各项的系数，所以要准确表示一个多项式就必须至少与多项式未知数的数量一致才可以。
传统的系数表示法求多项式乘法的方式复杂度是O(n^2)。 如果使用点值来计算多项式乘法，就会有一些可优化的地方。首先两个n次多项式相乘得到的结果多项式有2n项，这个是确定的，也就是说要用点值表示法就要有2n个点。如何用点值表示法求多项式相乘呢？我们取点的时候就取x相同的点值，这样对应的y值相乘的结果就是结果多项式的y。所以我们在取两个多项是的点的时候就要取2n个点，然后得到2n个结果点。然后剩余的任务就是将这个点值表示法转换成系数表示法得到了我们要的多项式。这个由点值转换为系数的方式称之为插值。
但是这样的算法，在第一步的时候就崩溃了，因为求一个点的值就要至少O(n)， 我们要求2n×2个点复杂度就O(n^2)了。然后就需要一些数学手段。
秦九韶算法 # 这个算法的中心思想是通过选取特殊的点来简化计算，什么点是特殊的呢，用复数点。
介绍这个之前需要先复习一下复数。 高中数学的基础还是比大学的更有用。 复数的基本表示方法：z = x + yi。在复平面上的从原点到点(x,y)的向量是其对应的几何解释。 利用直角坐标与极坐标之间关系，复数还有一种三角表示：z = r(cosθ + isinθ)，θ代表极角，r是复数向量的模|z|=sqrt(x^2+y^2)。 另一种表示法是指数表示法，见下图. 然后有一个棣莫弗公式能够将两个复数相乘简化：
设两个复数（用三角形式表示）: z1 = r1(cosθ1 + isinθ1) z2 = r2(cosθ2 + isinθ2) 那么相乘的结果就是： z1*z2 = r1*r2[cos(θ1+θ2) + isin(θ1+θ2)] 这个过程很好证明，三角函数就可以了。 这个公式可以进行推广，数学归纳法，得到： z1*z2*...*zn = r1*r2*.</description>
    </item>
    
    <item>
      <title>CGI 通用网关协议</title>
      <link>https://Paladnix.github.io/posts/web/cgi/</link>
      <pubDate>Sat, 29 Jul 2017 13:35:17 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/web/cgi/</guid>
      <description>这是实现Web服务的最基础程序。目前只是看到了一些比较，但是我还没有时间去Read the fucking source code.
这样的程序算是计算机网络中比较有学习意义的代码。
在此简单的介绍一下先。
tcp通信过后，服务端需要有一个程序做为衔接程序，来将请求进一步转发给逻辑服务程序，并将结果返回给浏览器，做了个信使的角色。</description>
    </item>
    
    <item>
      <title>Servlet</title>
      <link>https://Paladnix.github.io/posts/web/servlet/</link>
      <pubDate>Fri, 28 Jul 2017 11:22:45 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/web/servlet/</guid>
      <description>这里有一些概念非常的恶心，一开始的时候不太好理解是什么。通过一段时间的实践，我逐渐理解，所以直到今天才开始写这一篇。
容器Container # 这个概念从我一开始接触Java就让我很困惑。 首先你需要先去看一下我在后面的一篇关于tomcat的配置文件：server.xml。在那里了解一下配置文件的结构，你可以看懂下面的这张图片。 首先，容器这个东西是针对servlet来说的，也就是我们说的容器都是放置和运行servlet的程序。tomcat是个容器。但是上面的每一级都算是一种容器，只是大小不同。
为什么要有容器 # 其实对于计算机软件体系来说，一切的东西的出现都是因为标准和规定。 所谓容器其实就是一个程序，这个程序按照servlet需要的标准实现了一些接口，使得当你写了一个servlet以后可以成功的放在这个程序中运行，再直白一点就是，你把你的servlet程序交给这个容器，容器可以成功的运行你的程序。
他们之间通过约定一些标志物信息来实现无缝对接。 所以学习这写东西就是在学习了解他们之间约定的事物，以及，为什么这么约定，这样的约定有什么好处和坏处。
容器是一段程序吗？ # 在tomcat中，并没有容器这个东西，所以容器并不是一个东西，就像水果并不是一个具体的苹果一样。容器是一个抽象的概念。
在tomcat中，如上图，有很多的层。这些层就是一个容器结构。他们一起构成了一个完整的容器。
Engine 是一段基础的引擎程序。我认为是整个tomcat的基础，所有的其他容器都在其的调度控制之下。
Host 这是一个逻辑概念，但也有对应的实体。在讲tomcat的配置文件servers.xml 的时候，有提到这个host是什么回事。有了这一层，可以在一个tomcat容器中部署不同的项目，这些项目的域名都是不同的。也就是这个容器可以容纳很多的servlet并且这些servlet可以是几种粒度的。
你可以是完全不同的两个网站，域名都不同，放在一个容器中运行。你也可以是一个网站的不同组件，放在不同的Context内运行。
所以容器是个体系，不是一个东西。 其实按照这个思路，一切皆容器。因为一切的这些都是调度管理，操作系统调度进程，进程调度线程。一切都是接口和约定。所以万物皆容器。
什么是servlet # 这是一个标准，你的程序符合这个标准就是一个servlet程序。 一个类其实就是一个servlet，但是很多个类在一起只要有一个servlet的接口，也是一个servlet。 （在此我们不再讨论tomcat的启动过程，我们更关心一个servlet放入tonmcat容器以后的过程）
来看一下这个图片，这就是servlet主要关联的几个类。 **摘抄：** 从上图可以看出 Servlet 规范就是基于这几个类运转的，与 Servlet 主动关联的是三个类，分别是 ServletConfig、ServletRequest 和 ServletResponse。这三个类都是通过容器传递给 Servlet 的，其中 ServletConfig 是在 Servlet 初始化时就传给 Servlet 了，而后两个是在请求达到时调用 Servlet 时传递过来的。
我们很清楚 ServletRequest 和 ServletResponse 在 Servlet 运行的意义，但是 ServletConfig 和 ServletContext 对 Servlet 有何价值？ 仔细查看 ServletConfig 接口中声明的方法发现，这些方法都是为了获取这个 Servlet 的一些配置属性，而这些配置属性可能在 Servlet 运行时被用到。 而 ServletContext 又是干什么的呢？ Servlet 的运行模式是一个典型的“握手型的交互式”运行模式。所谓“握手型的交互式”就是两个模块为了交换数据通常都会准备一个交易场景，这个场景一直跟随个这个交易过程直到这个交易完成为止。这个交易场景的初始化是根据这次交易对象指定的参数来定制的，这些指定参数通常就会是一个配置类。所以对号入座，交易场景就由 ServletContext 来描述，而定制的参数集合就由 ServletConfig 来描述。而 ServletRequest 和 ServletResponse 就是要交互的具体对象了，它们通常都是作为运输工具来传递交互结果。</description>
    </item>
    
    <item>
      <title>GeoHash</title>
      <link>https://Paladnix.github.io/posts/redis/geohash/</link>
      <pubDate>Fri, 28 Jul 2017 10:57:39 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/redis/geohash/</guid>
      <description>在做Redis页面控制台命令支持的过程中，对于Redis的GEO模块突然很感兴趣，不明白这个数据结构为什么突然就跟Set、Sorted Set一起出现了。然后发现这个数据结构居然是用来存地理位置信息的，很不简单，要看一下到底是什么幺蛾子。
Geo模块专用于存储地理位置信息，突出的有点是可以快速获取某一地理位置附近的相关位置信息。比如你要在某个地方找吃的，搜索附近2km的餐厅，后台使用的就是GeoHash的算法，Redis原生就支持这个数据算法结构，可见其应用场景支持非常丰富，有很大的应用空间。
GeoHash算法 # 其实这个原理是很简单的，对于地理位置信息，一般我们用经纬度来表示，这就将球面转换成了一个二维平面。在二维平面快速的定位一个位置并查找周围位置信息，就是这个算法解决的主要问题。、
传统的我们可能用一种树结构来搞，但是那样的时间效率和空间效率都不高。
GeoHash过程 # Geohash的主要过程就是将经纬度信息Hash成一个字符串。
将经纬度各自Hash成一个二进制串。 将两个串插叠，奇数位插维度串，偶数位插经度串。 将该串用base32进行编码生成字符串。 原理 # 在第一步中主要用二分的方法来Hash生成二进制串。例如对于维度：北纬30，其在北纬第一位设成1，由位于0-45所以第二位为0，这样一直做20次二分，就可以得到一个长度是20的串。 对于精度同样这样做一遍。
然后插叠得到一个长度为40的二进制串，然后用base32方式编码生成一个长度为8的字符串。
将这个字符串存下来就好啦。
Geohash特性 # 由过程可以看出来，这个Hash出来的字符串的特性，就是相同区域的两个点的Hash结果前缀一致。这样当我们要查找某个位置周围2km的餐厅只要匹配到字符串的前5位相同就可以了。
边缘误差 # 这个算法是存在边缘误差的，因为如果两个点相距的很近，但是在二分的过程中分在不同的两块中，这样的Hash结果就相差很大, 如下图中的红点位置与两个绿点位置。
解决这个问题的方式也很直观。
当我们在查找某一点周围的地理位置的时候，将其对应的周围8块区域的点都取出来，然后计算一下距离做个筛选就可以了。 这个区域的点并不会太大。
这些小算法还是很好玩的。</description>
    </item>
    
    <item>
      <title>spring</title>
      <link>https://Paladnix.github.io/posts/java/spring/</link>
      <pubDate>Fri, 28 Jul 2017 10:24:01 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/spring/</guid>
      <description>这篇文章原本是要完整的讲SpringMVC，现在觉得Spring自己要单独讲一下，SringMVC要单独写个瞎搞教程，混在一起不利于理解，而且写的太乱，所以本问只是介绍一些Spring的特性和一些概念。
Spring 是为了解决企业应用程序开发复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。
之前在学习Spring框架的时候主要研究了两个概念，一个是：控制反转(IOC)，还有一个是：面向切面编程(AOP)。今天来整理一下。
Spring 模块 # 学习框架或是其他的库，先概览一下这个东西是由什么组成，然后顺着这个设计思路就可以理解其工作方式。 据说Spring的模块化做的很好，每个模块都可以单独存在。下面这附图很直观的描述了其体系结构。 分两层，共7个模块，其他模块工作在Core模块之上。 每个模块的功能如下:
核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 Spring Context：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。 Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。 Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。 就这一段我copy过来的东西就有很多新鲜的东西。解释一下： 工厂模式和bean 这个东西就很大，简单说，工厂模式是一种设计模式。程序设计，搞到现在终于体会到什么是程序设计了吧。跟工业革命是一个道理，从手工作坊到工厂生产。这种设计模式无非就是要简化你写代码的过程，而这个工厂模式就是用来简化对象创建过程的一个设计模式。 在创建一个复杂对象的时候，往往我们要先建一些辅助对象，然后把辅助对象塞进去才能把对象真正new出来。这就是传统手工生产。 但是工厂模式也不是就那么简单的，这个工厂模式还有一个发展过程</description>
    </item>
    
    <item>
      <title>真正的老司机如何用Linux文本命令</title>
      <link>https://Paladnix.github.io/posts/bash/commands/</link>
      <pubDate>Thu, 27 Jul 2017 17:23:29 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/bash/commands/</guid>
      <description>Tomcat是最烂的软件，没有之一！Over! 因为日志系统冲突的问题，这两天跟Tomcat斗争了好久，最终被其无耻下流卑鄙所折服，自信点，你就是最烂的！于是就诞生了上一篇长文来叙述日志是怎么搞，现在这一篇也是在实战中学习到的。
曾经学这些命令的时候只知道这些命令有很多功能，也很困惑，一个命令搞这么多参数干嘛，有什么用啊，我反正不会用。然后今天就脸红了，是我不会用。 不得不说设计这些命令的前辈真的很厉害，然后发现windows就这么丢弃这些东西真的是自断后路。盖茨肯定意识到电脑以后会是标配，但是他一定没有意识到自己在让计算机变傻。或许他本身就很傻吧，不是很能懂，自己一个号称最优秀的程序员之一的人，在设计计算机的时候就这么把这些东西屏蔽掉，自己真的打算用吗？计算机是越来越多了，但是其真正强大的功能都被windows阉割了，也阉割了真正的优雅，一定程度上，我认为盖茨理解错了计算机处理信息的价值。
我喜欢vim、latex、linux他们都有一个共同的特点，就是连通性非常强，而且操作简单。在工作过程中除了浏览网页，我基本上不会用鼠标，快捷键加命令可以无所不达。
一般我会开两个终端窗口，一屏左右各占一个。开发服务器相关的应用的时候左边终端在本地，右侧终端ssh连进服务器。就单单这一个操作，在windows下就要复杂N倍，要安装软件才能支持ssh协议，还要软件模拟服务器终端，丑的要死不说，各种切换操作都要依靠鼠标&amp;hellip; 而在linux的终端下，每个操作都只是简单的一个命令的事情，可以用命令完整精准的描述你的想法，所想即所得。
下面几个命令，很强大。 ps、less、head、tail、grep、watch&amp;hellip;
ps # 你知道Tomcat自己的bin/shutdown.sh是无法把自己关闭的吗？很抱歉，我特么这么用了一天了。然后ps发现一堆tomcat进程在跑，顿时恐惧袭上心头。关不掉你就别写个shutdown.sh啊，坑死爸爸了。 下次要关tomcat就特么直接kill，就不用那么麻烦了。
ps 命令是一个系统进程的快照。他通过读取/proc文件的方式获取信息。 使用man 命令获取内置说明文档：man ps，就可以看到各个参数的说明。这里会介绍一些参数的用法，但是仅仅是做个记录而已，有价值的东西是后面的实战例子。
在参数中，ps命令支持三种命令格式：
Unix 带短线(dash)：-a 参数 BSD 不带短线(dash)：a 参数 GNU 两个连续短线(two dash)：--a 参数 一般我用Unix格式的参数。 在解释这个命令之前还要解释一个东西就是Linux的进程。 在Linux中，一个进程组(process group)都是独一无二的会话(session)，这个session的ID就是这个session的第一个process的ID。这个进程也叫做the session leader。
-e 获取所有的进程，与-A 一毛一样。 -aux 获取所有的进程的详细信息。包括没有tty的进程和leader进程。 包含一下信息： USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND -C cmdlist 获取对应cmd的进程 -p pidlist 获取对应pid的进程 -u userlist 获取对应user的进程 -f 获取格式化信息 --sort spec 根据spec排序输出，example：ps jax --sort=uid,-ppid,+pid + - 代表增序和降序 example: 按cpu时间排序 ps -aux --sort -pcpu example: 按内存使用排序 ps -aux --sort -pmem example: ps -aux --sort -pcpu,+pmem 多标准排序 k 与sort同等作用 -L pid 获取特定进程的所有线程 -jaxf 以树形显示进程 -eo 控制输出，可用来产看特定字段信息 example: ps -eo pid,user,args 查看谁登录了你的机器 -m 在进程后面输出线程 上面这些只是基础知识，下面在补充一些： 进程状态STAT代码</description>
    </item>
    
    <item>
      <title>Java-Log日志</title>
      <link>https://Paladnix.github.io/posts/java/log/</link>
      <pubDate>Wed, 26 Jul 2017 14:28:29 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/log/</guid>
      <description>日志以我目前使用到的，有两个功能。 第一，在上线调试的时候查看问题所在。 第二，在线上运行的时候，出现故障回看日志查询问题所在。 总之就是查问题出在哪里，因为编译型的程序没有办法直接搞中间输出来确定问题所在，写在文件里是最好的方式了。
Java中有很多日志系统，但是根据经验，一定有一个日志的抽象层来统一各个日志系统。没错，今天就直接来用这个抽象层的日志工具：SLF4J(Simple logging facade for Java)。它允许你在后台使用任意一个日志类库。如果是在编写供内外部都可以使用的API或者通用类库，那么你真不会希望使用你类库的客户端必须使用你选择的日志类库。
如果一个项目已经使用了log4j，而你加载了一个类库，比方说 Apache Active MQ——它依赖于于另外一个日志类库logback，那么你就需要把它也加载进去。但如果Apache Active MQ使用了SLF4J，你可以继续使用你的日志类库而无需忍受加载和维护一个新的日志框架的痛苦。
日志原理 # 一般的日志都是由三个部分组成：logger、appenders、layouts。logger负责捕获记录信息，转给appender去转发到配置的目的地，layouts负责定义日志的格式。
下面就具体的介绍一下Log4j帮助理解。
Log4j # log4j 有很多优点：
Log4j是高度可配置的，并可通过在运行时的外部文件配置。它根据记录的优先级别，并提供机制，以指示记录信息到许多的目的地，诸如：数据库，文件，控制台，UNIX系统日志等。 已经扩展到C/C++、C#、Perl、Python等语言中。 线程安全、速度快 多输出 也有一些缺点，比如不能保证所有日志信息都送到目的地在其出现故障的时候，会减慢程序的速度，不过这是所有日志都面临的问题，貌似也没有什么好的解决办法。
log4j 在使用的时候需要一个配置文件：log4j.properties或log4j.xml。
如果是java project项目，则在项目的根目录下创建log4j.properties而不是在src目录下。 如果是java web项目，则在src目录下创建log4j.properties配置文件，因为这个时候tomcat会去默认的加载这个配置文件，而不需要我们手动的加载log4j的配置文件。 两种配置的基本配置选项都是一样的，log4j.properties的格式是更好理解的，奈何我拿到的是个该死的xml格式的项目。直观看很丑！非常丑！xml在我这的印象分又掉了一半。 还是先介绍各个选项的内容吧，形式不重要。
选项参数 # 上面讲了日志的三个组成部分，其配置也就是针对这三个部分来搞的。 以properties的格式先介绍一下。
#配置根Logger (Loggers) log4j.rootLogger = [ level ] , appenderName1 , appenderName2 , … #配置日志信息输出目的地 (Appenders) log4j.appender.appenderName = fully.qualified.name.of.appender.class log4j.appender.appenderName.option1 = value1 … log4j.appender.appenderName.optionN = valueN #配置日志信息的格式（Layouts） log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class log4j.appender.appenderName.layout.option1 = value1 … log4j.</description>
    </item>
    
    <item>
      <title>java 线程与池</title>
      <link>https://Paladnix.github.io/posts/java/java-4/</link>
      <pubDate>Tue, 25 Jul 2017 15:45:44 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/java-4/</guid>
      <description>线程与池这两个东西在很多语言中都存在，这是一种编程模式。 池的思维是根本。举个例子，如果某个数据库有一个远程交互的API允许你写代码来远程操作，那么你如果不用池，每条命令都重新发起一个连接，然后要数据库认证身份，然后执行命令。这样的效率不高，你会很当然的想到我要把连接保持住，让多个命令的执行只进行一次身份认证。这个时候就引入池的概念。每次从池中取出对应的连接，执行完命令再放回到池里。 同样的思维在ACM比赛中我们常用内存池的方法来避免频繁申请内存。
线程作为一种资源，也需要申请，申请也要开销，所以能将申请次数降低就可以提高效率，所以我们搞个池。 线程是一个进程的执行单元。一个进程中可以有若干线程，每个线程都是独立的执行单元。线程的调度比进程调度要快很多，因为线程调度的资源涉及更小。
那么为什么要多线程？
先来讲一下并行和并发。 并行：“真正的两个机器同时工作”； 并发：“看上去的同时执行的，实际上在同一个cpu上轮转执行的”； 并发的场景非常多，最基本的就是同时过来两个请求需要做，如果你是单线程的程序，就必须等待前一个完全做完再处理后面一个。如果你是多线程程序，就可以从线程池里取一个线程来处理新的请求，可以保证工作效率。这个地方其实有两个东西，一个是用户体验，一个是异步操作。前一个好理解，后一个讲一下我的理解。 现在很多时候我们都要将处理步骤拆成异步的来做，异步处理的实现方式其中就有多线程。同步就是我前一句代码没有做完，后面的代码后面的步骤就阻塞在那里了。如果我们用异步的方式，开一个新的线程来搞某个步骤。例如写日志和返回执行结果，我们就可以起一个线程去写日志，然后主线程直接返回处理结果，这个处理结果对日志是弱依赖的，日志写的如何并不影响我返回结果的操作，不能因为我日志写失败了我就不把结果返回去，有可能磁盘页被其他程序上锁了，一时半会儿都搞不完，这个时候多线程的优势就显现出来了。
感觉到这里讲了很多东西，都可以讲的很细的，但是讲的太细看的人都没兴趣了，我自己也不需要写太多。
如何实现多线程 # 在Java中封装的很好，用起来也很简单。实现多线程有两种方法，一种是继承Thread类，一种是实现Runable 接口。
Thread # class Thread1 extends Thread{ private String name; public Thread1(String name) { this.name=name; } public void run() { for (int i = 0; i &amp;lt; 5; i++) { System.out.println(name + &amp;#34;运行 : &amp;#34; + i); try { sleep((int) Math.random() * 10); } catch (InterruptedException e) { e.printStackTrace(); } } } } public class Main { public static void main(String[] args) { Thread1 mTh1=new Thread1(&amp;#34;A&amp;#34;); Thread1 mTh2=new Thread1(&amp;#34;B&amp;#34;); mTh1.</description>
    </item>
    
    <item>
      <title>Latex写工作日志的实践</title>
      <link>https://Paladnix.github.io/posts/others/diary/</link>
      <pubDate>Tue, 25 Jul 2017 10:26:38 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/others/diary/</guid>
      <description>最近1个月手里同时在日常环境上跑通6个应用，脑内存实在不够用，现实在召唤新的工作模式的诞生。于是有了这篇文章。
一直在寻找一种方法，能满足我记录各种东西的需求又不要太凌乱，还要不时画一下软件结构图等。我需要一种可以一站解决这个问题的解决方案，但是很遗憾，貌似并没有。所以还是决定自己搞最原始的方案，使用latex直接写工作日志吧。
工作日志不同于其他笔记，相对比较机密，也不好写在其他地方。也为以后开发日志打个基础。
Latex的Ubuntu安装 # 除了体积略大以外，并没有什么太大的缺点。latex支持的东西貌似更多，用户也更多。
顺序执行以下命令：
sudo apt install texlive-latex-base sudo apt install latex-cjk-all sudo apt install texlive-latex-extra sudo apt install texlive-xetex 四个包加起来不到2G，其中第二个是中文支持包。我使用的方式是用命令行直接编译，用vim写代码。
在后续的使用过程中，你有可能会遇到有些包没有，这些包都是以xxx.sty 的形式命名的，这个时候这样来安装缺少的包：
sudo apt search xxx # 查找到对应的包名，因为有的时候软件库中的名字可能不一致，有些前缀什么的。 # 从查出来的列表中选择你要的那个包然后安装就可以了 sudo apt install xxx 缺少包的情况会在编译的时候报错报出来。 还有的时候是因为缺少一些字体，在Ubuntu 上安装字体的方式如下：
# 下载你的字体包到本地。 # 你可以将自己的字体都放在一起，例如~/.share/fonts/ 文件夹中，没有这个文件夹就自己建。 # 然后将字体放进来，终端进入这个文件夹后执行下面的命令 sudo mkfontscale sudo mkfontdir sudo fc-cache -fv 提醒你success就安装成功了，重新编译就可以了。
编译Latex # 编译的命令是xelatex filename.tex。编译完成以后可以打开来看效果，我一般直接使用一个makefile文件来完成这一系列操作: 编译、后台打开，清除多余文件 Makefile代码如下：
all: xelatex T.tex evince T.pdf &amp;amp; clean: rm *.</description>
    </item>
    
    <item>
      <title>VIM 花式进阶</title>
      <link>https://Paladnix.github.io/posts/vim/vim/</link>
      <pubDate>Mon, 24 Jul 2017 20:36:46 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/vim/vim/</guid>
      <description>据说Vim在程序员鄙视链的顶端，呵呵，连编辑器都能用来鄙视别人的程序员肯定是个菜鸡。 但是一个Vim修炼之路真的是挺好玩的，一个编辑器居然能这么炫酷的写代码，这么强的扩展能力，和这么顺畅的操作，站上顶端也不是空有其名的，当然用Vim写代码的工程师的代码能力也不是浪得虚名。
IDE有IDE的好处，个人喜欢Vim。
所谓花式，就是没有章法，一点一点积累。
Vim的剪切板-寄存器 # Vim有大概47块剪切板，牛逼坏了。也就是说你可以存N份不同的东西在不同的剪切板中，当要用那个东西的时候直接一键粘出来。这其中有一个误会，就是以前总以为Vim默认不支持系统剪切板，其实系统剪切板是这N块中的一块，只不过不是默认剪切板而已，怎么想都不可能没有系统剪切板的，只是自己不会用。 在Vim中，这些其实并不叫剪切板，而叫寄存器，功能比剪切板大很多。
Vim中有10种寄存器，命令模式下：:help registers 就可以调出帮助文档。至于这10种寄存器具体的区别就不说了，列举一下都有那些寄存器。 寄存器的标志是&amp;quot;开头加寄存器名称。
默认的无名寄存器&amp;quot;&amp;quot;，就是引号所代表的寄存器 &amp;quot;0-&amp;quot;9号寄存器 &amp;quot;a-&amp;quot;z 或&amp;quot;A-Z&amp;quot; 字母寄存器 &amp;quot;+ 寄存器，就是系统剪切板 其中默认的无名寄存器是我们平时剪切dd和复制yy用的剪切板。 如果我们要把一个东西存到某个寄存器，例如将某两行存在1号寄存器中，在普通模式下： 2&amp;quot;1y 这个命令地一个2是要复制的行数，然后是1号寄存器，然后是y复制。 要粘贴1号寄存器中的内容就在普通模式下： &amp;quot;1p 要想将系统剪切板的内容剪切到vim中就把&amp;quot;1换成&amp;quot;+ 就可以了。</description>
    </item>
    
    <item>
      <title>VIM 在ACM/ICPC中的非最佳实践</title>
      <link>https://Paladnix.github.io/posts/acm/acm-vim/</link>
      <pubDate>Sun, 23 Jul 2017 21:05:54 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/acm/acm-vim/</guid>
      <description>5月份在看今年的Final直播，看到了ITMO队的屏幕的时候，看到一些骚操作，感觉自己是拿着冲锋枪当鸟枪使了。
Vim确实十分强大，其强大是有原因的。最主要的原因是他本是依托终端存在的，他与终端有着非常强的联通。终端的强大一定程度上让vim变的很牛逼。不需要插件就可以在内置命令行。
打比赛两年了，现在也算是个退役狗了，才发现自己并没有好好用vim这个神器，不仅仅是装逼。 第一年的时候简单会用vim来写代码，会简单的配置，会用一点点的快捷键。 第二年的时候会用更多的快捷键，并没有什么本质上的突破，除了会用一点bash脚本来加快测试等。
本文将以ACM比赛场景作为线索，介绍一下Vim应该怎么用，以及，你为什么不要用IDE。
比赛开始 # 按照我们队的分工，我在前2分钟负责配置vim环境和代码环境。这里推荐一个简明配置清单：
vim ~/.vimrc set nu &amp;#34; 行号 set mouse=a &amp;#34; 鼠标可用 set shiftwidth=4 &amp;#34; 与tab宽度相关的 set tabstop=4 &amp;#34; tab宽度 set cindent &amp;#34; c语言风格缩进 set autoindent &amp;#34; 自动缩进 set cul &amp;#34; 高亮当前行 colorscheme desert &amp;#34; 配色，选用你平时用的最好 syntax on &amp;#34; 开启语法高亮 &amp;#34; 以下配置自己酌情 set noswapfile &amp;#34; 不产生交换文件，在意外退出没有保存的情况下刚写的代码就没有了。 &amp;#34; 好处就是不会在打开文件的时候提醒你交换文件，下面会讲怎么处理这种请况。 在配置完vim后，我会写一个头文件和主函数的模板，然后命令行给每一题都复制一份。 模板会写：所有会用到的头文件、主函数、输入格式、输出Case、常用的#define、typedef、const等。
用一个四行的脚本来复制：
#!/bin/bash for name in {A..M}; do cp a.cpp $name.cpp done # 我写的模板文件是a.cpp # 脚本名为copy.</description>
    </item>
    
    <item>
      <title>iterator 迭代器</title>
      <link>https://Paladnix.github.io/posts/java/iterator/</link>
      <pubDate>Sun, 23 Jul 2017 19:14:14 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/iterator/</guid>
      <description>迭代器是一种对数据结构数据进行遍历的模式，也成为游标(Cursor)模式。这种模式为了适应各种被封装了的复杂数据结构的完全顺序遍历而设计。其设计思想依旧是封装的思想，屏蔽各种数据结构底层的存储差异，使用统一的方法来遍历所有的数据。
C++ # 先以C++中的迭代器的使用来说一下。举两个常用的容器的例子。
vector # 遍历、删除元素 # vector&amp;lt;int&amp;gt;::iterator it; for( it = A.begin(); it!=A.end(); it++){ cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; endl; if(*it == 3){ A.erase(it); } } /* 上面这种写法是有问题的，当你删掉3这元素的时候，it再++，直接就到了5了，4就跳过去了。 因为erase后，后面的元素都会前移。 从这里我们可以看到，vector中的迭代器应该就是指针。 正确的写法如下： */ vector&amp;lt;int&amp;gt;::iterator it; for( it = A.begin(); it!=A.end(); it++){ cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; endl; if(*it == 3){ vector&amp;lt;int&amp;gt;::iterator it_tmp = it; it--; A.erase(it_tmp); } } set # set&amp;lt;int&amp;gt;::iterator it; for(it = S.begin(); it!=S.end(); it++){ cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; endl; if(*it == 3){ set&amp;lt;int&amp;gt;::iterator it_tmp=it; it--; S.</description>
    </item>
    
    <item>
      <title>chrome 控制台</title>
      <link>https://Paladnix.github.io/posts/web/chrome/</link>
      <pubDate>Sun, 16 Jul 2017 12:56:55 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/web/chrome/</guid>
      <description>chrome是一个非常好用的Web开发的工具，而不仅仅是个好用的浏览器。 按下就可以调出控制台，控制台可以与页面分离成为一个单独的窗口。这个在调试大屏效果的时候很方便，但是我不是搞前端设计的，所以不管这个。
这里可以看到有很多选项，常用的有以下几个：Elements、Console、Sources、Network。
Elements 审查元素 # 这里可以看到你的HTML源码，和对应的css。在前端工程师的工作中经常会用到，不过现在自动化的工具越来越多了，也不一定非用这个了，但是这个一定是很强大的功能。 在这个框的最左上角有一个鼠标箭头的标志，点一下就可以到页面上定位某个元素的代码，很好用。 这一块没有什么技术含量
Console 控制台 # 这是一个命令交互的控制台，语言是Javascript。下面就介绍一下常用的几个命令。
console.log() # 这是一组四个命令分别是：console.log()、console.info()、console.error()、console.warn()。其作用就是在控制台中打印信息，在编写前端工程的时候可以这样在js代码中打印log信息来排查问题。
$.cookieStorage.set(&amp;lsquo;id&amp;rsquo;, 1234) # 这是一个cookie操作函数。可以对应的设置cookie的参数值，如上，如果某个网站的用户登录验证使用cookie来做的，你又猜到了其参数的名字，就直接设置cookie就可以登录上去了，免密码呢。
Sources # 这个在调试的时候可以看到自己的页面的每个资源的加载情况，包括时间、来源、是否加载成功等，也可以把资源down下来。
NetWork # 这个我感觉是最好用的一个，他会记录你的异步请求。可以记录请求的地址，参数，返回值等等。
Anything more?
Nothing more&amp;hellip;</description>
    </item>
    
    <item>
      <title>比赛题解-2017苏大暑假集训个人赛(13)</title>
      <link>https://Paladnix.github.io/posts/acm/acm-contest-1/</link>
      <pubDate>Fri, 14 Jul 2017 12:53:21 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/acm/acm-contest-1/</guid>
      <description>比赛现场传送门。此次比赛共8道题目如下：
A. HDU 5777 签到题 B. Poj 3581 后缀数组 + 细节处理 C. Poj 2228 DP+循环情况处理 D. Poj 2155 二维树状数组/二维线段树(区域修改，单点查询) E. UVA 11853 DFS乱搞 F. HDU 4609 FFT基础题 G. HDU 5676 DFS + 二分 H. Poj 2728 最优比例生成树(0-1分数规划)/二分 题目整体偏难，除签到题外应该都是银牌及以上题目，基本上要掌握到这个程度才算可以。
A. HDU 5777 签到题 # 某一场BestCoder的B题，很简单的思维小题目。
#include&amp;lt;iostream&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;algorithm&amp;gt; using namespace std; typedef long long ll; int n,k; int a[100006]; ll sum=0; bool cmp(int a,int b) { return a&amp;gt;b; } int main() { int T; scanf(&amp;#34;%d&amp;#34;, &amp;amp;T); while(T--) { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n,&amp;amp;k); for(int i=0;i&amp;lt;n-1;i++) scanf(&amp;#34;%d&amp;#34;, &amp;amp;a[i]); sort(a,a+n-1,cmp); sum=n; for(int i=k-1;i&amp;lt;n-1;i++) sum+=a[i]; printf(&amp;#34;%lld\n&amp;#34;,sum); } return 0; } B.</description>
    </item>
    
    <item>
      <title>redis</title>
      <link>https://Paladnix.github.io/posts/redis/redis/</link>
      <pubDate>Fri, 14 Jul 2017 11:42:58 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/redis/redis/</guid>
      <description>redis 是一个高速的高级的键值对存储系统。开源的，高可用，高效。 其将数据完全保存在内存中，磁盘只做持久化。并且支持多种数据结构：list、set、hashtable等，使用方便。 使用的场景主要有:
如排行榜、计数器缓冲、数据统计（如TopN，交集，并集等）、最新项目检索、地理位置存储及range查询 实时统计和过期处理，如用户投票及排序；复杂的数据结构缓存及内存数据库 缓存，消息队列(Redis本地支持发布/订阅)，应用程序中的任何短期数据，例如，web应用程序中的会话，网页命中计数等。 由于其属于内存数据库，所以成本比较大，冈起来比较爽一点。
Install on Ubuntu # sudo apt-get install redis-server Startup # redis-server Work on it # redis-cli # 出现命令提示符即正常工作 支持的数据结构 # 正时因为支持这些数据结构才易用。
字符串 # Redis中的字符串是一个字节序列。Redis中的字符串是二进制安全的，这意味着它们的长度不由任何特殊的终止字符决定。因此，可以在一个字符串中存储高达512兆字节的任何内容。
set name `Paladnix` # 存入key-value get name # 获取key对应的value Hash散列 # Redis散列/哈希(Hashes)是键值对的集合。Redis散列/哈希是字符串字段和字符串值之间的映射。因此，它们用于表示对象。
HMSET key uname &amp;#34;Paladnix&amp;#34; password &amp;#34;123&amp;#34; level 0 # key 对应一个对象 列表List # Redis列表只是字符串列表，按插入顺序排序。可以向Redis列表的头部或尾部添加元素。
lpush alist redis # 插入字符串 lpush alist Paladnix # 插入字符串 lrange alist 0 10 # 获取字符串 集合Set # Redis集合是字符串的无序集合。在Redis中，可以添加，删除和测试成员存在的时间O(1)复杂性。</description>
    </item>
    
    <item>
      <title>Java Exception &amp; Error</title>
      <link>https://Paladnix.github.io/posts/java/java-exception/</link>
      <pubDate>Thu, 13 Jul 2017 17:24:27 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/java-exception/</guid>
      <description>你没有看错，这篇文章的tags中有人生。又一次开始思考人生，总有Bug想害朕。
今天碰到了一个，算是一个BUG，跑出来是个ERROR，抛出了个Exception。讲道理，这些都是正常的，但是很不讲道理，这个错误报的我望而却步，这个异常更是一头雾水。Just A Fuck For You.
当我拿到这个集群巡检程序的时候，我认为应该是很简单的部署上服务器就可以了，因为这是一个已经在线上运行的包，我只要改改参数在日常环境跑起来就可以了。然而，真正的魔术开始了。日常环境与线上环境居然差异很大，包括巡检的目标集群、结果数据库机器等都要改。这个还算好，虽然我不知道，但是有师兄在搞搞还是比较简单的，然后就上线，运行。
第一个问题就是找不到主类。我懵逼，居然连启动都起不起来。好在还有进一步的报错信息，原来是找不到log的包。但是我在本地可以启动，我一直以为打jar包的时候会打依赖进去，结果是并不会打依赖包。这个是学艺不精，经验不足。于是把本地所有依赖包怼进服务器。这次顺利的启动起来了。
然后就开始报错，几乎所有集群都拒绝访问。这尼玛就很尴尬了，我对整个项目一无所知啊。那就去问一下呗： “师兄，这个巡检被拒绝访问了，所有集群都访问不到。” &amp;ndash;“有点忙，你自己先看看。” “我看不懂啊，先给我讲讲这个整体逻辑啊” &amp;ndash;“没空” &amp;hellip;
然后就开始了一下午的生不如死。哼，回家睡觉！不干了！ 第二天来到，我决定再深入看一下代码，应该能从代码中找到问题。作为ACM选手，从来就没有机器DEBUG的习惯，眼爆bug在C++100多行的代码里还是很快的，但是在Java里就有点懵逼了。Java的代码你说长，其实也不长。但就是会让你抓狂，自己看自己写的Java项目那是怎么看怎么喜欢。去看看其他人的Java项目，呵呵。写一个大工程当然就是要功能块分拆，功能隔离，减少代码内耦合，利于修改调整，兼具灵活性与健壮性。所以Java代码的特点就是不断的继承，类间调用，流程拆分……有的时候一个很简单的功能可能要涉及7、8个类和接口，所以看代码，就要有个够大的脑内栈空间。但是，就算难看，也不机器DEBUG，手动DEBUG的基本功还是有的。
但凡报错靠谱点，都没有那么难，痛苦就在于，他报的错误与真正引起错误的地方相差太远，异常却又报的模模糊糊。首先是拒绝连接错误，现在代码里找到所有要访问的集群IP，打出来。然后找师兄去确认，集群是否在用，就这一个工作就前前后后搞了两个多小时，都在忙的不亦乐乎。集群有问题就好办多了，因为这锅就可以甩出去啦，偏偏机器没有问题。既然机器本身没有问题，那就只有代码的问题了。
坑就坑在这次抛出的异常居然没有抛出一场的地点信息。或者说异常信息说明的地点距离异常真正发生的位置也有一段距离。主异常是有连接器客户端抛出的，抛出信息就是链接失败啦。然而依靠其抛出的异常栈只能找到发出链接请求的这个类，再往下就没有栈内信息了。然后就去看调用的函数，结果一进去发现这个类没有抛出异常，而是自己处理掉了。这本应该是非常值得表扬的，因为捕获了异常意味着这个异常是可以被预料并处理的，所以优秀的程序员都会在能处理的情况下都处理掉，如果是一些不好处理的，或需要根据使用者的需求来处理就继续向上抛，抛给函数使用者去处理。很多初级的Java程序员最常见的做法就是捕获这个异常，然后打印出来，交给运维去发现异常再回来改代码。我手里的这个类并没有抛出异常，而是把一场catch下来自己处理掉了。但是他只处理了其中的IO异常，还有一个可抛出异常也被他catch下来了，并且仅仅是打印到了log里，所以我就只能从日志中追踪到这里了。然而由于没有抛出，所以也就没有信息表明这个一场出现在上面的哪个位置，只能手动二分位置查错了。这个的原理很简单，就是发生异常位置以后的代码都不会被执行，所以只要在其中夹杂一些输出语句，就可以定位到出错的那句了。接下来定位到一个新的类中，至于这个类是干什么的我也不清楚，但是可以找bug。而这个函数就完全没有抛出异常也没有捕获异常，所以这个就要对函数里所有代码都做二分定位，而不是像刚才一样只定位try代码块中的代码就可以了。几个过大概5轮定位，又定位到了一个新的类里，通过对新的这个类的定位，可以基本确定异常就来源于这个函数中的某一句。异常信息中有一个是数字格式错误，通过上面的分析，我也基本上确定在这里发生的就是这个格式错误的异常，由于函数参数中只有一个double的参数，就重点找他的问题。先输出了他的值，发现没有问题。然后发现代码中他与另外一个变量做了比较，而定位异常位置也就发生在这个比较代码块中，参与比较的另外一个是从配置文件中提取的数据。经过往回找这个配置文件的参数选项，发现问题竟然是因为拼写错误导致找不到这个配置选项，所以这条语句的值变成了if( double &amp;gt; null ) 然后就有了这个数字格式错误的异常了。
草泥马我的心好累。代码中写的是max_master_clients，然而配置文件中是master_max_clients，真不知道线上的那个代码是怎么跑的，害怕。
异常 Exception # 通过上面的故事，你应该已经了解了Exception的一些特性了。下面具体的介绍一下，以及正确用法！</description>
    </item>
    
    <item>
      <title>tomcat</title>
      <link>https://Paladnix.github.io/posts/web/tomcat/</link>
      <pubDate>Wed, 12 Jul 2017 11:06:56 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/web/tomcat/</guid>
      <description>日志 # Tomcat的日志系统还算很完善的。来看一下，当你的应用出现问题的时候要去哪里找原因吧。
apache-tomcat/logs/ |_ catalina.2017-07-12.log |_ catalina.out |_ host-manager.2017-07-12.log |_ localhost.2017-07-12.log |_ localhost_access_log.2017-07-12.txt |_ manager.2017-07-10.log |_ 对应的App应用的log文件夹，取决与你项目用的日志工具。 catalina.out 这里的数据都是代码输出到标准输出流的重定向，所以你的SOUT都在这里。 localhost.DATE.log 是你的应用抛出的错误，如页面运行错误，servlet错误等，常用查错工具。 其实目前我也就用过以上两种日志，可能用法还是不太对，入门的时候查日志感觉日志乱的要死。其实这个也不影响使用就是很影响心情，找错误一般可以直接搜索字符串定位就好了。但是我自己感觉还是要在项目开发之前就做好日志的规划工作，什么时候要打log什么时候不打，log的格式是怎样的。心情必须照顾！
tomcat 安装到发布应用 # 这一部分非常简单。
安装 # 下载tomcat-core代码包,并解压。 到其bin/目录下，linux执行./startup.sh, windows执行startup.bat脚本。 前提是需要配置JDK到环境变量。 打开http://IP:8080 查看效果。 发布应用 # 将你的应用编译打包成一个war包，然后copy到其webapps文件夹下，通过http://IP:8080/NameOfWar访问。 如何开发Java Web？你需要了解：servlet、SpringMVC、maven、javaBean等。
tomcat 源码梳理 # 打算看一下源码是怎么玩的，也有可能看不下去，坑先挖上&amp;hellip;</description>
    </item>
    
    <item>
      <title>curl</title>
      <link>https://Paladnix.github.io/posts/linux/curl/</link>
      <pubDate>Tue, 11 Jul 2017 17:37:47 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/linux/curl/</guid>
      <description>linux下面自带的一个命令行工具，很常用，关键是很强大。
supports # DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, Telnet and TFTP.
supports SSL certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies, HTTP/2, cookies, user+password authentication (Basic, Plain, Digest, CRAM-MD5, NTLM, Negotiate and Kerberos)
file transfer resume, proxy tunneling and more.
基本上无所不能了。。。 这里是cURL的PDF版本说明文档，不是很难看懂，里面介绍了这个项目的起源发展、网络协议、如何使用等等。作者还有个很帅的名字：丹尼尔·斯坦伯格。
作者写了这样一段话：
Running curl from the command line was natural and Daniel never considered anything else than that it would output data on stdout, to the terminal, by default.</description>
    </item>
    
    <item>
      <title>你所不知道的http协议之优秀</title>
      <link>https://Paladnix.github.io/posts/web/http/</link>
      <pubDate>Mon, 10 Jul 2017 19:02:33 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/web/http/</guid>
      <description>协议 # 协议就是数据格式+确认策略。 你所需要知道的就是协议是如何分类的，一般我们按照其工作的层次来分类，分成：通信层协议、应用层协议、物理层协议等七个层次的协议。整个计算机网络体系是由这么多层次组成，但是发展到今天我们主要关心的其实就是两个层次上的协议：通信层、应用层。TCP/IP协议属于通信层，Http属于应用层，也有人认为http属于通信层。关于http属于什么层次，可以是两个架构之间的区别，一种就是RESTful模式的，也是我们常用的；还有一种就是SOA（面向服务的体系结构)他是将http当作通信层协议来使用的。这个关于什么是RESTful和SOA就可以写一篇，这里你只需要知道现在正在向RESTful模式迁移就可以了。
(成熟的架构大局观+敏锐的技术嗅觉，这是一个CTO必备的能力。)
http协议 # http协议（超文本传输协议）是现代计算机网络最最重要的组成部分。其协议简洁、高效、灵活、强大，也是计算机应用下一步进化的方向。
除了上面讲的几个你体会不到的特点以外，下面几个特点你要清楚：
无连接： 不需要保持连接，一个请求干一件事，干完就过。 无状态： 换句话说就是没有记忆，这一点有利有弊。 内容 # http1.1的RFC文档在此，有兴趣的可以去看看。内容比你想的多得多，比我知道的也多得多。本文就简单的介绍一下http报文结构啊什么的，那些网上到处都是，没必要说太多。
Request # 由于是应用层，所以我们就只关心数据而不关心其他的东西。 报文结构如下：
GET /562f25980001b1b106000338.jpg HTTP/1.1 Host img.mukewang.com User-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36 Accept image/webp,image/*,*/*;q=0.8 Referer http://www.imooc.com/ Accept-Encoding gzip, deflate, sdch Accept-Language zh-CN,zh;q=0.8 xxx 报文由四个部分组成，请求行、请求头、空行、请求数据。
第一行是请求行，包含三个数据，空格分隔：请求方法、请求资源(URL)、协议版本。 下面紧跟的是请求头，是n个键值对，空格分隔，包含其他的数据：请求的目的地、什么浏览器、该请求接受什么返回格式、什么编码&amp;hellip; 空一行 请求数据。 Response # 返回报文一样四部分：状态行、消息报头、空行和响应正文。
HTTP/1.1 200 OK Date: Fri, 22 May 2009 06:07:21 GMT Content-Type: text/html; charset=UTF-8 &amp;lt;html&amp;gt; &amp;lt;head&amp;gt;&amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>关于计算机科学的学习</title>
      <link>https://Paladnix.github.io/posts/self/howtolearn/</link>
      <pubDate>Sun, 09 Jul 2017 15:29:05 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/self/howtolearn/</guid>
      <description>这篇文章的标题写了很久都没有开始动笔去写，因为随着学习的宽度和深度不断的扩大，越来越不敢贸然的去写这么大的题目。
首先这个文章是我自己的经验和思考，要适合个人的情况。
如何学习新事物 # 抓住概念，触类旁通。
上面这个两个词是一个高度的概括。扩展出来分成两个方面，一个是如何抓住概念，一个是什么是触类旁通。
抓住概念 # 在传统的学科中，概念是十分清晰的，尤其是数学、物理学的表述。这样经过总结下来的概念是什么呢？ 就是描述这个事物的特点的严谨表述。 归根结底，现在科学发展的再高，也只是一种归纳，谁也无法确保数学的基础就是无法动摇的，物理学的基础还存在很多不同维度上的争议。所以现在的概念就是一种归纳。
这种归纳将这个事物独有的特征组合进行描述。符合了这个描述的东西我们就可以认为是这个东西。
所以当我们在分析事物的时候，除了我们本能主管可以判断的事物以外，我们就是利用这样的特征比对来进行分类判别。
为什么我们要进行分类判断，给这个东西一个定义呢？
为了应用前人的理论研究。举个例子，你知道一个直角三角形的两条直角边的长度，你想知道第三条边的长度，如果你不上升到理论的层次上去，你就只能去量。但是一旦你将这三个点上升到了直角三角形的理论分类中，接下来的思考就是理论上继续延伸出去，可以用三角函数、勾股定理等，在没有上升到理论层面的时候是直观的问题，上升到了理论上就是抽象的问题。
所谓科学与经验的区别，我认为某种程度上是直观与抽象的区别。
上面说的实际上是抓住概念的重要性。那么如何抓住概念。
很简单就是去找概念，总有别人定下的概念。 但是！计算机科学有其特殊之处，而且非常的独特的地方，就是，这个领域的很多概念是个体的思维抽象，其他的理论基础非常少。会出现什么问题呢，就是同样的事情，第一个发明出这个概念的人有很清晰的概念。当别人看到了这个东西或是理论以后，他会有自己的理解。这个理解就让人很头疼。有的时候，有些人的理解很形象，相比于最初的概念来说，很容易被人们普遍直观理解。但是，如果这个时候这个人对于原概念或是事物本身并没有理解的非常深刻，没有完全抓住这个事物的特点，那就会产生信息的缺失。
概念中的信息缺失是十分可怕的。
就比如你学习牛顿第一定律：一切物体再不受外力作用时,总保持匀速直线运动状态或静止状态。这是原生的概念，如果我说在一个光滑的平面上，放一个小球，不推他，他就静止在那里，推他一下他就一直保持匀速往前滚。这就是牛顿第一定律。
上面的这个表述对于一个初中生来说，确实很好理解啊。但是这个表示事实上出现了信息缺失，我说的是光滑的平面上，这并不是牛顿第一定律的特征，或者说只是符合条件的一个特殊情况。相比较原版的不受任何外力，对于这个定律的理解就会产生非常大的偏差，你可能会以为只有在平滑的平面上才是这样。
就是这样，很多时候我们想去快速的了解一个东西或概念是什么意思，于是就去问别人，或是看别人的转述，别人的理解。但是很多情况下，写下这些东西的人本身可能理解了，但是在表述上又讲不完全，导致你的理解会有问题。
所以你要去抓住概念本身，总结概念本身表述出来的特征，才能让你真正准确的理解这个问题。真正的概念和定理都是非常的简短且优美的，形式上的简单，思维上的复杂，所以需要花时间好好领悟出来。
在以前学习计算机相关的知识的时候，我会经常去看别人的博客，也能学到很多东西，但是有些时候就无法掌握一个技术点的精髓，尤其是一些算法的精髓。好在在学习算法并实现算法的过程中自己根据实践的经验也能够弥补这些不解，在实践中总结规律和特征。
在别人的博客中，学习的其实是经验，而概念，要找到源头去理解，好在那些发明了这些概念的人都还大部分建在。
触类旁通 # 任何事物和理论都不是孤立的。 计算机的很多理论都是相通的，一切的发展也都是有原因的。
当你知道了计算机的基本物理结构以后，你就应该能够想到一个程序的运行方式。计算机由运算器、控制器、存储器、输入、输出设备组成。那么代码一定是在运算器中运算，数据一定存在存储器中，程序如果要用数据一定也要从存储器中取到运算器中，从存储器到运算器之间的数据传输一定是需要时间的。所以你就知道为什么计算机要有内存和硬盘，因为要加速这个数据传输的过程。。。。
计算机的很多硬件的设计，其根源就在计算机的基本结构中。这也算是要抓住概念，抓住计算机的物理结构。 同样的很多程序在做优化的时候要优化那些东西，也都是源于硬件的差异，什么部件速度慢，什么部件速度快。
基本上从计算机的基本结构中我们可以触类旁通的拎出一串很长的技术线。
这是硬件层，我们的注意点再换个层面，从程序语言这个角度来思考。
低级的程序语言就是要操纵硬件和逻辑门，用什么来操作呢，用电压。高级的语言能不能被计算机理解，很明显不能，那为什么要有高级语言，因为要方便人的编写。那么高级语言势必要被某个东西转换成底层语言，这就是编译器的工作。怎么能让高级语言变成低级语言，这就要求高级语言一定不能太复杂，要有准确的规则，使得每句高级语言都能准确的翻译成一句底层语言而不能有二意性。
很多高级语言会有很多高级特性，比如什么动态绑定啦、继承、多态，你去想一下这些是否具有二异性，很明显没有。所以才能实现这样的高级特性。但是在我们直观来看多态本身就是要做到根据运行时的情况的不同去执行不同的代码呀，代码一经编译就是死的了，怎么实现的呢？肯定是在编译的时候加了一些控制代码，程序不可能活的。，肯定是死的。这个代码就是编译器去加的了。所以不同的语言有不同的特性，因为他们用不同的编译器嘛。
在此基础上在去理解什么设计模式，开发框架，就会简单很多。
计算机还有一个重要的分支，就是计算机网络。
从底层来说就是电信号或者是光信号转换成数字信号。所以每个设备都要具备一个转换器，有了转换器，我们就可以不去探讨物理上的问题了。回到计算机的问题。网络如何来认识目的地，肯定不能是单拉线，那么共用一个网络就要确认一下是不是到了目的地，就有了IP地址、Mac地址、路由、转发、协议等等。到了目的地怎么知道是发给哪个程序的呢？于是就有了端口，端口要实体的口嘛？当然不需要，因为你的电脑上没有那么多口嘛。
。。。
当你遇到一个上层的问题的时候，把这个问题往底层推，找到它的技术依赖点，然后你就可以懂了。
如果你看其他人的博客或是什么，他们一般会基于自己的知识，没有必要往下推问题才能理解，以为其本身很熟悉这个层次的问题，只是在这个层次去讨论，所以也不适合你去学习。
我觉得博客一定是要同一层次或者是略高一点层次的东西才有价值，过高的层次没有好的效果。
计算机科学本身 # 计算机是一门实践的科学。
在计算机中，一些工程上的设计思想其实非常简单。很多人只要逻辑思维清晰就很容易理解。这也是计算机行业的某些方面门槛很低的原因，也是很多培训机构看到的商机。
但是计算机的很多科学理论也是非常难理解的，计算机是数学、物理学、离散数学的应用。其伟大的基础并不是那么简单的逻辑就能理解的，就比如设计一门语言，并不是我们想想这样设计就能保证正确了。我们的逻辑思维虽然很智能，但是不完备，我们无法用逻辑去思考到所有的情况，为了避免逻辑上的遗漏，语言这样的设计工作都要上升到理论层面，从闭包的理论上去证明语言的正确性，也就是保证编译出来的底层语言是准确的，无二意的。举C语言的例子，语法就那么一点点，但是却几乎构建了整个计算机世界。无数人写出的千变万化的C语言代码中，没有一句话会有问题，这不是几个设计者用脑子去想出来怎么设计的，而是用理论去证明出来的。
计算机的理论可以很坚深，但是其应用也可以很简单。无论是哪一部分，都可以作出优秀的作品出来。
同时我认为计算机业界的规范还非常混乱，这样很难将经验抽象成理论，没有理论化的基础，这个科学的发展很快就会到瓶颈，因为人脑的能力有限，靠人去搞清楚这些并在记住这些东西的基础上再去发明新的东西是很浪费的。
学习计算机，关键还是要热爱，如果学着不快乐，活着有什么意义。</description>
    </item>
    
    <item>
      <title>SQL进阶</title>
      <link>https://Paladnix.github.io/posts/others/sql/</link>
      <pubDate>Sun, 09 Jul 2017 15:26:31 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/others/sql/</guid>
      <description>本文不介绍最简单的增删改查，而是对于SQL的进阶语句的介绍，顺便研究一下其内部实现。
Join # 由浅入深，从使用到优化。
概述 # Join一般会有人称为级联查询，我表示这个名称还算直观。其应用场景有那么几种：
某个表中的某些字段需要另一个表来做精细描述。比如职工表中职工等级需要等级表来进一步详细描述该等级的权限、福利等。当我们需要某个人的信息的时候一定是从职工表拉取记录并且需要再从等级表中拉取具体信息合并呈现。 某个人的全方位信息存放在不同的表中，要想得到完整信息就要多表查询合并结果。 上面两种场景都是涉及了两个及以上的表，这就是join的使用场景特点。
SQL语句 # select col_a, col_b, ... from tb_1 join tb_2 on tb_1.col_a = tb_2.col_a where ... ; 其最主要的特点就是from的来源发生了变化，所以我们可以理解为这个sql语句生成了一个新的表，并从这个新表中获取了符合where条件的记录。所以这个join我们看作是对表的一种运算，运算的结果是一张新的表。 这个join运算有一个on的条件，也就是在这个on的基础上进行运算。
Join 运算一共有四种：
inner join （内连接） outer join （外连接） left outer join （左外连接） right outer join （右外连接） 在讲这四种运算之前先要有一个笛卡尔积的概念。 笛卡尔积来源于离散数学中的集合操作，对于两个集合做笛卡尔积就是将两个集合中元素两两组合，生成一个新的集合，新集合中的每一项都是一个二元组(可以理解为一个数据包， 并且这个数据包是有序的，总是某一个集合的元素在前，另一个在后)。所以，如果两个集合的size分别是n,m， 那么笛卡尔积生成的集合size=n*m; 对于表做笛卡尔积，同理就是将两个表的记录两两组合生成一个巨大的新表，每条记录都是由两个表的记录拼接而成。 该概念仅用于理解运算结果的组成，并不是其实现方式。以下的操作可以理解为是在此基础上进行条件筛选，但事实上SQL使用的是循环的方式去查找结果。
inner join # 其结果为：笛卡尔积中，符合on 条件的记录。
outer join # 对于一条A表的记录，如果没有找到符合on条件的对应的B表记录，那么A表的此记录依然出现在结果集中，其对应的B表部分为NULL。 The same to B.
left outer join # 根据outer join 的意思，可想而知，对于A找不到B的情况，保留A的记录，而对于B则滤掉相应记录。</description>
    </item>
    
    <item>
      <title>JDBC</title>
      <link>https://Paladnix.github.io/posts/java/jdbc/</link>
      <pubDate>Sun, 09 Jul 2017 15:25:31 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/jdbc/</guid>
      <description>JDBC(Java DataBase Connectivity) 这是JDK中集成的一个数据库API，可以访问任何类型表列数据，特别是存储在关系数据库中的数据。 本文以mysql为例。
所谓数据库交互，无非就是那么几个部分：建立连接，执行SQL，取回数据。JDBC的设计思路被Php借鉴过去后就产生了PDO，跟JDBC一曲同工，加之轻量级，然后就感觉很好的样子&amp;hellip; 与数据库交互体现在程序上，也无非就是那么几个部分：引入包，实例化对象，调用函数。
那么学习JDBC学他的什么？学会了怎么用然后呢？可以学习其设计思路，有的时候，从设计思路来学习怎么用会比直接学怎么用要容易，Let me show you.
架构 # 现在把自己当成设计者，从设计的角度出发来看JDBC。 你要做的事情是将市面上诸多数据库整合到一起，给Java程序提供一个格式统一的工具。用更学术的语言来表达就是将底层差异屏蔽掉，抽象出一个数据库抽象层，使得数据库对于Java程序透明（学术其实也是将事物统一整理成一个较高的层次，忽略底层实现差异，用思想指导实践。例如当你碰到一个新的问题，整体十分复杂，你不可能直接就想到一个实践方法将其实现，这个时候就需要知识来抽象这个问题，当问题抽象到了某个知识领域内，这个问题就可以再从抽象顺着这个知识往下拆解，最后落实到具体实践跟抽象知识已经没什么关系了）。
要实现统一接口，我们借鉴操作系统与硬件之间的做法，就是每个数据库按照我给的一个标准来写你自己的驱动程序，这个标准就是初步将数据库之间的差异屏蔽，例如我规定所有的select语句由什么函数执行，返回什么格式的数据等。这就是底层的Driver。
再往上，我们需要一个统一的入口。在Java中，不同数据库实现的Driver肯定是不同的类，这样的话难道我们要用什么数据库就用什么类吗？当然能透明就透明，最好是我在参数中体现我要用什么数据库，灵活性更大。所以这个时候我们在几个类上面在做一个抽象，抽出来一个Manager，这个Manage负责数据库的选择，动态实例化，连接等等乱七八糟的事情，然后这个manage在整理封装成JDBC API提供给Java程序使用。
Over.
但是你知道了怎么设计，还是没有卵用，哈哈哈呵呵！上面已经说过了，当你具体实践的时候已经跟上层知识没有什么关系了，但是你会很快理解具体该怎么做。
实例 # jdbc简单的使用差不多在下面的代码中都有体现，另外我对于这个资源关闭的问题还有点迷惑，因为在jdbc的代码中实现了一个Autocloseable的接口，对于当前版本的JDBC要不要显示关闭资源的问题，有可能是不需要的。有待深入了解这个AutoCloseAble接口。
//STEP 1. Import required packages import java.sql.*; public class FirstExample { // JDBC driver name and database URL static final String JDBC_DRIVER = &amp;#34;com.mysql.jdbc.Driver&amp;#34;; static final String DB_URL = &amp;#34;jdbc:mysql://localhost/emp&amp;#34;; // URL 格式(mysql)： jdbc:mysql://host:port/databaseName // Database credentials static final String USER = &amp;#34;root&amp;#34;; static final String PASS = &amp;#34;123456&amp;#34;; public static void main(String[] args) { Connection conn = null; PreparedStatement stmt = null; try{ //STEP 2: Register JDBC driver // JDBC要求要显式注册你要用的驱动类 // 这个代码就是让JVM加载对应的类，并执行其中的静态代码。 Class.</description>
    </item>
    
    <item>
      <title>rest_framework</title>
      <link>https://Paladnix.github.io/posts/web/rest-framework/</link>
      <pubDate>Sun, 09 Jul 2017 15:23:34 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/web/rest-framework/</guid>
      <description>这是一款Django下的API开发框架，对于业务逻辑较简单的API来说非常方便，开发速度非常快。
此坑待填&amp;hellip;</description>
    </item>
    
    <item>
      <title>百技</title>
      <link>https://Paladnix.github.io/posts/self/baiji/</link>
      <pubDate>Fri, 07 Jul 2017 23:20:15 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/self/baiji/</guid>
      <description>百技给我的另一个很大的冲击就是，让我再一次思考自己的人生在追求什么。这可能是要思考一生的问题，但问题的答案在你开始思考的那一秒，潜意识里就已经有了。 我的答案依旧是坦然的面对自己，不为可笑的虚名浪费时间。
为什么会再一次思考这个问题。其实这个问题在过去的一段时间里一直在思考，因为要做选择了嘛。选择当然就是在现实与自己之间做个平衡。参加培训的我所在的组有10个人，其中9个是研究生，我有点紧张，然后我粗略看一下现场120多人的样貌，我判断的本科生应该不超过10个。这个数据我是没有预料到的，很震惊，同时更加慌张。我想到的第一个问题是：我不会成为下一个《伤仲永》吧。不过很快我就不这么想了，因为我特么根本就不是什么天赋异禀，怎么能跟仲永做比较。然后我就更慌了，没有仲永的本事还在这玩，不太妙啊。然后通过跟大家的几天相处，我终于近距离了解了一下研究生是个什么样子的一群人？然后我又意识到，这群研究生都是很厉害的研究生啊，害怕。
学术圈的事情，本科生普遍就算了，算是全民普及教育的一部分了，研究生也搞成这样，很大程度稀释了国内学术水平，都是交易，学术民工。(或许这个时候我没有想到后来我也会去读研究生，做起了学术民工)
为什么会问这样的问题。什么样的问题呢，就是这种问题。。。如何才能平衡工作跟生活？如何成为厉害的人？有没有什么好的方法XXXXX。。。问出这样的问题的人如果自己在0.001秒内没有给自己答案的都可以回家了。如果自己0.001秒就可以的出答案的还问出来，也可以回家了。
研究生问出这样的问题，我觉得是很不应该的，所以我加了学术上。这就想讲到我对研究生这个学历的看法，不是对研究生们哦。首先一点要说的就是研究生什么年龄都是可以去读的，这在制度上是正确的，给赞。其次我认为其知识水平与思想素质水平不对等是不应该的。换句话说，一个人如果能够参透高深的知识内容，其必定也参透了一些哲学思想，或是自然之道，中国话讲大道至简。如果其强行掌握知识，也未必能在此基础上生发新生命。这貌似是国内学术圈的现状。
所以有的时候，一纸虚荣未必值得我浪费青春去求证，我也未必需要世界对我的一纸认证。但倘若我真的去了，我会践行一个学者应有的付出。 归根结底，当我面对自己的时候，不要后悔。
后记： # 2022年6月，重新来读这一篇感想。已经读完研究生，并重新入职原部门，工作8个月。
在疫情中度过了研究生生活，由于研究的方向是NLP，遇到大规模预训练模型的诞生和发展，研究工作推进的还算顺利，但是没有什么实质的成果。</description>
    </item>
    
    <item>
      <title>Django</title>
      <link>https://Paladnix.github.io/posts/web/django/</link>
      <pubDate>Thu, 06 Jul 2017 12:56:56 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/web/django/</guid>
      <description>(注：本文写在N天之中，随着对其的深入学习，很多的看法会发生变化。我也尽量把东西放在这一篇中解决掉，文章思路会有些跳跃，可能先上了细节后面再归档等等。另外，本文会屏蔽一些技术细节，用一些术语来表达，这些术语均是较容易学习的知识块。)
这段时间神奇的技术走位，Java与Python的爱恨交织。
所以既然写到了肯定就是用到了呗，拿到了一个Django的项目，改写成Java的，玩的就是这么欢脱，做为一个写C++出身的入门级Java工程师生活已经如此艰难，然后发现现实是还要兼职Python工程师。
Django也算是工程师玩的玩意儿？封装成了这个样子还有什么好玩的，估计随随便便学2个小时语法加一点Django的框架设计就可以玩起来的，我只能说写这项目的哥们太会偷懒了，服气，骗完钱就离职，更是任性的不行。
言归正传！框架这种东西嘛，就是为了简化开发，提高速度效率，降低合作成本用的，所以django的设计也算是符合了这个目的。但是他并不是简单的照搬了JavaWeb框架的MVC设计思路，而是他妈的又提出了一个神奇的MTC，不用想也知道，就在人家的基础上变来变去还自以为参透了宇宙的奥秘。所谓的MTV就是把几个分工重新分了一下，对，就是要跟人家不一样，日你哥！
不过话回来，就算是对于MVC这个业界都普遍遵循的设计模式，也有很多不同的理解，比如业务逻辑到底该Controller来做还是Model来做，甚至还有人要把这个交给view来做的。之前貌似还看到了个文章讲什么官方设定，话说都发展到这个地步了谁还管你官方设定。不过呢，这都是个设计思路，不同的程序员当然有自己的理解，自己写项目的时候怎么搞都行，但是现在这框架数量真的有点爆炸了，所以大家还是在设计的时候多用点心吧，实现框架的技术不难，但是设计是艺术。
所谓的MTV分别就是： Model、Templete、View。熟悉就对了，你肯定一眼就看懂了，我也是一瞬间就明白了。但是很抱歉，仔细想一下这个Templete如果是前端模板的话，view是啥？如果view用来组装前端模板的话，要model来做业务逻辑吗？那controller岂不是没有了？……就是这么神奇，人家把业务逻辑交给了view来做，我特么也是佩服的吐血。Model就纯纯的数据库操作，就像是一个sql的python版。至于Templete，我已经没有耐心再跟他浪费时间了，老子一个写接口的要什么前端！
对于理解一个框架来说什么最重要？我在很久以前初学框架的时候一脸懵比。我草，这么多代码我得看到什么年？怎么连个主函数都没有，日了狗。。。好在我当时看了一会php，这个比较简单，不用编译一下就能懂，后来我从别人的文章中看到了学习框架的几个步骤等，才知道，看懂路由，就懂了这个框架的一半。
路由 # 提到这个路由，Python这个框架还是让我吃了一惊的。因为这玩意儿不需要容器，厉害啊。写过其他Web的都知道，我们的Web程序是要在一个Web服务程序的组织下做应答的。但是Django抛弃了这个服务程序，严格来说是Python的Web Server抛弃了其他的服务程序，自己写了一个简单的网关程序&amp;ndash;wsgi。其实作用就是做个协议转换，链接机器与python程序，替代了apache2的一些基础功能。不过据说性能欠佳，做做测试还行，上线还是要靠Nginx的帮助，搞个uwsgi。
底层的东西，可以不懂，但是懂一定没有坏处，但是我还没时间搞懂。下面讲一下上层路由。
一个Django的项目特点就是目录比较清晰，比如这个urls.py就是存放路由信息的文件。django在自动化这个地方并没有做太多东西，对于路由信息要显示的写在这里。for一个zample.
from django.conf.urls import url, include from django.contrib import admin import views urlpatterns = [ url(r&amp;#39;^admin/&amp;#39;, admin.site.urls), url(r&amp;#39;^docs/&amp;#39;, include(&amp;#39;rest_framework_docs.urls&amp;#39;)), url(r&amp;#39;^er/&amp;#39;, views.ERView), # ui view url(r&amp;#39;^ui/Node&amp;#39;, ui_views.node_view), url(r&amp;#39;^ui/Cluster&amp;#39;, ui_views.cluster_view), url(r&amp;#39;^ui/InstanceGroup&amp;#39;, ui_views.instance_group_view), url(r&amp;#39;^ui/Chart&amp;#39;, ui_views.chart_view), url(r&amp;#39;^ui.*&amp;#39;, ui_views.home_view), # API url(r&amp;#39;^v1/&amp;#39;, include(&amp;#39;rest_api.urls&amp;#39;)), url(r&amp;#39;^v2/&amp;#39;, include(&amp;#39;rest_api.urls_v2&amp;#39;)), #url(r&amp;#39;^report/&amp;#39;, include(&amp;#39;report.urls&amp;#39;)), url(r&amp;#39;^.*&amp;#39;, include(&amp;#39;rest_framework_docs.urls&amp;#39;)), ] 路由中可以预留参数位置，可以写正则表达式，论灵活性也还行。看到有些东西后买你跟的不是一个类，而是一个import语句，这是将路由转移到这个新的应用中去了，所以要去这个应用下再找对应的文件去继续路由，直到找到某个类为止。上面这个程序中其实是用到了一个叫rest_framwork的东西，这个玩意貌似是用来写网页文档用的东西，不过这个不是重点。
既然找到了这个类，那么有个经典的问题又来了。去调用那个函数啊？这就涉及到了django路由的两种方式，一种是定义到函数，另一种是调用到类。一把小项目就自己定义到函数就好了。但是当项目比较大的时候就需要将路由定义到类的身上，注意这里我们说的都是在views.py 中的类。
对于基类View，其暴露了一个as_view()的函数，该函数会对请求进一步做分发。下面两个就是这种方式路由的。
url(r&amp;#39;^Unit/(?P&amp;lt;pk&amp;gt;\w+)&amp;#39;, UnitDetailView.as_view(), name=&amp;#39;UnitDetail&amp;#39;), url(r&amp;#39;^Unit&amp;#39;, UnitView.as_view(), name=&amp;#39;Unit&amp;#39;), as_view() 是如何做分发的呢？它会调用一个dispatch函数对请求方式做个路由出去再调用到你真正的处理函数。总是很麻烦，还没来得及看代码。 不过这里有一个简化的另外一个类，继承的时候继承Generic.</description>
    </item>
    
    <item>
      <title>Java-反射</title>
      <link>https://Paladnix.github.io/posts/java/java-3/</link>
      <pubDate>Tue, 04 Jul 2017 20:41:16 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/java-3/</guid>
      <description>Java某些特性决定了他今天的地位，反射就是其中之一。
反射是一种在运行过程中使用的，对于任意一个对象都可以获得他所属的类，进而都能够获取他的任意的方法和属性。我对反射的理解就是可以实现动态调用。 最常见的应用场景就是在Java的Web框架中，就是根据一些路由信息来定位到某个类的某个函数，定位到这个函数后就要启动这个函数。不可能写N多个if-else来匹配是否是当前类，是否是这个函数，我们希望的就是我传个参数，然后就能动态调用这个函数。至于类的实例化，函数的调用，交给JVM来做，这就是反射的意义。也是一种语言特性，很多解释型语言都具备这一特性，例如php等，其实java究其本质也算是一个解释型语言，只是有一个预编译的过程，编译出来的字节码也还是要用java虚拟机来解释执行。
实例化对象并调用对应函数 # 使用反射可以根据类名称来实例化对象，调用函数，传递参数。 这一部分涉及到的内容还是很多的，比如可变长参数，反射的机制，函数的重载问题等。
首先要获取我们要调用的函数，所以第一步先Class.forName()。这个函数是让JVM去加载这个类，然后获取其对应的函数getMethod()。在获取函数的时候会涉及重载的问题，多个函数名称一样的函数会被随机获取，我们可以通过制定参数类型的方式来确定我们要获取的函数具体是哪一个，下面的例子中就有这个问题的体现。后面还会有一个函数的重载的问题，有待求证。
获得了函数，接下来就可以做调用了， invoke函数参数列表也是可变的，第一个参数是执行函数的实例，如果是静态函数第一个参数就是null。这里我是先new了一个实例，然后传进去的，一般也可以在第一个参数的位置上写class1.newInstance()，然后就是参数列表了，按照与原函数参数顺序一致的顺序填进去就可以了。我在例子中用的是另外一种方式，也是由于目标函数的参数列表并不是普通的参数导致的，这也是一个坑点。
如果你要调用的函数有一个可变长的参数，你就得绕个弯。一般我们调用可变长参数的函数的时候就是传一个数组进去就可以了，但是这里并不可以，如果参数位置是一个数组的话就会报IllegalArgumentException: wrong number of arguments。然后就发现这个invoke本身就是一个参数可变长的函数，所以当我们把参数传进去之后被JVM拆成了单项，这样再往我们要调用的函数里传的时候就会参数数量不一致。这个是由于JVM会做拆分导致的，为了避免这个问题就把参数搞成JVM不会拆分的数据结构，这样做个整体传进去就可以了。下面的代码里就是使用Object来解决这个问题，可能也有其他的方式。
package com.paladnix /** * Created by paladnix on 17-7-17. */ public class TestReflect { public static void main(String[] args) throws Exception { String className = &amp;#34;com.paladnix.TestReflect&amp;#34;; String methodName = &amp;#34;exec&amp;#34;; Class&amp;lt;?&amp;gt; class1 = Class.forName(className); TestReflect testInstance = new TestReflect(); Method method = class1.getMethod(methodName, String.class); // 调用exec(String args) // Method method = class1.getMethod(methodName, String[].class); // 调用exec(String... args) String[] params = new String[3]; params[0] = &amp;#34;123&amp;#34;; params[1] = &amp;#34;234&amp;#34;; params[2] = &amp;#34;345&amp;#34;; Object[] p = new Object[]{params}; System.</description>
    </item>
    
    <item>
      <title>Java 基础数据结构</title>
      <link>https://Paladnix.github.io/posts/java/java-2/</link>
      <pubDate>Mon, 03 Jul 2017 22:00:27 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/java-2/</guid>
      <description>最近在高频率的开新坑，所以博客也就高频率的开新东西，但是由于精力有限而且需求不是很大，所以在很多问题上暂时是不求深解的。浅尝辄止，还要去快攻下一个堡垒。但是以后都是要补回来的。。
但是这个应该不是浅尝，因为会经常用到。
String # 其构造方法比较特殊，可以直接等于赋值，也可以用严格的Java面向对象的写法。
构造 # String s = &amp;#34;abc&amp;#34;; s = &amp;#34;abc&amp;#34; String s = new String(&amp;#34;abc&amp;#34;); char[] data = {&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;c&amp;#39;}; String s = new String(data); String str = s.subString(1,2); //start from 1, length=2 方法 # charAt(int ); length(); replace(char old, char new); // 常见的对象转换成字符串与转换回去的问题。 // 待补充 String对象是不可改变的。每次使用 System.String类中的方法之一时，都要在内存中创建一个新的字符串对象，这就需要为该新对象分配新的空间。在需要对字符串执行重复修改的情况下，与创建新的 String对象相关的系统开销可能会非常昂贵。如果要修改字符串而不创建新的对象，则可以使用System.Text.StringBuilder类。例如，当在一个循环中将许多字符串连接在一起时，使用 StringBuilder类可以提升性能。
StringBuilder # 其一般使用方式很简单。
StringBuilder sb = new StringBuilder(); sb.append(&amp;#34;abc&amp;#34;+&amp;#34;bbc&amp;#34;); sb.append(1.0); System.out.println(sb.toString()); 至于StringBuffer，可以理解为线程安全的StringBuilder。Builder的是非线程安全的，Buffer是安全的。所以在单线程的时候就可以使用StringBuilder。在速度上是 Builder &amp;gt; Buffer &amp;gt; String 。</description>
    </item>
    
    <item>
      <title>Maven</title>
      <link>https://Paladnix.github.io/posts/java/maven-1/</link>
      <pubDate>Sun, 02 Jul 2017 21:48:02 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/maven-1/</guid>
      <description>使用maven已经是不可避免的事情了，如果你是个java工程师的话。并且，使用maven基本上是你最好的选择。但是我并不喜欢用IDE来集成maven，这算是强迫症，命令行强迫症。
Maven 是什么？ # 传说他的功能十分强大，目前我感受到的是如下几个功能：
自动构建项目结构，根据不同的框架需求 自动包依赖管理 自动编译工程 自动启动测试 总而言之就是恰到好处的做了你觉得很麻烦又没有必要自己做的事情。 安装 # 跟JDK是一个思路的，在环境变量中添加M2_HOME即可。
使用 # # 创建Java Web 项目 mvn archetype:generate -DgroupId=com.hello -DartifactId=hello -DarchetypeArtifactId=maven-archetype-webapp # 生成项目 mvn install # 发布到tomcat # 复制生成的./target/xxx.war到tomcat目录下的webapps中去，如果不能访问就重启一下tomcat。 上述是将项目自带的helloworld页面显示出来，我们自己使用会用到一个更核心的方法&amp;ndash;配置文件。
pom.xml # 这个配置文件是maven的核心。
在创建好的文件夹中有一个pom.xml 这里的内容分成两部分，一部分是你的项目基本信心，叫啥，啥版本的等等；还有一部分是我们要配置的部分。这一部分又分成好几部分，有依赖关系(dependencies)、生成(build)等等。
下面是一个Maven的基本结构
&amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;!-- The Basics --&amp;gt; &amp;lt;groupId&amp;gt;...&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;...&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;...&amp;lt;/version&amp;gt; &amp;lt;packaging&amp;gt;...&amp;lt;/packaging&amp;gt; &amp;lt;dependencies&amp;gt;...&amp;lt;/dependencies&amp;gt; &amp;lt;parent&amp;gt;...&amp;lt;/parent&amp;gt; &amp;lt;dependencyManagement&amp;gt;...&amp;lt;/dependencyManagement&amp;gt; &amp;lt;modules&amp;gt;...&amp;lt;/modules&amp;gt; &amp;lt;properties&amp;gt;...&amp;lt;/properties&amp;gt; &amp;lt;!-- Build Settings --&amp;gt; &amp;lt;build&amp;gt;...&amp;lt;/build&amp;gt; &amp;lt;reporting&amp;gt;...&amp;lt;/reporting&amp;gt; &amp;lt;!-- More Project Information --&amp;gt; &amp;lt;name&amp;gt;...&amp;lt;/name&amp;gt; &amp;lt;description&amp;gt;.</description>
    </item>
    
    <item>
      <title>jersey</title>
      <link>https://Paladnix.github.io/posts/java/jersey/</link>
      <pubDate>Sat, 01 Jul 2017 20:32:52 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/jersey/</guid>
      <description>jersy是一个Web Service的框架，据说是符合RESTful架构的一种框架，这是一种新的思路，而不是新的技术，是对于前端的各种技术而言，所设计的后台实现方式，力图以一种统一的方便的方式组织为前端提供数据。 jersey的官网.
此次接触这个框架是业务需要了，但是，觉得这个框架比较简单，正好也有时间，所以就做一个学习实验，探索一下在资源短缺的情况下如何学习一个新的东西。事实上资源也确实不是很多，这一次主要依靠官方文档学习使用。
原本打算直接上代码的，但是在官网上看了一会后就发现有好多名词解释的问题。那就先来看几个名词。
首先第一个就是JAX-RS，这是JAVA EE6引进的新技术，全称Java api for RESTful Web Service. 主要是使用了注解的形式来简化Web开发和部署。然后跟Jersey的关系是Jersey实现了JAX-RS的框架接口，并且扩展了更多的东西，提供了自己的API。
然后学习Jersey的第一步就是搞懂他的路由方式，在这里就是注解了。
在讲注解之前还有一个不是很重要的名词：POJO(Plain Old Java Object), 称之为简单一般Java对象，这个概念是与JavaBean做区分的。其实没有什么必要，引用Martin Fowler的一句话：
“我们疑惑为什么人们不喜欢在他们的系统中使用普通的对象，我们得到的结论是——普通的对象缺少一个响亮的名字，因此我们给它们起了一个，并且取得了很好的效果。” ——Martin Fowler
所以事实上也就是个名词，所谓简单Java对象就是不包含业务逻辑的对象，一般用于描述数据实体。具体的区别等到写JavaBean的时候就看出来了，这里不讲了。
在我手中的项目使用了其中的两个包，maven代码如下：
&amp;lt;!-- jersey --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.glassfish.jersey.containers&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jersey-container-servlet&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.25&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.glassfish.jersey.core&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jersey-client&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.25&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 可以看到一个是servlet的Container，另外一个是client客户端。具体的用法，等到用到再说。
注解路由 # 这里用的路由就是JAX-RS的规范。（一次写不完，慢慢补充）。
@Path # 这个注解的原文解释非常好，所以有时间的还是去看一下原文是怎么写的吧，下面我就结合自己理解写一下。
这个@Path注解的内容是一个相对的URI路径，由其注解的类会被相应的路径访问到。
在下面这个例子中可以看到，这个类被一个@Path注解为&amp;quot;printers&amp;quot;，当URL路径为/printers的时候就会路由到这个类中，那么这个类有那么多函数，调用那个函数呢？下面还有子路径以及路径的通信方式。
首先HTTP-Methods都是被支持的，常用的有：
@POST @GET @PUT @DELETE 并且对于每个函数都可以进行@Path的进一步注解，有过Web开发经验的人都知道是怎么玩的。如果你的URL路径是/printers/list， 就会定位到getListOfPrinters()函数。同理可知其他的用法。 需要说的可能是如果一个函数没有注解而其他的函数有注解，在路径为printers的时候就会定位那个没有注解的，因为其他的都是精确匹配的，按照精确匹配无法匹配到其他的函数，这个是不精确匹配的，所以就过来了。 对于/，开始和结尾的位置可以加可以不加，都能够被解析。除此以外，这里还有些内容你可能看不太懂，下面会讲。
@Path(&amp;#34;/printers&amp;#34;) public class PrintersResource { @GET @Produces({&amp;#34;application/json&amp;#34;, &amp;#34;application/xml&amp;#34;}) public WebResourceList getMyResources() { ... } @GET @Path(&amp;#34;/list&amp;#34;) @Produces({&amp;#34;application/json&amp;#34;, &amp;#34;application/xml&amp;#34;}) public WebResourceList getListOfPrinters() { .</description>
    </item>
    
    <item>
      <title>IDEA常用快捷键</title>
      <link>https://Paladnix.github.io/posts/idea/ideakey/</link>
      <pubDate>Sat, 01 Jul 2017 20:14:58 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/idea/ideakey/</guid>
      <description>&amp;lt;Ctrl&amp;gt;+ &amp;lt;click&amp;gt; 定位到变量声明处
&amp;lt;Ctrl&amp;gt; + &amp;lt;\B&amp;gt; 返回上一次浏览的位置
&amp;lt;Ctrl&amp;gt; + &amp;lt;Alt&amp;gt; + &amp;lt;L&amp;gt; 自动对齐
&amp;lt;Ctrl&amp;gt; + &amp;lt;F12&amp;gt; 显示类成员
&amp;lt;Alt&amp;gt; + Left\Right 切换标签页
&amp;lt;Alt&amp;gt; + &amp;lt;Enter&amp;gt; 光标在错误上调出自动错误处理列表
&amp;lt;Ctrl&amp;gt; + &amp;lt;-&amp;gt; 折叠光标所在的方法
&amp;lt;Ctrl&amp;gt; + &amp;lt;Shift&amp;gt; + &amp;lt;-&amp;gt; 折叠所有方法
&amp;lt;Ctrl&amp;gt; + &amp;lt;=&amp;gt; 展开光标所在的方法
&amp;lt;Ctrl&amp;gt; + &amp;lt;Shift&amp;gt; + &amp;lt;=&amp;gt; 展开所有方法</description>
    </item>
    
    <item>
      <title>C&#43;&#43; OOP--const、引用、指针</title>
      <link>https://Paladnix.github.io/posts/c&#43;&#43;/c-oop-3/</link>
      <pubDate>Tue, 30 May 2017 17:39:54 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/c&#43;&#43;/c-oop-3/</guid>
      <description>继续梳理C++中的问题， 今天梳理的是最基础的几个概念，也是比较麻烦的概念。
引用 # 引用是一个变量的别名，声明时必须初始化，而且之能在初始化的时候绑定一个变量对象。
引用不能绑定在引用上，因为引用本身不是对象。 普通引用不能绑定到立即数上，因为立即数不是对象，但是常量引用是可以的。 普通引用不能引用类型不同的对象。 以上的普通引用是相对于常量引用来说的，下面会介绍到。
指针 # 这个概念最简单，他不是是一种数据类型，他的数值是个地址，可以用解地址符*来直接操作指向的地址内的变量。
指针有下面四种状态:
指向一个对象; 指向紧邻对象的下一个位置； 空指针(nullptr, 避免使用NULL，nullptr可以被转为任意类型的指针); 其他指针装态(无意义的状态)； const 常量 # const 修饰的常量，默认是文件内有效，如果想在多文件内可用，就加extern修饰。
这个和其他的东西一结合就比较烦。
首先const是声明常量的作用，用其修饰的变量值必须初始化且不可更改。这就是普通常量了，很好理解。
const 引用 # 如果你声明了一个引用，并且这个引用是const修饰的，那么，你要知道两个事情：第一，引用不能绑定到其他变量了；第二，用这个引用不能改变做引用的对象的值了，但是不影响那个变量通过其他途径改变，改变后的值一样会在引用中表现出来。
如果你引用的对象是个常量，那么这个引用也必须是常量。反过来没有这个限制。
const 指针 # 指针这块又有两种，因为指针是可以改变其指向的对象的，并且其指向的对象也是可以更改的。就出现了指针常量(pointer to const) 和 常量指针(const pointer)。汉字理解起来没有英文来的准确，所以下面不用常量指针和指针常量来表述。
pointer to const 很明显是指向的对象是个常量，而指针不能够修改这个对象的值。
const pointer 很明显就是这个指针是个常量，只能指向这个固定的内存，但是可以通过其修改对象的值。
在定义上如下：
int a; // pointer to const const int *p1 = &amp;amp;a; // 等同于 int const *p = &amp;amp;a; // const pointer int *const p2 = &amp;amp;a; 所以可以看出来，const修饰的就是紧跟其后的内容，在pointer to const的定义中可以认为*p 指代指向的对象；而const pointer中const修饰的是p；</description>
    </item>
    
    <item>
      <title>C&#43;&#43; OOP--函数解析过程</title>
      <link>https://Paladnix.github.io/posts/c&#43;&#43;/c-oop-2/</link>
      <pubDate>Tue, 30 May 2017 00:58:59 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/c&#43;&#43;/c-oop-2/</guid>
      <description>类的作用域 # 名称查找优先，对于编译器来说，优先寻找名称一致的函数，再关心类型的问题。
编译器在进行名称查找的顺序: 直接类定义 -&amp;gt; 父类定义 -&amp;gt; 祖宗类定义。但是，搜索顺序是按照静态类型开始的，结合上面的动态绑定，如果你的指针类型是父类，那么即使实体是个子类也不会在子类域中搜索，直接从父类开始搜索，因为编译阶段无法做动态绑定。
隐藏&amp;amp;重载&amp;amp;覆盖 # 这个概念刚开始学C++的人可能会比较迷。
隐藏 # 隐藏是在继承中出现的概念。基类与派生类有一个同名函数，则无论是否参数类型一致，基类的函数都会被隐藏掉。这个隐藏的意思，与Java中的override是否一致，我觉得不一致，但是效果一致。因为编译器在搜索名字的时候首先搜索派生类的函数，然后看参数，如果参数类型对的上就调用，对不上就报错。所以根本调用不到基类的函数，实现了隐藏。但是，C++中基类的函数还是存在的，Java中是直接将父类的函数段重写，父类的函数完全从代码段消失了。 既然还存在，就意味着可以访问。使用using关键字调用函数可以直接调用基类被隐藏的函数，可以说using改变了编译器名字查找的顺序。
对于虚函数，我们要求参数类型必须一致，就是这个原因。要实现动态绑定就必须使得当查找到函数名时，此函数可以被调用，而不是报个错说参数不一致。
这个规则是可以类推出来的，从命名上我们就可以窥探出这个东西有什么特质。
比如作为成员函数，就是可以被隐藏，无论是虚函数还是普通函数都是可以的。虚函数可以被普通函数隐藏，普通函数也可以被虚函数隐藏，其他一些概念一样可以用命名来推导出来。
重载 # 重载是对于函数来说的，与类间继承没有关系。对于一个普通函数，即不存在任何的类中的独立函数，重载的概念很清晰，就是相同的函数名，不同的参数列表；
对于成员函数来说，在同一个类中，可以重载，重载的概念也是一样的。
覆盖 # 覆盖与上面的东西又不一样，但是这个不是C++中的重点概念。覆盖是对于基类的虚函数来说的，派生类写一个名称、参数类型完全相同的函数，可以实现覆盖，其实就是虚函数的那一套东西。
只要分清楚，隐藏和覆盖是在父子间作用的，重载是同级内作用的就可以了。
那么有一个问题，很恶心，哈。 就是基类的虚函数被重载了，有很多个版本，子类在覆盖的时候，可以选择覆盖哪个版本。一样是使用using修饰符来将基类的函数作用域同步到当前作用域上来，这样只有对需要覆盖的版本进行覆盖就行了，其他的就使用基类的实现。</description>
    </item>
    
    <item>
      <title>C&#43;&#43; OOP基础--动态绑定</title>
      <link>https://Paladnix.github.io/posts/c&#43;&#43;/c-oop-1/</link>
      <pubDate>Mon, 29 May 2017 19:10:17 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/c&#43;&#43;/c-oop-1/</guid>
      <description>面向对象其实就是那样，都差不多，不一样就是关键字还有一些奇怪的机制问题，总的来说实现的东西都是一样的。
虚函数 # 对应Java的抽象函数。但是略有区别。 虚函数在定义的时候使用关键字virtual来修饰声明，但是不一定是没有实现的，可以指定一个已经是实现的函数为虚函数。虚函数最主要的定义是使得每个继承他的子类都实现自己的版本。并且虚函数是实现C++动态绑定的关键。 虚函数只能声明在类的内部。
动态绑定 # 所谓动态绑定就是，有些函数并不是在编译的时候就知道要去调用那个函数的，而是在真正运行的时候才能根据变量的类型去调用对应的函数。这个实现就是对于基类的虚函数，子类也实现一个版本（子类在实现的时候不需要指定函数为虚函数，因为继承过来的函数就是虚函数，是可以传递的），这样对于同一个函数就有两个版本，当我在调用的时候使用指针调用或引用调用（注意必须是这两种调用之一的方式才会有动态绑定的效果，其他都是在编译阶段就能够确定下来。）就可以实现动态绑定。
由于虚函数是在执行的时候才调用，所以在编译阶段就有些错误报不出来，比如如果我们没有实现某个子类的虚函数，在调用的时候就没有函数去执行，所以所有的虚函数都必须被定义，而不仅仅是声明，普通的函数只要我们永不到就可以不进行定义。
引用和指针调用 # 所谓引用和指针调用，是指函数中关于虚函数的调用对象是作为引用参数或者是指针参数传进去的，这样就需要根据参数的类型来调用不同版本的虚函数。这里就要说一下基类与派生类之间的类型转化问题，正是因为其二者可以进行类型转化，所以在参数列表中的类型并不能唯一限定参数的类型，才有了虚函数调用时的动态绑定。
类间类型转换 # 子类中有一部分是来自与基类的，这一部分可以被单独利用。也就是说，一个子类，我们也可以把他当作他的某个基类来使用，使用的时候只用到基类的部分。也就是说，我有一个基类的指针，我就可以指向这个子类，此时，指针就操作子类的基类部分。这就是从派生类到基类的类型转换。
反过来就是不行的，可想而知，多的东西可以不要，少了东西就会有问题，所以不存在从基类到派生类的转化。同时我们也就明白了，如果你要对于一个虚函数动态绑定，在调用函数的对象的类型声明的时候就要声明为基类的类型，这样当你传入一个子类的引用的时候，该引用就会转换为子类，进而去调用子类的虚函数实现；如果你写声明的时候声明为了子类的类型，就没有办法动态绑定了，因为反向没有办法转换。
虚函数覆盖 # 子类要实现自己的虚函数版本就要对基类的虚函数进行覆盖，override，又是这个熟悉的东西。覆盖当然就要参数类型完全一样，参数不一样的那是重载，是不同的函数。书上说，一般我们都是要进行覆盖而不是重载，但是有的时候我们会搞错参数列表的顺序等细节，所以，你可以在函数声明的参数列表后加override说明符来告诉编译器，你是要覆盖虚函数的，如果有细节错误就告诉我！
如果你在后面加上了final修饰符，就意味着，这个虚函数不希望再被覆盖了。
关于虚函数的默认参数，不同版本可能会有不同的默认参数值，但是在默认参数的选取上，是依据静态类型决定的，也就是说不能做到动态绑定，调用函数的对象定义成什么类型就用什么默认值。如你调用函数的对象是基类的引用，那么即使你最后执行的是子类的函数，默认值也是基类的默认值，所以这个就会出现隐蔽的问题。所以安全起见，默认参数一致最好。
猜想 # 同时从这里我们也可以窥探出编译器的原理。对于一个函数覆盖来说，函数的默认值必须是在编译阶段就写进机器码中的，尽管你有两个版本的函数，编译器会对两个函数分别编译，但是默认值存储的实现是与函数编译分开的。这里只是猜测，对于函数的默认值，其实编译器可以将其存储在对应的栈位置上，也可以将其转成一个赋值命令存储在函数代码段中，这两种理论上都可以实现默认参数的功能，但是从编译器的定义角度，参数是单独存放在数据段的，而不在代码段，那么在编译的时候就会根据你参数的字面类型进行设定，而无法进行动态绑定。这个应该是C++的一个设计缺陷，最初设计函数编译的时候没有动态一说，就直接写进数据段了，等到出现动态绑定的时候沿用之前的函数处理的方式，就无法实现绑定。（不知道这个思路对不对，以后有时间考证下）。
回避动态绑定 # 除了动态绑定，也可以用作用域操作符来强制执行某一类的虚函数版本。
double ans = C-&amp;gt;Base::Update(); 为什么要回避动态绑定，这与类间设计有关。如果基类与派生类关于虚函数功能设定是：基类虚函数处理通用处理，派生类处理剩余子类相关内容，那么对于真的要完整实现功能的时候就要在派生类的虚函数中先调用一下基类的虚函数，再实现派生类的函数剩余部分，所以这时候就要回避动态绑定。
纯虚函数 # 你的直觉会告诉你这个纯虚函数应该是个只有声明没有定义的函数。没错，这就是纯虚函数，在格式上有一个特点，就是函数声明最后有一个=0标志。这个声明必须在类的内部，并且类内不能对这个函数进行定义，在类外部定义是可以的。
纯虚函数是在一些设计上必要的。比如我们有一个操作，有4个版本，每个版本根据不同的参数值有不同的动作，那么我们会设计一个基类，并在基类中声明这个函数，但是这个函数明显什么都不能做，而是要等到不同的子类根据自己的方案实现这个函数。所以这时候就声明一个纯虚函数就好了。
子类只要正常的覆盖这个函数就可以，如果不覆盖就继续往下传递。
抽象类 # 很熟悉，Java中含有抽象函数的类是抽象类，在这里有纯虚函数的类就是抽象类。并没有什么修饰符，就是个类。
继承中的友元 # 友元不可继承、不可传递。 派生类的友元不可访问基类中的非公有成员。 </description>
    </item>
    
    <item>
      <title>Java 抽象与接口</title>
      <link>https://Paladnix.github.io/posts/java/java-1/</link>
      <pubDate>Mon, 29 May 2017 04:24:56 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/java-1/</guid>
      <description>在使用Java的过程中最主要的就是接口、继承这些东西。其实概念十分的简单，只是名字特殊了点，设计的技巧性较强。
之前听到有人在思考抽象类和接口的区别，以及为什么要两个都存在。但是，可能是我的见识太短，并没有这样的疑问。
抽象 # 面向对象编程抽象是避不开的内容，最经典的动物类，没有任何一种生物你可以说他就是动物，但是就是有动物这个概念，所以动物就是思维的抽象。良好的设计就要这样从抽象一步一步实例化最后具象为实体。 那么对于抽象的类来说，有一些东西就没有办法确定，比如动物的行走是用腿还是用腹？这个在动物类中无法确定，所以就需要先抽象着。
抽象类用修饰符abstract 修饰，并且抽象类不可以实例化，所以就不能用final来叠加修饰。抽象类可以没有抽象函数，但是有抽象函数的类必须定义为抽象类。
抽象函数 # 就是只有声明没有定义的函数，声明如下：
public abstract boolean Update(); 抽象类 # public abstract class A{ ... } 接口 # 与抽象类最大的不同就是，这并不是个类。接口不是类。所以这两个东西在本质上就不一样，所以我不认为二者有什么好冲突的。
而且最重要的就是，在Java中类是单一继承的，也就是说一个类只有一个父亲。那么对于从动物类派生出来的陆地动物、水生动物来说是没有什么问题，但是对于一个两栖动物就很尴尬，他没办法从上面的两个类中做继承，你要单独分出一个两栖动物也不是不可以，但是如果在一个系统中这样的复杂类型非常多就非常的麻烦了，然而在C++中是可以多继承的，于是就出现了接口这个东西。
接口是一种特殊的、完全没有实现的类。其中所有的方法都是没有实现的，且其中的域全都是常量。
接口的定义 # public interface interfaceName [extends superInterface1, superInterface2, ...]{ // 常量定义(类型已经默认，可以省略不写) [public] [static] [final] type Name = constValue; // 方法定义 [public] [abstract] returnType functionName(params)[throws exceptionList]{ ... } } 在子接口中对父接口的函数可以进行覆盖。
接口的实现 # public class A implements Interface1, Interface2, ...{ // 必须实现所有的接口函数 } public abstract class A implements Interface1, Interface2, .</description>
    </item>
    
    <item>
      <title>Hexo</title>
      <link>https://Paladnix.github.io/posts/others/hexo/</link>
      <pubDate>Sun, 28 May 2017 14:24:05 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/others/hexo/</guid>
      <description>这是一个经济又快速又好看的博客搭建教程。
你的博客将会有一个后缀为github.io的域名，并且在该域名下有300M的存储空间。但是，本教程只写给Linux用户，其他用户参考自行摸索，原理一致，操作类似。
你看到的我的这篇博客就是最后的效果，当然你也可以自行修改样式。
博客使用Hexo博客生成系统，其优点如下：
简单快速，无需服务器端架设环境。 可选样式众多，易于修改。 扩展插件众多，且使用方便。 使用markdown语法编写博客，易于上手。 生成博客为纯静态代码，无需运行环境可直接移植，不依赖数据库。 本机环境的准备 # 你需要以下几个软件的环境：
Node.js Git Hexo 安装node.js # 在安装这个的时候卡了很久，然后才知道自己装的是Node.js, 然而需要的是Node！正确的结果是在命令行输入node -v 如果可以看到版本号就可以了。 正确的安装命令是：sudo apt install nodejs-legacy，害怕。。。就是有这样的操作，当你install nodejs的时候，对不起，这个并不是你要的node.js， 哈，我也很绝望啊！
然后要安装一下这个npm工具：
$ sudo apt install npm $ npm -v #看npm版本，如果结果显示版本号则安装成功 安装git # $ sudo apt install git 有的时候在安装完git后依旧在项目中无法使用，后面发布博客到github上面的时候会使用到git，如果报错：Deploy not found git 之类的，就需要再搞一下这个玩意儿！这就是软件版本混乱的锅，想说爱你不容易！
$ npm install hexo-deployer-git 安装Hexo # $ npm install hexo-cli -g 当然这个在安装的时候也有坑出现各种问题，那就只好去百度了，我是因为前面的东西出问题后来修好后就好了。一般也不会有啥问题了。
使用 # 其使用逻辑非常简单而且封装很好，命令操作也十分简洁，重点在于配置文件的修改。这是个强配置的框架，事实上好的框架就应该这样，甚至可以将软件由不懂程序设计的人来使用，但是前提得有一个个很清晰的配置文件设计思路以及详细的说明书……
建立工作区 # $ hexo init Blog $ cd Blog 新建一篇博文 # 在Blog文件夹内执行：</description>
    </item>
    
    <item>
      <title>ACMRoad</title>
      <link>https://Paladnix.github.io/posts/acm/acmroad/</link>
      <pubDate>Sun, 28 May 2017 03:35:21 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/acm/acmroad/</guid>
      <description>作为ACM的老队员，最经常被问的不是XXX算法的问题，而是“学长我要玩ACM，我该从哪开始？”。这个问题嘛，有超过3个人问就有必要写成文字来回答，正如但凡一个操作需要两条以上命令就可以写成脚本来做一样。
就不回首往事了，尽管一路走来感慨良多啊。
新人，也有区别。你是没有程序编写基础的还是有一定代码基础的？有Py基础还是C的基础？有没有算法基础？
如果你是一个大一新生，且没有学过程序设计，或正在学，那么我建议你花最多2周，把C语言关于文件操作之前的部分学完(文件操作非必要)。不要说2周太短了，如果你打算在ACM竞赛中获得不凡的成绩，就2周。你可能天赋异秉可以花很少的时间学会C语言，这很好，说明你有个好脑子，且可以在搞好ACM的同时兼顾上课。如果你的脑子不是很棒，但是也喜欢，2周时间就必要的做些调整，课该怎么上就要考虑一下了（事实上就算是脑子很好，也要考虑一下）。
然后你可能要检测一下自己的C语言水平，尤其是在做ACM题目上的水平。此时我建议你去用2周的时间刷掉HDU平台上的第11页的题目，这上面的题目涉及到的算法比较简单，算法对应的C语言程序也比较简单，只是使用到了字符串的处理、数组的使用、结构体的使用等基本语法知识，但是会让你对这些基本知识有翻天覆地的改观，他们很简单，但是可以做出很神奇的动作。这些题目可以让你对C语言的语法更加熟练，甚至到了4岁小朋友说母语的水平一样自然而流畅，同时，当然你因为不会使用高级语法来加快代码编写速度和质量，就像4岁小朋友不会写作文一样。但是仅仅语法熟练只是一方面，同时你会学习到一些更加快速方便的函数，如使用sort()函数来排序而不是自己编写冒泡排序等傻逼的排序函数；你还会接触到强类型语言中变量的数值边界问题、数值精度问题；字符串处理的常见bug；如何编写递归代码等。你还会知道你的电脑一秒钟只能运行大约1e8次的简单数学运算，你会慢慢的学会用计算机的思维方式思考问题的解决办法。同时你还会接触到一些算法，如动态规划等。（此页中有很少的几个题目非常困难，没关系，不要管他们，但你需要完成至少90道题目）
然后你可以小声的对自己说：“我已经看到了ACM-ICPC的影子了！”。
然后你需要入门一下。这个阶段你可能会比较痛苦，因为你要做的就是不断的离开你熟悉的几行代码，转而去学习新的算法，写新的代码。而这一切，应该都没有人会仔细的教你。
到现在为止，你可能都没有学过一个完整的算法。之前做的那些水题都只是思维的开胃菜而已。那么现在你要清楚你必须去认真的、系统的学习一些算法。要能清晰的理出算法的逻辑，快速的编写出高质量且准确的代码，要能眼动查找BUG。不用担心，有人的地方都有路，已经有无数人做过这件事，所以你有章可循。
在介绍下一站之前，我必须告诉你，ACM比赛使用Linux操作系统编写代码。所以，按照我们的一致希望，我们希望你能从现在开始使用Linux并逐步使用Linux来工作，windows只是个好东西，但不是程序员的玩具，你的玩具是Linux操作系统，比赛统一使用Ubuntu操作系统作为平台，如果你对Linux一无所知，你需要去百度一下了。
至于如何安装Ubuntu操作系统和如何使用，请见其他博文或直接来实验室寻找学长的帮助（文章目前还没有整合）。
你需要去Vjudge申请一个帐号，并且开始学习[简单搜索专题]传送门。我们一致建议从这个算法专题开始，因为这里要用到的技能你学习起来会比较快速，因为你的前期技术铺垫已经做好了。其次这里的内容将会在其他的算法中使用到，所以你要从这里开始。这里的学习并没有学习资料，一切资料都在网络上，这里有的只是十几道检验你学习成果的题目，但是，这些题目与你今后比赛中遇到的题目在外形上长的已经很相似了。你大概需要一周多一点的时间来攻克这个专题。当你结束这个专题的时候你应该具备以下几条但不限于此的能力：
快速编写递归程序。 看到搜索类问题可以快速反应出解决方式并编写代码解决。 快速估算自己方案的时间空间复杂度并决定是否可行。 尝试使用高级一些的语法来编写代码，如C++中的部分内容，包括重载运算符等。 手动调试代码修改BUG而不需要依靠调试工具。 初步熟练使用Vim编写代码，并初步熟悉Linux-Ubuntu操作系统，使用简单命令来操作计算机。 熟练的从网络上寻找资源解决自己的疑问，同时可以快速的看懂别人的相关代码。 了解一些题库。 接下来你或许就不再需要这篇文章的指导了，但是，你离入门还差的远。
之后的一段时间内，算法还是要继续学习，依旧用这样的专题的形式。同时你也要去接触一下真正的比赛是什么样子，以及，真的强是什么样子。
以下平台会不定期有比赛，可视个人情况参加： # Codeforces(cf) HihoCoder
以下算法方向需要你在未来两年内有所涉及，但是掌握这些算法并不是保障： # 搜索 图论(最短路、生成树、二分图、连通图、网络流&amp;hellip;) 动态规划(树形DP、数位DP、区间DP、斜率DP、概率DP&amp;hellip;) 数论 数据结构(线段树、搜索树、平衡二叉树、KD树、树堆&amp;hellip;) 字符串(KMP、Hash、AC自动机、后缀数组、字典树) 等&amp;hellip; 推荐的书： 刘汝佳竞赛入门经典两本：紫书、大白书，链接不放了。 # 有些问题，可以先尝试自己回答一下，自己实在回答不了或无法找到答案回答，再提出来。</description>
    </item>
    
    <item>
      <title>OOP中的-控制修饰符</title>
      <link>https://Paladnix.github.io/posts/c&#43;&#43;/accessmodifier/</link>
      <pubDate>Sat, 27 May 2017 15:55:04 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/c&#43;&#43;/accessmodifier/</guid>
      <description>面向对象编程(Object-Oriented Programming)中,最初开始接触到的就是访问控制修饰符。访问控制修饰是几乎所有的OOP语言都会涉及到的，下面就整理三个我熟悉的语言。
C/C++ # 更详细的内容可以参考《C++ primer》-类 这一章。
概述 # 有三种修饰符，分别：private、public、protected。其中最后一个protected是在继承出现以后才有效的。对于无论是成员变量还是成员函数，这些修饰符都具有相同的作用，即访问控制。其设计的主要作用是为了防止封装的类内成员被类的使用者无意更改或误操作，同时，对访问权限的限制可以实现代码间的松耦合。在类内算法做调整的过程中保持使用者可调用的代码接口，只更改私有函数等。 在详述各个控制符之前要讲一下struct 和class的区别。二者都可以用来定义类，唯一的不同就是默认的访问权限不同。struct的第一个修饰符之前定义的成员默认是public的，但是class是默认private的。
private 与 public # 这两个要一起来说，因为二相相生。private就是将控制权限制在类内，只能是类内的函数访问。public完全没有限制。这两个是最容易理解的，也没有什么好说的。
protected # 比上面两个略复杂一点点。在没有继承的情况下，protected与private是一样的，所以protect之所以与private不同在于派生类的访问。其修饰的成员可以被派生类直接访问，但是不被派生类对象访问。这个有些博客写的不太严谨，protected无论什么时候都不能与public一样，也就是类的使用者不能直接访问。 换句话说，派生类可以将其修饰的成员当成自己的亲成员来访问，派生类内部可以用对象实例来访问，但是类外不行。
举个例子：
class Base{ protected: int m; ... } class A : public Base{ public: // Note-1 void Add(A &amp;amp; tmp){ tmp.m += 1; } ... } int main(){ A tmp; // Note-2 int x = tmp.m; return 0; } /* * 其中，Note-1的写法没有问题，但是Note-2的写法就是非法的。 */ friend # 有的时候我们的类成员不能被使用者直接访问，但是我需要让其他的一些非类内成员函数来访问，如重载运算符的时候需要被模板函数访问，所以又有了一个新的控制访问修饰符，这个修饰符只用来修饰一些函数或类的声明，也就是说可以让一些类或函数成为该类的友元，使得其可以访问类内的成员变量和成员函数，不受其他修饰符的限制。
只能修饰非成员函数的声明，或其他类。 只能在类内修饰。 其声明不受其他几个修饰符影响。 友元关系不能传递, 也不可继承。 友元声明，只是声明了访问权限，并没有实际声明，如要使用该函数，仍然需要显示用普通声明再声明一次。 用作继承权限修饰符 # 除了用于成员权限声明，此三个修饰符海可以用来修饰类的继承方式，不同的继承方式使得基类成员在派生类中的权限不同。</description>
    </item>
    
    <item>
      <title>随想-1</title>
      <link>https://Paladnix.github.io/posts/self/thinking-1/</link>
      <pubDate>Sun, 21 May 2017 10:06:11 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/self/thinking-1/</guid>
      <description>最近听民谣，都是比较低沉的，各种无奈、不得志等等。。。但是这个阶段的我听了却是一脸的轻蔑。
第一首歌，听到“趁我们还年轻，还可以倔强”，我的第一反应是为什么不年轻就不可以倔强？然后想到了我的父亲，这应该是十分真实而贴切的例子了。
我真切的感受到我父亲的无奈与痛苦，所以曾经思考良久，一个男人自己与家庭是什么关系的存在？是财富收入的来源？是家庭的一份子？是家庭具有主宰地位的人？…… 我自己心中当然有我的答案。得出自己的答案永远只需要1秒钟，剩下的就是你的内心能否强大的做到这个答案。我的答案跟真理同路，跟大众心理相悖。我不认为男人跟女人之间有什么家庭分工上的区别，不存在男人就要做什么而女人就不需要做什么。有人可能会问你为什么不说不存在男人就不做什么而女人就要做什么？你这大男子主义！呵呵，现实中大家都知道，女人一旦不高兴了，还有什么做不做，男人不都特么得做吗？男人不高兴了能怎么样？排解一下、发泄一下、调整一下，回来继续该干嘛干嘛。那么，为什么？为什么会有这样的情况出现？有人说不这样的男人都被淘汰了。当然这只是一部分的人，并不是所有的男人女人都是这样，总有一批人大家都认知很清楚明了，不会做这样无聊又损人不利己的事情。
男人跟女人没什么差别，人格上没有、性别上没有、能力上也没有。有人说女人青春就那么短暂，过了那段时间就人老珠黄，而男人呢？四十还是一样反而越老越有魅力。其实这个观点就足够写一篇文章的了，今天就慢慢来扯一下。首先第一个就是为什么男人年龄大反而有魅力？为什么女人没有？这个问题我的第一反应很清晰，因为男人在社会上什么都干，生活了那么久，各个方面的能力经验财富都积累的很多，所以由内而外的散发着成熟的力量，这是真正的魅力，当然有一些各个方面都不怎么样的男人就没有这样的魅力了。然而女人嘛，如果你选择了在20多岁依靠自己的美貌获得了生活资料，那么必然就缺少了这些经验、阅历、能力等，自然当你年老色衰的时候就没办法散发这样的力量。如果你没有依靠女性特质来生活，你的人格魅力应该也是非常大的。所以在这个角度来看，大家都是一样的，你有能力，有经验，就会有魅力，而不是人种天生带有区别。一个男人年轻的时候依靠家里的财富而腹内空空，等到40岁一样是个没有魅力的中年人。当然要说一下的就是，有优势就要用，但是别依赖。最可怕的不就是别人比你聪明还比你努力吗？同样可怕的就是别人比你先天优势强，还比你更清楚自己要做什么。
另一个角度就是，女人的青春短暂，那么，男人的青春就不短暂了吗？男人也是这个年纪身体素质很强，体型最好看，精力最旺盛，过了这个阶段一样就是个中年人，他的内在可能很强，但是外在一样衰老。但是男人在这段时间做了什么，一些女人又做了什么？我认识两个女人，大我10岁，此刻都是30多的年纪了，现状截然不同，而这样的现状我曾预料到，但是当时不敢相信，后来现实印证了。一个是很骄傲、很独立、有想法有能力的女人，长的也好看；另一个就是最最一般的女人，该上学的时候没有好好上，当然另外一个也没有好好上，俩人同学。然后这个女人在生活稍微好一点的时候，就会享受生活，说享受其实不太恳切，就是对后面的事情抱着极其乐观的心态，因为挣钱的是他的男人，当经济不紧张的时候就吃吃喝喝玩玩乐乐，等到经济紧张的时候就满面愁容。另一个女人，在青春中，学习茶道，卖茶叶，谈了恋爱，分了手，但是始终经济独立，有自己的事业。此时的二人，在两个层次甚至差了两个层次。等到两个人都30多了，都开始容颜凋谢，该有魅力的人依旧碾压另一个，当然你要跟20岁的小姑娘比，颜值自然没法比，但是思想更胜一筹。从这个角度来说，男人女人一样，放在自己的同类中做对比，很现实，很多人就是自己没有自律这个东西，今天好了就天真的想象每天都好，思维目光具浅。自己付出了多少就会得到多少，别的都没用。其实这个故事中还有另外一个角色，就是这个普通女人的男人，他是个很有头脑也有能力的人，但是这个男人大这女人10岁，就是我的父亲。由于各种原因，男人要在这样的情况下工作，又没有固定的工作，工程风险很大，所以，在这种风险很大的情况下身边还有一个这样的人存在当然就特别容易出问题，这里疏漏一点那里浪费一点。所以多这个男人来说，他被拖累了。更严重的是，他们有一个小女儿，又是一个无法摆脱的负担，还有一个上大学的儿子，怎么办？还能怎么办？对这个男人来说就被加持死了，没有办法动，没有足够的资金支持他做出变动，即使所在的行业出现问题，也必须坚持到儿子大学以后才行吧。
这就是无法倔强！
他曾经有什么样的眼光、什么样的魄力和勇气，孤身进入一个新的行业，依靠自己的社交能力和头脑，自己解决机会问题，解决技术问题。我十分清楚，并且十分敬佩。但是现在的他，就是这样的无奈。心中纵使万分不服气，没办法，倔强不了。儿子要生活、女人要生活、女儿要生活，不能让他们都暂停啊，说给我一年时间我去自由打拼挣钱去。曾经我还小的时候，无所谓，我放在我奶奶家，也离婚了，自己一个人，就特么天不怕地不怕。什么是倔强，就是当我有一天想做什么事情的时候我就能去做而不是被现实加持的死死的在心里挣扎。
这需要什么？很清晰，一定的资本储备，一个人或有个贤内，一个清晰的头脑。千万不要因为一时的寂寞、一时的人性弱点就贸然做不成熟的动作，最大的表现就是不要因为寂寞就找个不适合自己的女人，这是最最最重要的。你要倔强，要自由，就得承受这些不好过，这就是代价，但是对我来说，我可以忍受寂寞，但是我无法忍受自己怂，我自己怎么失败我都认，但是如果让我因为某个人而没有尽全力而败，我会恨这个人，但是这个人是我自己选择的，怎么能恨她呢？最后还是恨自己，相当于自己做了不成熟的选择，所以不存在这样的人就不存在这样的风险。当我一个人的时候我什么时候都能吼一句：从头再来！然后哪怕几天吃不上饭又如何，我不怕。我不能低下我的倔强的头，那是我活到现在的一大支柱。
当你一个人的时候，一切都变简单了，毫无压力就往前走。生活费？不存在的，能吃饱就行，吃的自在一点也没多少钱。房子？无所谓，有个洗澡睡觉的地方就够了，大了还得打扫。人际？都是自己好兄弟，挺开心的。父母？自己的，有困难说话，没困难我要有自己的生活了。我有喜欢的东西，车、狗。攒钱去买，没钱了车可以不开，狗可以跟我一起吃我剩的。
这世界上唯一不存在的就是规则。我为什么非得用别人的做法来要求自己？那是别人的做法，那是大家认为的规则，什么没有房子就很难结婚，什么各方压力很大。那都是庸人被裹携，我为什么还要自己走进去？当然不，没有谁规定，就算有人规定没房子不能结婚，那我干嘛要结婚？也没人规定必须结婚啊。所以，没有规则。
这社会有规则，但是你有选择规则的权力。你可以选择进入一个体系，然后要与其中的规则博弈。你要看清楚你适合什么样的规则，甚至有很多规则是潜在的，隐藏的，但是你可以看出了它真实存在，你就像一个异类生活在一个体系内却用着另外一套规则跟他们博弈。这依靠的是你对社会规律的把握。你没有必要遵循大家的规则，因为大家要的东西不一样怎么能用同样的规则呢？
行业最害怕的就是践踏规则的人，因为这样的人一定成功更快而且当你意识到的时候已经无力回天，只能望尘莫及。很典型的就是当初瑞星杀毒和某杀毒软件价格竞争的如火朝天，360突然冒出来说，我不要钱，免费了。其他人还玩个屁，然后所有人都只好玩免费。有些规则可以践踏，有些可以，当你看到一条规则可以践踏的时候，就别犹豫，干了再说。
Good Luck.</description>
    </item>
    
    <item>
      <title>学习更深C/C&#43;&#43;语言之前的思想准备</title>
      <link>https://Paladnix.github.io/posts/self/before/</link>
      <pubDate>Fri, 19 May 2017 19:46:17 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/self/before/</guid>
      <description>从开发这个Online Judge开始到现在，我自己收获颇多。有的时候是为了这个项目去学了很多东西，有的时候是学了其他的东西刚好就用在了这个项目上。一个良性的过程就是这样，有的是目的去做，有的是无心为之，但总会带来新的峰回路转，柳暗花明。从最开始的稚嫩，连MVC的概念都不清晰，就开始写，一点点实现，写的很丑，然后就写不下去了；后来学习了Java 的MVC， 然后又偶然看到了Php的MVC，然后就开始写自己的框架，有了Husky，然后就把OJ用框架进行重构。写了一段时间后，写到了后台的判题核心，一部分是自己闭门造车，一部分借鉴了网上的思路，但是实现起来总是那么别扭，说不上的不放心。刚好在这样的情况下，又看到了一些实现的细节，有了新的思路。意识到自己的技术实力贸然开发是很不成熟的，但是，没有关系，本来就是这样，它成功了是我的成功，他不成功也不会失败，是我增长经验最重要的一次经历，我借此机会学习到了很多知识和经验。但是我一定是对此有很大的信心和决心，要做好，并且要做的更优秀，虽然可能会花费比较长的时间。
写这篇博客的时候，此时我坐在理工楼三楼的悬空阳台上吹着风，听着手机的歌，塞着耳机，桌子是暗红色，很沉稳；一字排开手机、电脑、鼠标。很少会动鼠标，更少动手机，很简洁也很舒服，优美又惬意的工作环境。
下午的时候，突然大脑进入了很奇怪的状态，突然想不起来刚刚要做什么，跑出去打了一个多小时的球，然后回来去洗澡，车忘了骑回来，裤子也被打出一条口子，整个人的状态就不对。可能最近一直都是满载运行，所以需要休息一下，然后就过来写博客了。
写这篇博客干什么呢？ 为了更好的出发。
意识到自己在C++的操作系统部分的薄弱，所以下一步就是要开始学习，以OJ的判题核心为基础，一个一个的学习下来。学习的过程与开发过程是完全不一样的，因为学习是很卡顿的过程，总是不懂，然后查，然后想，记下来。所以带着开发的节奏来学习就不行，开发的时候要一气呵成，行云流水的代码一行一行的开始码，思路很清晰，然后单元测试，几个修改，结束。就像是一切都准备好后开始做菜，一步一步几分钟就出锅了。学习的过程就不一样了，要看，要记下来，更主要的是，要实践，甚至是各种情况都要试验一下，才能熟练的掌握用法，处变不惊。
所以这篇博客就是自己跟自己谈谈心，调整一下装态和心态。同时也规划一下学习的路线。
路线： # C++中的系统进程、内存、CPU时间相关的函数用法。 C++编译器的参数使用。 C++头文件使用。 C++机器相关的常量与不同机器之间的区别。 以上是第一部分，另外就是关于如何在服务器上开设一个独立服务，监听端口。还有消息队列怎么在PHP和OJCore之间传递。 一点一点来，应该会需要1周左右的时间。
明天是5.20，此时的我毫无想法。其实大家都差不多，看谁能得偿所愿吧。或许再过一段时间，都明白了是怎么一回事，就再也不会这么傻了，那个时候就挺可笑的了。
有些事情，只有一次机会，错过了，就变成了另一种，虽然表面一样，但是实质已经不同。
Glade to see you.</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>https://Paladnix.github.io/about/</link>
      <pubDate>Thu, 18 May 2017 02:03:44 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/about/</guid>
      <description>参加过ACM-ICPC 算法竞赛，成绩还可以。喜欢算法，喜欢简洁的东西，至少用起来要简洁， Linux死忠粉。 觉得趁年轻，该努力就努力，趁还喜欢学习，就多学一些。希望如果某一天突然想干点别的就能去干点别的。但是，写程序，是一辈子的爱好了。
计算机科学与技术学院 ( CS ) 苏州大学计算机科学与技术学院ACM集训队 ( 队长 ) 苏州大学微软学生俱乐部SUMSC ( 主席 ) 2017.01 MCM/ICM Meritirious Winner 2016.12 ACM/ICPC Asia Regional Contest China-Final 2016 Bronze Medal ( Shanghai ) 2016.11 ACM/ICPC Asia Regional Contest Beijing Site Sliver Medal 2016.10 CCPC Hangzhou Site Sliver Medal 2016.10 ACM/ICPC Asia Regional Contest Dalian Site Gold Medal 2017.10 ACM/ICPC Asia Regional Contest Shenyang Site Gold Medal 2017.11 ACM/ICPC Asia Regional Contest Qingdao Site Gold Medal 2017.</description>
    </item>
    
    <item>
      <title>Husky - A Light Web MVC Framework</title>
      <link>https://Paladnix.github.io/posts/web/husky/</link>
      <pubDate>Wed, 17 May 2017 21:56:06 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/web/husky/</guid>
      <description>这篇文章是对我自己编写的PHP MVC 框架：Husky 的详细说明， 算作是官方说明文档。
项目的GitHub地址
Husky是什么？ # Husky 是一个使用PHP语言编写的Web MVC微框架，此项目最初是作者偶然看到的一篇博客中的教学项目。我对项目的代码进行了一些修改和整理，删除了一些不必要的内容，添加了部分设计，目前框架处于第一个版本(Husky-0.9)，框架将会长期维护更新。目前只在Linux开发环境下测试可用。
如果你是一个初出茅庐的Web开发者，那么本框架就十分适合你来使用了。相比较很多成熟的PHP框架来说，Husky的体积小，逻辑简单，还没有加入很多集成的自动化功能。整个框架按照一个既定的数据格式实现了MVC开发的需求，更主要的是，在一定程度上说，这个框架还处于比较原始的状态， 这对新手深入了解框架的体系结构十分有利，你可以按照自己的想法对框架进行修改，甚至可能在此基础上改写出更出色的框架。
本框架的开发初衷是为作者所在的学生社团开发网站，多人合作模式下编写网站没有一个框架实在太乱了。但是衡量工作内容，于是决定自己开发一个微框架来辅助网站的开发，就有了这个项目。
你需要掌握什么？ # 此框架需要一定的php网站开发经验才能熟练的使用。所以在使用之前，你需要具备以下的知识或能力:
配置apache2 的Rewrite功能 数据库SQL语句 php基本语法 面向对象编程的基本知识 简要了解http协议与请求url链接 清楚的了解软件 MVC 架构的组成 在进一步开发框架之前，你需要进一步具备以下的知识或能力:
apache2 的更多配置选项 熟练掌握http协议 深入理解 MVC 框架结构 熟练使用php语言进行面向对象编程 熟练使用PDO数据库操作库 良好的编程习惯 Husky 做了什么？ # Husky 实现了下面几个功能：
唯一的网站入口，url地址重定向 自动化加载MVC控制类，自动化解决类间依赖 过滤SQL注入攻击的安全问题， 使用PDO进行数据库操作 Controller、Model、View模块分离 定义数据参数等的格式 配置环境 # 框架需要软件环境：
Linux apache2 php(&amp;gt;=5.4) mysql 开启apache2 rewrite 功能 # 默认的Ubuntu apache2是没有开启这个功能的，要先去看一下 /etc/apache2/mods-enabled/ 文件夹下是否存在rewrite.load 模块的链接，如果没有，要去看一下 /etc/apache2/mods-available/ 中是否存在对应的文件，如果有，则使用下面的命令建立一个链接到 ../mods-enabled/ 文件夹下：
$ ln -s /etc/apache2/mods-available/rewrite.</description>
    </item>
    
    <item>
      <title>Begining</title>
      <link>https://Paladnix.github.io/posts/self/begining/</link>
      <pubDate>Wed, 17 May 2017 18:12:01 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/self/begining/</guid>
      <description>这里是新的起点。
其实没有什么特殊的事情发生，只是因为最近的状态发生了一些很微妙的变化，从一个单纯的ACMer逐渐的过渡到一个真正的程序员。开始真正的系统的接触学习计算机体系的其他的更多元的知识，去体系化的思考和学习计算机和软件体系。
有句话说的好：编程只是一门失传的艺术的再现，这门艺术就是“思考”。我很喜欢去思考或是去观摩别人的思考。每个人的程序和架构都是他思维的体现，优秀的代码总是闪着令人振奋的美感，思维之美。精巧的结构，复杂的算法，灵活的扩展，严谨的安全意识&amp;hellip; 我愿意花费时间去琢磨这些美妙的设计。
博客我曾经写过一段时间，但是觉得长得太丑，然后就转去了Latex。写了很久的Latex的文档，觉得也有点麻烦，尤其最近在写网站相关的内容， 所以又重新考虑了一下博客，然后选了Hexo这个新物种。觉得还不错。
我的博客会写些什么 # 在博客长的好看的情况下我会写很多东西，因为一旦颜值高，就会想写东西，毕竟，金玉其外败絮其中的东西总是很可笑。为了匹配这样的颜值就会想方设法的让内容充实起来。
技术 # 这个是作为程序员的基本素养，学习&amp;ndash;传播，利人利己。我不会在学习的过程中来记录学到的一知半解，因为那样的东西堆积起来没有什么意义，甚至破坏了整体的美感，我会在经过一段时间的学习和思考后来博客中系统的记录下一项技术和事件。但是有的时候我会先编写一个草稿，以免经过的时间过长我会遗漏一些比较基础或是底层的内容，造成技术文章的阅读门槛变高。我本人是不喜欢那些阅读门槛高的文章，尤其不喜欢依靠虚的名词架高理解的门槛。这样做没有什么意义。我在技术的文章中更喜欢做比喻，找一个形象化的例子加以解释。事实上很多技术都是思维的体现，思维总是来源于生活的基本认知，所以都会有形象化的解释方法，便于理解。如果有人能从我的博客中学习到比知识本身更深刻的东西，那才是我的技术文章的真正价值。知识本身只是信息，能传达信息深层的理念和设计，才是文章的作用。
生活 # 作为我的个人博客，难免会写一些我的个人境况，个人对一些技术、事件、人、物的理解和看法。我相信我是站在自己的角度上，无意对外界作出攻击或诋毁，我只是必要的心理活动的表达，更多的时候是写给自己看。他体现了我的人生观、价值观、世界观。如果有的人看了我的文章，我也很乐意分享我的看法，但是，我无意强加我的观点给任何人，一切只是一种表达，他的本意没有向外辐射的意图。我也相信我的个人博客不具备社会影响力，而是新时期技术加成后的一方思维天地。
在这一部分，有可能会涉及情感、工作、爱好等。
新的起点 # 从来没有那么一刻，你说，我就在这一刻长大了，或我就从这一刻从一个男孩变成一个男人。所以也就没有那么一刻就成了新的起点。
是因为技术方向的变更，使得我从，事实上只是较少范围的使用网络，变换到了现在这个几乎离开互联网和文档就工作不下去的状态。我自己也感受到这种微妙的，给我的心理状态带来的变化。
计算机技术就像是一个巨大的游戏机。在这其中你可以设计、使用工具去完成很多有趣的工作，自动化的处理，漂亮的界面，便捷的生活。其实每天都在玩游戏，沉迷在这个巨大的游戏机世界。在玩这些游戏的时候，会获得难得的平静，明明就在工作，其实思维已经在另一个世界。这个世界的一切都是有缘由的，有确定的规则，而这个世界产生的东西还可以加成到现实社会，最主要的是可以用来赚钱，何乐而不为。
我相信在不久的将来，几乎所有人都要具备基础的计算机知识和程序设计能力，因为这是未来社会运行的技术基础。甚至我大胆的认为，当全民都具备程序设计思维的时候，社会的精神状态将发展到一个新的时代。人将具备深刻的规则意识，并深刻认识到自身的渺小，具备合作的意识与能力。换句话说，社会进化的下一个节点，将依靠这样的技术革命进行，而不是靠文化教育。
最后，Hello World！</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/docs/menu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/docs/menu/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/c&#43;&#43;/debug/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/c&#43;&#43;/debug/</guid>
      <description> 启动后台进程，top -H -p 可以查看所有的线程 systemd, deamon pstree -a // 进程树 wait waitpid, // 父进程管理子进程 hup 和 nohup pstack 打印堆栈, 是GDB的简单封装，可以参考一下GDB的使用。 LLDB 和 GDB # LLDB 是LLVM工具链中的一个DEBUG工具，和GDB非常相似。
GDB教程：http://c.biancheng.net/view/8191.html 命令差异详情参考：https://lldb.llvm.org/use/map.html LLDB 速查：https://www.jianshu.com/p/4250e4805bb3 o </description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/c&#43;&#43;/epoll/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/c&#43;&#43;/epoll/</guid>
      <description>Linux事件驱动机制 # 在本学人机交互课程的时候，用到过一个渲染库，由于需要监听很多组件的点击和键盘事件，主函数中有一个巨大的轮询机制，并且当时还是写的单线程的处理，这当然是十分鸡肋的一种处理方式。
Linux中，事件驱动机制，也称为IO多路复用。是内核实现的一种机制，在内核2.6以后的版本中才有。
在Linux中，一切皆文件，文件即IO。文件、socket通信、进程间通信管道pipe都是IO事件，都使用统一的fd文件描述符(File Descriptor)来表示。
文件描述符 # 每个文件描述符会与一个打开的文件相对应 不同的文件描述符也可能指向同一个文件 相同的文件可以被不同的进程打开，也可以在同一个进程被多次打开 系统为维护文件描述符，建立了三个表:
进程级的文件描述符表 系统级的文件描述符表 文件系统的i-node表 每一个进程都会维护一个fd表，一般一个进程允许打开的最大文件数量是1024。
事件驱动机制 # 应用程序层面的事件通知机制总是绕不过轮询这个天坑，轮询带来的问题至少有三个：
不加限制的for循环必然导致cpu跑满 加了sleep的轮询必然导致一定的拥挤，不必要的等待。 大IO事件的阻塞，影响了后续的事件处理。 Linux在内核层面提供了epoll的机制来实现事件的通知，在没有事件的时候阻塞应用进程。做到CPU的0浪费。具体的实现方式在应用端只需要三个函数。
epoll_create， 创建一个fd池 epollctl，向fd池中注册需要监听的事件 epollwait，等待事件唤醒自己 我们先从整体了解一下epoll的内部实现机制。
内核中epoll的实现机制 # Linux系统的一切皆文件的设计中，为文件对象设计了一个poll回调机制，即当某个fd的读写状态满足的时候，即发生poll回调，将fd相关的数据(epitem)塞入一个队列中，并通知操作系统唤醒应用进程。
由此我们可以知道，当应用进程使用epollctl函数注册了事件以后，调用epollwait函数即可进入实际的睡眠状态，直到操作系统接到poll回调将其唤醒。应用线程没有任何浪费的操作。
此处需要注意一点，虽然Linux中一切皆文件，但是并不是所有的文件对象都具有一致的接口，poll接口就不是都支持的，朴素意义（狭义）的文件系统是不支持的。socket是支持的。所以epoll常用于网络IO的处理中。
代码示例 # 关于socket的知识：
[1]. C/C++ socket编程教程之六：使用listen(),accept(),write(),read()函数 [2]. linux C++ socket编程 实例 int socket(int domain, int type, int protocol); 函数对应一切皆文件的open操作；
AF_INET: IPv4 Internet协议
SOCK_STREAM: TCP字节流
int bind(int sockfd, const struct sockaddr * addr, socklen_t addrlen); 分配一个具体的地址给sockfd
listen() 函数让socket处于监听的状态，此时如果有请求进来，就放入缓冲区，直到缓冲区满；中间调用accept() 函数即可以从缓冲区获取一个请求。listen 非阻塞。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/c&#43;&#43;/gccclang/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/c&#43;&#43;/gccclang/</guid>
      <description>GCC 是 GNU旗下的编译工具集。Clang是基于LLVM的一套C/C++、Object-C/C++ 的一款编译器。LLVM则是一个通用后端，用于优化程序、链接程序、生成代码等。
常用的编译选项说明 # </description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/c&#43;&#43;/rand/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/c&#43;&#43;/rand/</guid>
      <description>mt19937 # std::mt19937是伪随机数产生器，用于产生高性能的随机数。 C++11引入。返回值为unsigned int。
mt 是Mersenne Twister算法译为马特赛特旋转演算法，是伪随机数发生器之一，其主要作用是生成伪随机数。发明于1997年。
Mersenne Twister有以下优点：随机性好，在计算机上容易实现，占用内存较少(mt19937的C程式码执行仅需624个字的工作区域)，与其它已使用的伪随机数发生器相比，产生随机数的速度快、周期长，可达到$2^19937-1$，且具有623维均匀分布的性质，对于一般的应用来说，足够大了，序列关联比较小，能通过很多随机性测试。
随机数生成的用法 # 生成5个随机数
#include &amp;lt;iostream&amp;gt; #include &amp;lt;random&amp;gt; using namespace std; int main() { std::mt19937 rng(std::random_device{}()); for (int i = 0; i &amp;lt; 5; i++) { cout &amp;lt;&amp;lt; rng() &amp;lt;&amp;lt; endl; } return 0; } 生成均匀分布的随机数
#include &amp;lt;iostream&amp;gt; #include &amp;lt;random&amp;gt; using namespace std; int main() { std::mt19937 rng(std::random_device{}()); std::uniform_int_distribution&amp;lt;&amp;gt; uni_int(1, 100); for (int i = 0; i &amp;lt; 5; i++) { cout &amp;lt;&amp;lt; uni_int(rng) &amp;lt;&amp;lt; endl; } return 0; } 【参考文献】 # 自研实现 &amp;amp; boost实现：https://blog.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/c&#43;&#43;/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/c&#43;&#43;/readme/</guid>
      <description>虽然简单的C++ 会写了，但是对于一些面向对象的设计依然有较大的漏洞。在这里针对漏洞进行修补。
函数拦截替换：https://cloud.tencent.com/developer/article/1478460 C++ 异步： https://chlorie.github.io/ChloroBlog/posts/2020-10-07/0-async.html </description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/c&#43;&#43;/scopeguard/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/c&#43;&#43;/scopeguard/</guid>
      <description>C++ 原子事务 # 本文所介绍的ScopeGuard方法来自于Andrei-Alexandrescu 和 Pertu-Marginean在2000年发布的一篇文章。其提出了一种更加安全和优美的原子事物处理机制。
原子事务是指，一个或一组动作，要么全做，要么全不做。在代码中，体现为操作失败时的回滚操作。
比较直观的做法是在代码中引入大量的异常处理。这不仅让代码变得更长而且更加不易扩展，当添加一个新的操作将会引入大量的异常处理代码。
另外一种做法则是遵循“构造时创建资源，析构时清除资源”的原则来实现，需要为每一种操作实现一个单独的操作类，大致如下：
class VectorInserter{ public: VectorInserter(std::vector&amp;amp; v, User&amp;amp; u): container_(v), commit_(false) { container_.push_back(&amp;amp;u); } void Commit() throw(){ commit_ = true; } ~VectorInserter() { if (!commit_) container_.pop_back(); } private: std::vector&amp;amp; container_; bool commit_; }; 你可以这样来使用这个操作类：
void User::AddFriend(User&amp;amp; newFriend) { VectorInserter ins(friends_, &amp;amp;newFriend); pDB_-&amp;gt;AddFriend(GetName(), newFriend.GetName()); // Everything went fine, commit the vector insertion ins.Commit(); } 可以看到，在析构函数中，只有当commit没有被调用的时候，才会进行回滚操作。这样做的好处是，避免编写大量的异常处理代码，一旦操作成功就设置commit为true，否则在析构函数中进行回滚操作。
Scope Guard 的实现方法 # 以上的思路缺点在于需要编写大量的操作类。使用Scope Guard可以写出如下简洁的代码。
void User::AddFriend(User&amp;amp; newFriend) { friends_.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/c&#43;&#43;/thread/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/c&#43;&#43;/thread/</guid>
      <description>C++11 提供了线程开发模块，此前都使用pthread，一种C语言的解决方案。但是pthread的使用极其繁琐，导致初初使用pthread在赛场上搞了几个小时还是传不对参数，结果也拿不出来。thread的出现大大的简化了多线程编程。
Thread 的基本用法 # #include&amp;lt;iostream&amp;gt; #include&amp;lt;thread&amp;gt; using namespace std; void say_hi(string s) { cout &amp;lt;&amp;lt; &amp;#34;Hello: &amp;#34; &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl; return ; } int main() { string str = &amp;#34;Paladnix&amp;#34;; thread thr(say_hi, str); // 创建线程thr并启动。传入待执行的函数和参数。 cout &amp;lt;&amp;lt; &amp;#34;Others&amp;#34; &amp;lt;&amp;lt; endl; thr.join(); // 阻塞主函数直至thr线程结束退出。 return 0; } 如果主函数没有调用join(), 则主函数可能在thr线程之前结束，会强制结束子线程。输出的结果如下：
Others libc++abi: terminating Hello: Paladnix [1] 39257 abort ./a.out 也可以使用detach() 函数，将thr函数放到后台运行，与主函数的进程解绑。缺点就是thr的输出结果不会再出现在主进程的终端上。
传入成员函数 # 除了可以使用普通函数作为线程的启动函数，也可以用类的成员函数来构造线程。
class Person { string name; int age; public: Person() {} Person(string name, int age):name(name), age(age){} void say_hi(string hi) { cout &amp;lt;&amp;lt; hi &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; __LINE__ &amp;lt;&amp;lt; &amp;#34;: &amp;#34; &amp;lt;&amp;lt; this_thread::get_id() &amp;lt;&amp;lt; endl; } }; void test_thread_2() { Person a(&amp;#34;Paladnix&amp;#34;, 18); thread thr(&amp;amp;Person::say_hi, a, &amp;#34;Hi&amp;#34;); thr.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/c&#43;&#43;/%E5%86%85%E5%AD%98%E6%A3%80%E6%B5%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/c&#43;&#43;/%E5%86%85%E5%AD%98%E6%A3%80%E6%B5%8B/</guid>
      <description>由于对指针的深度操作，使得C++程序出现内存问题的风险变得很大。常见的内存问题包括：内存泄漏、重复释放、读写未申请的内存地址、悬挂指针、野指针等。
gcc 自带编译检查 # google的sanitizers工具集提供了这部分编译检查工具，gcc 4.9以上支持。
需要安装libasan的库: sudo yum install libasan
常用的gcc参数如下：
开启内存泄露检查功能：-fsanitize=leak 开启地址越界检查功能：-fsanitize=address 开启越界详细错误信息：-fno-omit-frame-pointer 只有跑到的代码才能检测出，未被执行的代码无法检测。
Valgrind 教程 # 参考：https://blog.csdn.net/tissar/article/details/87194737</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/c&#43;&#43;/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/c&#43;&#43;/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</guid>
      <description>C++ 智能指针是对普通指针的一种封装，具体的有四类指针， 而不是一种。按照需求使用指针有助于我们提高代码质量。
所有的智能指针都在追求一个东西：RAII(Resource acquisition is initialization), 资源获取即初始化。
scoped_ptr 作用域指针(boost 库) # 正如其名字指出的那样，在作用域结束的时候即自动释放的指针。
scoped_ptr 指针具有一些特殊的要求。
scoped_ptr是noncopyable的，也就是无法复制。 不能作为容器中的元素，因为无法复制。 example # #include &amp;lt;boost/scoped_ptr.hpp&amp;gt; #include &amp;lt;iostream&amp;gt; struct Shoe { ~Shoe() { std::cout &amp;lt;&amp;lt; &amp;#34;Buckle my shoe\n&amp;#34;; } }; class MyClass { boost::scoped_ptr&amp;lt;int&amp;gt; ptr; public: MyClass() : ptr(new int) { *ptr = 0; } int add_one() { return ++*ptr; } }; int main() { boost::scoped_ptr&amp;lt;Shoe&amp;gt; x(new Shoe); MyClass my_instance; std::cout &amp;lt;&amp;lt; my_instance.add_one() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; std::cout &amp;lt;&amp;lt; my_instance.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/c&#43;&#43;/%E7%81%AB%E7%84%B0%E5%9B%BE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/c&#43;&#43;/%E7%81%AB%E7%84%B0%E5%9B%BE/</guid>
      <description>使用dtrace 分析程序性能 # 运行程序并采样， &amp;lt;main&amp;gt; 替换为待分析的程序
# 采样到程序结束 sudo dtrace -c &amp;#39;./&amp;lt;main&amp;gt;&amp;#39; -o out.stacks -n &amp;#39;profile-997 /execname == &amp;#34;&amp;lt;main&amp;gt;&amp;#34;/ { @[ustack(100)] = count(); }&amp;#39; # 以99Hz的频率, PID是2063的进程为捕获对象, 包括用户态和核心态, 持续60s sudo dtrace -x ustackframes=100 -n &amp;#39;profile-99 /pid == 2063 &amp;amp;&amp;amp; arg1/ { @[ustack()] = count(); } tick-60s { exit(0); }&amp;#39; -o out.user_stacks dtrace 脚本语法参考：https://docs.oracle.com/cd/E24847_01/html/E22192/gbwaz.html#scrolltoc
生成火焰图 # 1. git clone https://github.com/brendangregg/FlameGraph 2. ./stackcollapse.pl &amp;lt;out.stacks&amp;gt; | ./flamegraph.pl &amp;gt; ~/Desktop/perf.svg perf 性能分析 # 直接参考这个吧：http://linux.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/cmake/libs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/cmake/libs/</guid>
      <description>列出所有动态连接库 # ldconfig -p nm 命令 # 查看静态库或动态库定义了哪些函数
nm -n --defined-only xxxx.a nm -g -C --defined-only xxxx.so nm -D xxxx.so 显示hello.a 中的未定义符号，需要和其他对象文件进行链接.
nm -u hello.o 在 ./ 目录下找出哪个库文件定义了close_socket函数.
nm -A ./* 2&amp;gt;/dev/null | grep &amp;#34;T close_socket&amp;#34; objdump 命令 # 查看动态库有哪些符号，包括数据段、导出的函数和引用其他库的函数
objdump -tT xxx.so objdump -x xxx.a 查看动态库依赖项
objdump -x xxx.so | grep &amp;#34;NEEDED&amp;#34; 查看动态符号表
objdump -T xxx.so 假如想知道 xxx.so 中是否导出了符号 yyy
objdump -T xxx.so | grep &amp;#34;yyy&amp;#34; 。 查看动态符号表</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/cmake/makefile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/cmake/makefile/</guid>
      <description>赋值 # = 是最基本的赋值 := 是覆盖之前的值 ?= 是如果没有被赋值过就赋予等号后面的值 += 是添加等号后面的值 注意点 1: 赋值语句的处理顺序 # &amp;ldquo;=&amp;rdquo; 赋值是等到最后才会执行的部分。
x = foo y = $(x) bar x = xyz 在上例中，y的值将会是 xyz bar ，而不是 foo bar 。
“:=”表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。
x := foo y := $(x) bar x := xyz 在上例中，y的值将会是 foo bar ，而不是 xyz bar 了。
基本全局变量 # MAKECMDGOALS, make xxx， 配置的目标：xxx。 OPT, make xxx -Dtest_ut, 后面的选项参数：-Dtest_ut CXXFLAGS, CXX编译器的选项参数，与上面的OPT不同的是，OPT是来自于命令行，FLAGS是传递给编译器 判断选择 # 使用逗号隔开ifneq条件的两个变量，空就是空。 常用的if包括：ifeq, ifneq, ifdef, ifndef</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/cmake/project-struct/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/cmake/project-struct/</guid>
      <description>一个较好的项目结构 # . ├── CMakeLists.txt # CMake项目文件 ├── bootstrap.sh # 一些常用的脚本，如编译、测试、clean ├── build # CMake的临时文件夹 ├── deps # 第三方依赖库 ├── include # 项目的头文件，lib项目中需要暴露出的interface │ └── union_find.hpp ├── log # 测试时的log文件 ├── src │ ├── main.cpp │ └── union_find.cpp └── test └── test-main.cpp 以上所以一个lib库常用的目录结构</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/cmake/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/cmake/readme/</guid>
      <description>CMake Tutorial # 由于不同平台的makefile写法不同，因此需要一个集大成者cmake来实现：“Write once, run everywhere”。cmake主要用于生成makefile，实际的编译组织工作还是由make来实现。
在看了一些C++工程的CMake文件后，结合官网给的文档，对于CMake的设计思想有了一些理解。
核心思想 # CMake的核心思想是通过对构建对象的描述来组织编译。我们的代码核心的构建对象只有两类: 库(lib)、可执行文件(exe)。
因此我们需要了解CMake的两个核心函数：add_library, add_executable。分别对应了两类目标。一个常规的用法如下：
# for lib set(SRC_FILES_LIB xxx.cpp xxx.cpp xxx.cpp ...) addlibrary(&amp;#34;xxx_lib&amp;#34; ${SRC_FILES_LIB}) # for exe set(SRC_FILES_EXEC xxx.cpp xxx.cpp xxx.cpp ...) add_executable(&amp;#34;xxx_exec&amp;#34; ${SRC_FILES_EXEC}) 以上的两个部分，仅仅是简单的描述了目标程序的来源构成
一个简单完整的CMake项目 # # 设定cmake的最小版本 cmake_minimum_required(VERSION 3.21) # 设定允许指定项目的版本 cmake_policy(SET CMP0048 NEW) # 设定项目的&amp;lt;project_name, VERSION&amp;gt; project(codeshark VERSION 1.0.0) # 设定CXX编译标准 set(CMAKE_CXX_STANDARD 11) # 设定CXX编译器的标志 set(CMAKE_CXX_FLAGS_RELEASE &amp;#34;-g -O2 -DNDEBUG&amp;#34;) set(CMAKE_CXX_FLAGS &amp;#34;${CMAKE_CXX_FLAGS} -fPIC -Werror -Wno-format&amp;#34;) # 收集需要开放的头文件 set(SOURCE_HEADS_LIB include/union_find.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/docker/build-image/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/docker/build-image/</guid>
      <description>如何构建自己的镜像 # 当我们需要对外提供一个配置好的基础环境时，我们需要自己打包构建一个image镜像，并发布出去。
大致的流程是：拉取基础镜像、进入镜像并安装依赖、退出容器并打包、上传至中央仓库。
以一个简单的C++调试环境为例 # 选择ubuntu作为基础镜像： docker pull ubuntu 查看是否拉取成功：
docker images 以交互的方式启动容器 docker run -it ubuntu /bin/sh 在容器内部安装g++和gdb程序， 并退出 apt update apt install g++ gdb exit 找到容器并打包 docker container ls -a 可以看到有我们刚刚退出的容器，此时容器已经停止运行，但是容器依然存在。
docker commit -a paladnix -m &amp;#39;simple gdb&amp;#39; cbf13e09376d simple-gdb:1.0 docker images 可以看到我们已经有了两个image：
REPOSITORY TAG IMAGE ID CREATED SIZE simple-gdb 1.0 1a46f7f7599e 16 seconds ago 446MB ubuntu latest ba6acccedd29 8 weeks ago 72.8MB 通过dockerfile来创建镜像 # Dockerfile</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/docker/docker-limit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/docker/docker-limit/</guid>
      <description>运行Docker的容器时，我们往往需要对其进行资源管控，并且会有一些数据传输的需求。
运行 # </description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/docker/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/docker/readme/</guid>
      <description>Docker 的基本理念与设计 # Docker是一种基于cgroup技术的虚拟容器技术，其设计核心思路与Git类似。
镜像与容器 # 镜像(image)可以简单的理解为一个小型的OS或者APP，其好处是可以直接通过docker启动执行，而不需要配置乱七八糟的依赖环境。而容器(container)则是启动后的镜像，同一个镜像可以被多次启动。
启动一个容器以后我们可以使用交互模式启动也可以直接启动某个程序，或者在构建镜像的时候就指定默认启动程序。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/git/git-checkout/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/git/git-checkout/</guid>
      <description> checkout 主要用于 分支的切换 # 以当前(HEAD)分支为基础新建分支
git checkout -b &amp;lt;NEW_BRANCH&amp;gt; 以某一分支为基础新建
git checkout -b 新分支 基础分支 放弃修改 # 放弃未commit的修改
git checkout -- filename 放弃所有未add到暂存区的修改
git checkout . </description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/git/git-log/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/git/git-log/</guid>
      <description>git log 是查看 当前分支 的commit记录的工具。
以树状图的形式查看log记录。可以清晰的看出commit之间的关系。
git log --graph 查看某个文件的历史修改记录
git log -p [FILE_PATH] 如果不带[FILE_PATH]， 则显示commit的整体修改记录。
查看commit的简要修改记录
git log --name-status </description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/git/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/git/readme/</guid>
      <description> Git 的使用主要包含几个方面： # Git 版本控制 Git 协同开发 TODO # rebase合并commit: https://kinboyw.github.io/2019/04/09/Git-%E5%8E%8B%E7%BC%A9%E5%A4%9A%E4%B8%AAcommit%E4%B8%BA%E5%8D%95%E4%B8%AAcommit/ </description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/git/rebase/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/git/rebase/</guid>
      <description>参考文献： https://zhuanlan.zhihu.com/p/34197548
rebase 常用于在分支之间进行合并，但是这个合并比merge要灵活很多。
经常我们会创建新的分支feature来开发新的功能，有的时候我们的新功能要依赖于master上的新特性，或者为了master方便合并分支。我们需要拉去master上最新的代码。我们可以使用
git checkout feature git rebase master 以上的代码，会找到feature与master分支的最近公共祖先LCA结点。然后以master的最新分支为基础重新提交feature上所有LCA之后的修改。得到一个新的提交。宏观上来看，相当于换基。
git pull origin master --rebase 也可以使用这种方式来更新本地分支到最新。
另一种用法 - 压缩本地commit # 在一个分支上开发的时候，经常会有多次commit，主要是为了方便进行回滚操作，但是对于提交来说，子分支带着过多的提交记录并不是一件好事情。因此我们可以将我们的一段线性提交压缩成一个提交。
git rebase -i [start_commit_id] [end_commit_id] 上述代码将会打开一个交互模式的编辑器，罗列start至end之间的所有commit，你可以手动配置每个commit的处理方式。具体的有：
p, pick &amp;lt;提交&amp;gt; = 使用提交 r, reword &amp;lt;提交&amp;gt; = 使用提交，但修改提交说明 e, edit &amp;lt;提交&amp;gt; = 使用提交，进入 shell 以便进行提交修补 s, squash &amp;lt;提交&amp;gt; = 使用提交，但融合到前一个提交 f, fixup &amp;lt;提交&amp;gt; = 类似于 &amp;ldquo;squash&amp;rdquo;，但丢弃提交说明日志 x, exec &amp;lt;命令&amp;gt; = 使用 shell 运行命令（此行剩余部分） b, break = 在此处停止（使用 &amp;lsquo;git rebase &amp;ndash;continue&amp;rsquo; 继续变基） d, drop &amp;lt;提交&amp;gt; = 删除提交 我们可以按照需求定制每个commit的去留。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/git/reset/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/git/reset/</guid>
      <description>reset 用于在仓库的历史版本中穿梭。但是要明确的一点，reset与工作区和暂存区没有半毛钱关系。仅仅是更改了仓库中的记录点。
reset 有三种不同的模式：mixed（默认）、soft、hard
场景1 - 希望删除最近几次的commit记录 # 注意这个场景仅仅是我们对于最近几次的commit记录的删除，而这几次commit所修改的内容是不会撤销的，依然体现在文件中。只是仓库的记录里没有这些改动。这些改动将会随着你的下一次commit重新提交到仓库。
git reset commit_id # 撤销最近一次的commit，修改记录回到工作区 git reset HEAD^ 场景2 - 希望所有的一切回退到某个历史时刻 # 这就需要使用hard模式，可以将历史的commit记录连同文件的修改都扔掉，包括你的工作区、暂存区。一切都回到某个commit的时刻。 慎用
git reset --hard commit_id 场景3 - 希望撤销某个文件的commit # 某个文件被误修改了一个空格，并且被带入了commit，因此要单独撤销某个文件的commit，回到之前的状态。
git reset e32535157ac44 src/server/Processor.hpp 总结 # 通过上面的使用，我们可以发现，mixed就是将所有的变动都放入工作区，hard是将所有的变动删除，soft则是将commit的变动放入暂存区，工作区不动。
Git clean # 清除未被跟踪的文件。
git clean -n // 只查看将被删除的稳健列表，不真正删除。 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/git/summary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/git/summary/</guid>
      <description>Git 基本逻辑 # 几个核心的概念要把握住：工作区、暂存区、仓库</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/idea/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/idea/readme/</guid>
      <description> IDEA 配置远程同步 # 经常使用mac系统进行开发，但是需要项目在Linux系统上进行编译、运行。可以使用JetBrains家的Remote Deployment的功能。
1. 设置远程服务器 # Settings -&amp;gt; Build,Execution,Deployment -&amp;gt; Deployment -&amp;gt; +(添加)
设置SFTP, 使用ssh configuration的更多设置，设置好登陆的ssh-key登陆密钥。
最后一步最重要，选中这个remote deployment，右键，Use As Default
2. 设置自动上传 # 同样在Depolyment下面，找到Upload changed files automatically to the default server 选择Always。
3. 第一次需要手动触发 # 选择项目结构的根目录，然后右键在最下方找到Deployment，选择刚刚设置的Remote Server即可第一次触发自动上传。
4. 日常使用 # 自动上传可以将本地的变化同步到远程server，实时性非常高。 编译的操作直接登陆远程服务器进行编译，一般写成GNU风格的脚本一键编译、测试等。编译产生的文件不会反向回传到本地。 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/java/java-test-powermockito/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/java-test-powermockito/</guid>
      <description>基础测试 # PowerMockito 测试：https://www.cnblogs.com/hunterCecil/p/5721468.html
可以对每个对象以及对象的函数进行虚拟化，拦截填充数据。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/java/jdk/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/jdk/</guid>
      <description>mac 上安装多个jdk和切换 # 参考：https://www.cjavapy.com/article/91/</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/java/maven/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/maven/</guid>
      <description> maven 生命周期 # clean： 清空build的产生的内容和缓存 compile： java编译成class test： 执行test package： 按照pom的约定打包成对应的jar/war等包 install： 将包安装到maven的仓库，一般是本地的中心仓库中。 deploy： 发布包 命令行打包：
mvn clean -U compile package 执行特定的测试(指定的TestClass中的TestFunc)：
mvn -Dtest=xxxTestClass#xxTestFunc test Maven带依赖jar打包 # 默认的jar包打包方式不会将dependency中的jar包打进最终的包里。war包会默认打进去。
如果我们希望实现这样的需求，我们需要使用assembly插件。
&amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-assembly-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;archive&amp;gt; &amp;lt;manifest&amp;gt; &amp;lt;mainClass&amp;gt;org.example.App&amp;lt;/mainClass&amp;gt; &amp;lt;!-- 指定启动类 --&amp;gt; &amp;lt;/manifest&amp;gt; &amp;lt;/archive&amp;gt; &amp;lt;descriptorRefs&amp;gt; &amp;lt;descriptorRef&amp;gt;jar-with-dependencies&amp;lt;/descriptorRef&amp;gt; &amp;lt;/descriptorRefs&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;execution&amp;gt;&amp;lt;!-- 配置执行器 --&amp;gt; &amp;lt;id&amp;gt;make-assembly&amp;lt;/id&amp;gt; &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;&amp;lt;!-- 绑定到package生命周期阶段上 --&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;single&amp;lt;/goal&amp;gt;&amp;lt;!-- 只运行一次 --&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt; &amp;lt;/plugin&amp;gt; 上面配置执行器的部分一直没有成功，需要手动打包才行。使用assembly:single 来代替package
mvn clean compile assembly:single </description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/java/netty-io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/netty-io/</guid>
      <description>Netty是 一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。
前置历史 # 网络的处理分为两类，一类是Blocking IO(BIO, 阻塞式IO)和NO-blocking IO(NIO，非阻塞式IO)。 当然是NIO的CPU利用率要高一些。
关于JAVA 原生NIO的介绍，可以看这一篇文章： https://mp.weixin.qq.com/s/GfV9w2B0mbT7PmeBS45xLw?spm=a2c6h.12873639.0.0.53064a61jNPjIo
非阻塞式IO一般只用于网络IO，其核心的概念有三个：Buffer、channel、selector。
Buffer: 用于缓存网络IO的数据。 Channel: 是与Buffer一起使用的数据传输通道，本身不存储数据。 selector: 选择器可以说是NIO的核心组件，它可以监听通道的状态，来实现异步非阻塞的IO。 但是原生的NIO元素过多，并不方便编写代码，Netty是以NIO为基础的优秀实践。
Netty 使用入门 # 可以参考这篇文章的介绍： https://developer.aliyun.com/article/769587
Netty 在服务端存在两个线程组：BossGroup、WorkerGroup， 前者负责处理链接，后者负责处理业务。有两个大的工厂类：Bootstrap与ServerBootStrap，分别是客户端和服务端的工厂类。
服务端的代码如下： # public class MyServer { public static void main(String[] args) throws Exception { //创建两个线程组 boosGroup、workerGroup EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try { //创建服务端的启动对象，设置参数 ServerBootstrap bootstrap = new ServerBootstrap(); //设置两个线程组boosGroup和workerGroup bootstrap.group(bossGroup, workerGroup) //设置服务端通道实现类型 .channel(NioServerSocketChannel.class) //设置线程队列得到连接个数 .option(ChannelOption.SO_BACKLOG, 128) //设置保持活动连接状态 .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/java/spring-boot/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/spring-boot/</guid>
      <description>百技的Hackathon第一次接触了Spring Boot这个框架，总的来说没有特别难的点，确实是工程拆分的好东西。
Spring boot 与 Spring 简介 # Spring boot 是在spring基础上开发的一套框架，主要是简化了Spring框架复杂的xml配置，简化了依赖的管理，由于我也没有配置过spring框架的xml因此没有体会。
Spring 框架实现了两个主要的设计模式：IOC和AOP， 这是我之前就了解过的，不过并没有对此有任何实践。只记得要对bean类做很多依赖注入的配置，非常繁琐。
Spring boot 的基础使用 # 使用Spring boot可以将web应用直接打包成jar包，内部包含serverlet容器，直接使用:java -jar xxxxx.jar 的方式启动。
使用maven添加依赖(pom.xml)： &amp;lt;project&amp;gt; ... &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.4.5&amp;lt;/version&amp;gt; &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; ... &amp;lt;/project&amp;gt; 重点就是引入了一个parent和两个starter。
创建应用的启动类： package com.xxxxx.xx; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class HelloWorldApplication { public static void main(String[] args) { SpringApplication.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/java/util-concurrent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/java/util-concurrent/</guid>
      <description> java.util.concurrent 概览 # java.util.concurrent 是一个用于编写并行程序的java包， 包括异步Task框架。
参考文献 # [1]. https://www.baeldung.com/java-util-concurrent </description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/rocksdb/rocksdb%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/rocksdb/rocksdb%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/rocksdb/summary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/rocksdb/summary/</guid>
      <description> rocksDB 的逻辑框架 # 作为一个单机版的基于LSM-Tree模式的K-V数据库，具有较好的写入性能。其核心结构包含三个部分：memTable(缓存表), SSTable(持久化表), WAL(命令日志, write ahead log)。
其核心的部分就是写入链路。
write 写入链路 # </description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/self/%E4%B8%A4%E7%B1%BB%E4%BA%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/self/%E4%B8%A4%E7%B1%BB%E4%BA%BA/</guid>
      <description> 有一些道理只流传了一半，举个例子：百善孝为先，论心不论迹，论迹天下无孝子；万恶淫为首，论迹不论心，论人世间无完人。大多数只听到的前一半，所以全都以孝行约束自己的行为。儿子尽孝放弃了自己人生的发展，父母拿着这句话心安理得。一个引申的当下的例子，都说孩子以后只要开心就好。但是如果只拿着这句话，势必会分成三类人：1. 不认同；2. 拿这个空洞的道理安慰自己，并且放弃对孩子的教诲。3. 听从了这个道理，放任自流。但是这个道理应该是孩子以后只要做他自己喜欢的事情就可以，这样就会开心，但是要认真对待自己喜欢的事情，并尽力做出优秀的成果。 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/self/%E7%A4%BE%E4%BC%9A%E5%88%86%E5%B7%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/self/%E7%A4%BE%E4%BC%9A%E5%88%86%E5%B7%A5/</guid>
      <description>工业社会的典型特征就是精细化分工 + 全球协作。其期望达成一个高效的。（还是语音录制比较快）</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/vim/install/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/vim/install/</guid>
      <description> MacOS Monterey 上编译安装vim # 由于部分插件是依赖于py3的，所以需要自己手动编译打开py3的支持。
mac 自带的/usr/bin/python3是阉割版本的，没有python3的开发包。因此我们是一定要自己安装一个python3的。一般使用brew安装即可。
安装完python后，
./configure --with-features=huge\ --enable-multibyte \ --enable-rubyinterp=dynamic \ --with-ruby-command=/usr/bin/ruby \ --enable-pythoninterp=dynamic \ --with-python-config-dir=/usr/lib/python2.7/config \ --enable-python3interp=3.7 \ --with-python3-config-dir=$(python3.7-config --configdir) \ --enable-cscope \ --enable-gui=auto \ --enable-gtk2-check \ --enable-fontset \ --enable-largefile \ --disable-netbeans \ --with-compiledby=&amp;#34;paladnix@outlook.com&amp;#34; \ --enable-fail-if-missing \ --prefix=/usr/local </description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/posts/vim/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/vim/readme/</guid>
      <description> 常用的快捷键与配置 # 映射插入模式下的ESC，避免左手跑很远去按ESC。坏处就是连续输入ff的时候会卡顿。需要等待。
inoremap ff &amp;lt;ESC&amp;gt; 配置YCM与Sulti # </description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/shark/2.28/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/shark/2.28/</guid>
      <description> TODO # 为账户添加权限，细粒度到具体的操作类型。 机器人监听群消息，自动提取TODO消息。接入Task自动提醒。 设置一个enginer页面负责具体文档。 快速进入管理页面的通道。 填表位置使用快速补全的方式优化使用。 logo 引入svg的问题，周末处理，需要自己ps来处理一下。 article 页面的重构工作。 根据用户是否报名过某个课程，是否通过某个lesson来给course卡片定标签。 markdown 渲染文本样式： https://westar.io/blog/rust_web_framework_compare/ eslint + prettier 自动格式处理: https://segmentfault.com/a/1190000020379876 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/shark/algorithm-a/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/shark/algorithm-a/</guid>
      <description>写在前面：
此表是知识点分割表，其中一些是在讲题目的时候讲过，但是这些视频没有被挑出来，没有明确他们的核心作用。
无论是用已有的，还是新录制，需要将这些视频与单独的题解视频区分开。这些视频需要强对应知识点。
Lesson - 1 枚举基础 # 算法复杂度：$O(n)$, $O(n^2), $$O(\sqrt n)$, $O(log_2 n)$等。 (应当放在语言班)一些名词解释：序列、子序列、子段、子串、排列、矩阵、子矩阵、公共序列、上升、非升、区间。 Lesson - 2 枚举优化 # 本节只能就题论题。题解
lesson - 前缀和 # 容斥思想 前缀和的写法与注意事项。 题解 lesson - 二分法 # 二分法模版，算法复杂度计算 二分查找库函数(lower_bound)：数组版，vector版。 二分答案的适用范围、模版写法、复杂度分析。选一个典型题讲解。 lesson - 动态规划 # 以题为中心，解释单向依赖、重叠子问题，最优子结构，无后效性。 以题为中心，解释动态规划的状态，状态转移，初始化。 lesson - 树结构 # 邻接矩阵和邻接表 有根树与无根树：DFS遍历 二叉树的前中后序 lesson - 图 # 有向图与无向图：存储 BFS 遍历图 拓扑序、拓扑序模版 优先队列 # STL中优先队列的使用、注意事项 堆结构的原理 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/shark/atcoder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/shark/atcoder/</guid>
      <description>abc231_d 图论判断是否成链</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/shark/mui-v4-to-v5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/shark/mui-v4-to-v5/</guid>
      <description> 关于MUIv4与v5的差异 # v4 与v5在组件上的差异不大，但是组包方式有重大的更改。同时组件的样式注入改为了emotion库。
目前MUI-v5的包有如下几个：(https://mui.com/zh/guides/understand-mui-packages/)
@mui/material， 核心组件库 @mui/system， @mui/base， 是一个unstyled components， 你可以认为material部分的组件是用styled-engine修饰过的base组件。 @mui/styled-engine， 样式设计引擎emotion的封装 @mui/styled-engine-sc， 样式设计引擎，styled-components的封装，与上一条可以按需使用。 @mui/styles, 即将被删除 emotion是system部分默认使用的样式引擎，即官方推荐使用的是@mui/styled-engine。后面介绍emotion的特性。
传统的JSS-in-CSS，
对于用户来说，我们直接接触的部分其实就是@mui/material， 一切都从这个包里获取。
MUI-v5响应式改造 # 响应式改造主要是按照宽度自动调节：字体大小、间距、宽度、排版方向、可见性等。以此实现在不同大小的设备上都有良好的展示效果。
前端代码规范 # emotion # </description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/shark/test-combination/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/shark/test-combination/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/shark/testing-stl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/shark/testing-stl/</guid>
      <description>以下关于vector的说法正确的是：
vector是容器，一个vector内部可以存储不同类型的数据 vector的长度可以动态变化，并非在声明时固定长度。 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/shark/testing2-4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/shark/testing2-4/</guid>
      <description>测试的核心思路是测试孩子是否具有阅读理解的能力，是否具有理解概念的能力。介绍一些概念，并对概念描述的问题进行判断，是否理解了概念，区别概念中描述的细节差异。这是学习能力的至关重要的基础能力。
有一类特殊的数字叫做“回文数字”， “回文数字” 是从左向右读和从右向左读一摸一样的数字，例如：11、121、7887 都是“回文数字”; 而 12、988、771都不是&amp;quot;回文数字&amp;quot;。
下面不是回文数字的是：
1001 228 11111 1212 学校的食堂里有2种不同的主食：馒头、米饭；有3种不同的蔬菜：土豆、茄子、青菜，小Y同学每一顿饭要选一种主食和一种蔬菜，请问他有多少种不同的搭配方法。例如：米饭+青菜、米饭+土豆是两种不同的搭配方法。
定义一种新的运算符: $\odot$, 运算规则如下：$a \odot b = aab$, 例如：$32 \odot 4 = 32324$， 即将a部分复制2遍和b拼接在一起。请你写下$(33 \odot 54$ 的结果。
4年级
定义一种新的运算符: $\odot$, 运算规则如下：$a \odot b = aab$, 例如：$32 \odot 4 = 32324$， 即将a部分复制2遍和b拼接在一起。请你写下$(2 \odot 1) \odot 5$ 的结果。
找规律
请你找出下面的规律，并写出接下来的数字：$1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, ___$
中位数是指在一些数字中大小处于中间位置的数字。例如：$3，5, 3, 9, 23$ 的中位数是 $5$。请你写出下列数字中的中位数：$10, 2, 13, 12, 2, 5, 1, 99, 75$。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/shark/week_11.8-12/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/shark/week_11.8-12/</guid>
      <description> 11 月第二周Daily Mark # 开发红线（高危，需注明，等回复）：
后台改动API层的参数、方法、路径、返回数据类型等。 后台改动基础架构代码：redisTableBase 前段改动基础组件代码：libs/ 开发报备：
改动已有的文件 开发日报包括 # git log &amp;ndash;state， 中所有修改的文件列表。 结果截图 测试记录 简要说明代码结构和设计逻辑，重用了哪些代码模块，新建了哪些代码模块。 工作会议 # 文档工作大于代码工作。以最小单元行进。
笔试题目 # 以下代码的复杂度是：
for(int i = 0; i &amp;lt; n; i++) { for(int j = 0; j &amp;lt; n; j++) { continue; } } for(int i = 0; i &amp;lt; n; i++) { for(int j = 0; j &amp;lt; n; j++){ break; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://Paladnix.github.io/shark/work-record/2022-q4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/shark/work-record/2022-q4/</guid>
      <description> 第四季度 # 以应用易用性为基础做工作，简化工作操作流程。
优化微信群通知类消息的展示形式，转化为图片形式：代码、题解等。 权限角色系统接入细化到操作级别。 答题的步进式提示。 教师统计类信息快速获取。 用户行为判断、监控、提醒。 同学博客建设。 页面聊天室打通微信，接入自动答疑机器人自动处理。 数据文件提取ID仅提取前缀/后缀，如果没有就默认是大数据。 技术演进 # 网站做区域隔离，对外供给学校、机构等。 </description>
    </item>
    
    <item>
      <title>jupyter-notebook</title>
      <link>https://Paladnix.github.io/_drafts/jupyter-notebook/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/_drafts/jupyter-notebook/</guid>
      <description></description>
    </item>
    
    <item>
      <title>k8s 入门</title>
      <link>https://Paladnix.github.io/posts/docker/k8s/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/docker/k8s/</guid>
      <description>Docker 作为一种资源虚拟化的技术，并不具备资源调度的能力。因此如何管理调度大量的容器，则需要容器编排技术。K8s就是容器编排引擎。
Kubernetes作为一种资源编排引擎，除了预定义的pod资源外，也可以自定义资源，k8s则对这些资源进行调度。包括创建、销毁、变更等。
# </description>
    </item>
    
    <item>
      <title>Tutorial of Latex - The difference with .cls and .sty</title>
      <link>https://Paladnix.github.io/_drafts/latex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/_drafts/latex/</guid>
      <description>总的来说，.cls 和.sty 文件都是用来增强latex功能的。
二者的最主要的区别就是：
.cls 文件使用\documentclass{} 的方式引入 .sty 文件使用\usepackage{} 的方式引入 .cls文件用于确定的描述一个文档的结构，一个文档只能引入一个。.sty 文件是可选的，功能隔离的包，当我们需要某些功能的时候我们就引入。 二者都包含任意的tex或是latex代码，都是文档的功能的补充。</description>
    </item>
    
  </channel>
</rss>
