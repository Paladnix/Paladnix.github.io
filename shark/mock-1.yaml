- description: |
    以下选项中，不是操作系统的是（）

  type: 'SIMPLE'
  options:
    - windows
    - macOS
    - edge
    - centOS
  answer:
    - C
  source: 'CSP-J 模拟卷'
  score: 2

- description: |
    以下问题中无法用BFS算法解决的是（）

  type: 'SIMPLE'
  options:
    - 求解有根树的高度
    - 求解无向图中联通块个数
    - 判断无向图中是否有环
    - 求解一般图中两点间最短路径
  answer:
    - D
  source: 'CSP-J 模拟卷'
  score: 2

- description: |
    以下排序算法中，算法复杂度不稳定的是

  type: 'SIMPLE'
  options:
    - 冒泡排序
    - 快速排序
    - 归并排序
    - 堆排序
  answer:
    - B
  source: 'CSP-J 模拟卷'
  score: 2

- description: |
    对 "CSP-J", "CSP-S", "CSP J", "CSP S", "csp j", "csp s"按照字典序从小到达排序，以下字符串排序的结果正确的是（）

  type: 'SIMPLE'
  options:
    - "csp j", "csp s", "CSP-J", "CSP-S", "CSP J", "CSP S"
    - "csp j", "csp s", "CSP J", "CSP S", "CSP-J", "CSP-S"
    - "CSP-J", "CSP-S", "CSP J", "CSP S", "csp j", "csp s"
    - "CSP J", "CSP S", "CSP-J", "CSP-S", "csp j", "csp s"
  answer:
    - D
  source: 'CSP-J 模拟卷'
  score: 2

- description: |
    以下关于内存堆栈的说法错误的是

  type: 'SIMPLE'
  options:
    - 堆栈空间大小可以在程序中设定，但是CSP比赛中不允许使用
    - 局部变量存储在栈空间，全局变量存储在堆空间
    - 函数调用时传递的引用参数，不会在栈空间内占据任何空间。
    - 栈溢出错误通常会导致程序直接退出。
  answer:
    - C
  source: 'CSP-J 模拟卷'
  score: 2

- description: |
    现代计算机体系的冯诺伊曼架构中5大组成部分不包含（）

  type: 'SIMPLE'
  options:
    - 网络路由器
    - 存储器
    - 运算器
    - 控制器
  answer:
    - A
  source: 'CSP-J 模拟卷'
  score: 2

- description: |
    各位数字均不相同的三位数字([100, 999])有（）个。

  type: 'SIMPLE'
  options:
    - 648
    - 504
    - 720
    - 576
  answer:
    - A
  source: 'CSP-J 模拟卷'
  score: 2

- description: |
    由数字集合{1, 2, 4, 9, 3, 6, 8, 11, 20, 12}构成的二叉查找树中最大和最小的高度分别是（）
    (根节点高度为1)
  type: 'SIMPLE'
  options:
    - 10，2
    - 10，4
    - 9，2
    - 9，4

  answer:
    - B
  source: 'CSP-J 模拟卷'
  score: 2

- description: |
    在一个8行8列的棋盘上，从左上角走到右下角且不穿越左上角到右下角对角线的路径有多少条。
    每一步只能向右或向下走。

  type: 'SIMPLE'
  options:
    - 429
    - 428
    - 858
    - 857
  answer:
    - C
  source: 'CSP-J 模拟卷'
  score: 2

- description: |
    有以下函数
    ```cpp
    solve(n, m) {
      if(n == 1 || m == 1) return 1;
      int s = 0;
      for(int i = 1; i < n; i++) {
        s += i*solve(i, m-1);
      }

      returm s;
    }
    ```
    solve(7, 5) 的结果是多少

  type: 'SIMPLE'
  options:
    - 122
    - 85
    - 90
    - 28
  answer:
    - D
  source: 'CSP-J 模拟卷'
  score: 2

- description: |
    下列关于memset函数的说法错误的是


  type: 'SIMPLE'
  options:
    - 函数的复杂度是O(n), 当传入数组时，n是数组所占字节数。
    - memset 函数可以实现将int类型数组全量初始化为-1
    - mmeset 函数可以实现将int类型数组全量初始化为0x3f
    - memset 可以对非数组的变量进行操作，例如结构体。
  answer:
    - C
  source: 'CSP-J 模拟卷'
  score: 2

- description: |
   与二进制小数 0.1 相等的八进制数是（ ）     

  type: 'SIMPLE'
  options:
    - 0.8
    - 0.4
    - 0.2
    - 0.1
  answer:
    - D
  source: 'CSP-J 模拟卷'
  score: 2

- description: |
    1TB 代表的字节数量是()

  type: 'SIMPLE'
  options:
    - $2^{10}$
    - $2^{20}$
    - $2^{30}$
    - $2^{40}$
  answer:
    - D
  source: 'CSP-J 模拟卷'
  score: 2

- description: |
    若有定义：int a=5；float x=3.6,y=4.5；则表达式`(x/2)+((a%3)*((int)(x+y)%2))``的值是（）

  type: 'SIMPLE'
  options:
    - 1.800000
    - 3.600000
    - 4.500000
    - 2.700000
  answer:
    - A
  source: 'CSP-J 模拟卷'
  score: 2

- description: |
    在一个4*3的网格中随机放三颗棋子（不重叠），要求每行每列最多仅有一颗棋子，放置符合题意的概率为（ ）。

  type: 'SIMPLE'
  options:
    - 6/55
    - 7/110
    - 1/10
    - 4/27

  answer:
    - A
  source: 'CSP-J 模拟卷'
  score: 2


- description: |
    阅读程序
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    
    const int MAXN = 100005;
    
    int a[MAXN], b[MAXN], c[MAXN];
    int n, m, T;
    
    int solve() {
        for(int i = 1; i <= n; i++) {
            b[a[i]] ++;
            T = max(T, a[i]);
        }
        for(int i = 1; i <= T; i++) b[i] += b[i-1];
        for(int i = n; i >= 1; i--) {
            c[i] = b[a[i]]--;
        }
        return c[m];
    }
    
    int main(){
        cin >> n >> m;
        for(int i = 1; i <= n; i++) cin >> a[i];
    
        cout << solve() << endl;
        return 0;
    }
    ```
    当输入的数字均不超过100000时。回答下列问题。

    MAXN 最小可以赋值为100001才不会出现越界错误。


  type: 'SIMPLE'
  options:
    - 正确
    - 错误
  answer:
    - A
  source: 'CSP-J 模拟卷'
  score: 1.5

- description: |
    阅读程序
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    
    const int MAXN = 100005;
    
    int a[MAXN], b[MAXN], c[MAXN];
    int n, m, T;
    
    int solve() {
        for(int i = 1; i <= n; i++) {
            b[a[i]] ++;
            T = max(T, a[i]);
        }
        for(int i = 1; i <= T; i++) b[i] += b[i-1];
        for(int i = n; i >= 1; i--) {
            c[i] = b[a[i]]--;
        }
        return c[m];
    }
    
    int main(){
        cin >> n >> m;
        for(int i = 1; i <= n; i++) cin >> a[i];
    
        cout << solve() << endl;
        return 0;
    }
    ```
    当输入的数字均不超过100000时。回答下列问题。

    输出的结果可能是负数

  type: 'SIMPLE'
  options:
    - 正确
    - 错误
  answer:
    - B
  source: 'CSP-J 模拟卷'
  score: 1.5

- description: |
    阅读程序
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    
    const int MAXN = 100005;
    
    int a[MAXN], b[MAXN], c[MAXN];
    int n, m, T;
    
    int solve() {
        for(int i = 1; i <= n; i++) {
            b[a[i]] ++;
            T = max(T, a[i]);
        }
        for(int i = 1; i <= T; i++) b[i] += b[i-1];
        for(int i = n; i >= 1; i--) {
            c[i] = b[a[i]]--;
        }
        return c[m];
    }
    
    int main(){
        cin >> n >> m;
        for(int i = 1; i <= n; i++) cin >> a[i];
    
        cout << solve() << endl;
        return 0;
    }
    ```
    当输入的数字均不超过100000时。回答下列问题。

    b数组是int类型，存在数据溢出风险，要改为long long类型。


  type: 'SIMPLE'
  options:
    - 正确
    - 错误
  answer:
    - B
  source: 'CSP-J 模拟卷'
  score: 1.5

- description: |
    阅读程序
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    
    const int MAXN = 100005;
    
    int a[MAXN], b[MAXN], c[MAXN];
    int n, m, T;
    
    int solve() {
        for(int i = 1; i <= n; i++) {
            b[a[i]] ++;
            T = max(T, a[i]);
        }
        for(int i = 1; i <= T; i++) b[i] += b[i-1];
        for(int i = n; i >= 1; i--) {
            c[i] = b[a[i]]--;
        }
        return c[m];
    }
    
    int main(){
        cin >> n >> m;
        for(int i = 1; i <= n; i++) cin >> a[i];
    
        cout << solve() << endl;
        return 0;
    }
    ```

    当输入的数字均不超过100000时。回答下列问题。

    当输入“7 4 9 2 1 2 3 1 5”时，输出


  type: 'SIMPLE'
  options:
    - 0
    - -1
    - 4
    - 2
  answer:
    - C
  source: 'CSP-J 模拟卷'
  score: 3

- description: |
    阅读程序
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    
    const int MAXN = 100005;
    
    int a[MAXN], b[MAXN], c[MAXN];
    int n, m, T;
    
    int solve() {
        for(int i = 1; i <= n; i++) {
            b[a[i]] ++;
            T = max(T, a[i]);
        }
        for(int i = 1; i <= T; i++) b[i] += b[i-1];
        for(int i = n; i >= 1; i--) {
            c[i] = b[a[i]]--;
        }
        return c[m];
    }
    
    int main(){
        cin >> n >> m;
        for(int i = 1; i <= n; i++) cin >> a[i];
    
        cout << solve() << endl;
        return 0;
    }
    ```
    当输入的数字均不超过100000时。回答下列问题。

    当输入n=10，m=3时。下列a数组作为输入，输出的结果最大的是

  type: 'SIMPLE'
  options:
    - 8 0 9 1 4 2 4 2 2 3
    - 1,2,2,4,3,9,1,2,8,10
    - 1,1,1,1,1,1,1,1,1,1
    - 2 4 2 2 4 8 0 9 1 4
  answer:
    - A
  source: 'CSP-J 模拟卷'
  score: 3

- description: |
    阅读程序
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    
    string Manachar(string s) {
    	string t = "$#";
    	for(int i=0; i < s.size(); ++i) t+=s[i], t+='#';
    
    	vector<int> p(t.size(),0);
    
    	int mx = 0, id = 0, resLen = 0, resCenter = 0;
    	for(int i = 1; i < t.size(); ++i) {
    		p[i] = mx > i ? min( p[2*id-i] , mx-i ) : 1 ;
    		while( t[i+p[i]] ) ++p[i];x
    		if( mx < i+p[i] ) {
    			mx = i+p[i];
    			id = i;
    		}
    		if( resLen < p[i] ) {
    			resLen = p[i];
    			resCenter = i;
    		}
    	}
    	return s.substr( (resCenter-resLen)/2 , resLen-1 );
    }
    
    int main(){
        string s;
        cin >> s;
        cout << Manachar(s) << endl;
    
        return 0;
    }
    ```
    第4行参数s和主函数中声明的s指向内存中相同的一段地址。

  type: 'SIMPLE'
  options:
    - 正确
    - 错误
  answer:
    - B
  source: 'CSP-J 模拟卷'
  score: 1.5

- description: |
    阅读程序
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    
    string Manachar(string s) {
    	string t = "$#";
    	for(int i=0; i < s.size(); ++i) t+=s[i], t+='#';
    
    	vector<int> p(t.size(),0);
    
    	int mx = 0, id = 0, resLen = 0, resCenter = 0;
    	for(int i = 1; i < t.size(); ++i) {
    		p[i] = mx > i ? min( p[2*id-i] , mx-i ) : 1 ;
    		while( t[i+p[i]] ) ++p[i];x
    		if( mx < i+p[i] ) {
    			mx = i+p[i];
    			id = i;
    		}
    		if( resLen < p[i] ) {
    			resLen = p[i];
    			resCenter = i;
    		}
    	}
    	return s.substr( (resCenter-resLen)/2 , resLen-1 );
    }
    
    int main(){
        string s;
        cin >> s;
        cout << Manachar(s) << endl;
    
        return 0;
    }
    ```
    变量p存储在内存的栈空间中。

  type: 'SIMPLE'
  options:
    - 正确
    - 错误
  answer:
    - A
  source: 'CSP-J 模拟卷'
  score: 1.5

- description: |
    阅读程序
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    
    string Manachar(string s) {
    	string t = "$#";
    	for(int i=0; i < s.size(); ++i) t+=s[i], t+='#';
    
    	vector<int> p(t.size(),0);
    
    	int mx = 0, id = 0, resLen = 0, resCenter = 0;
    	for(int i = 1; i < t.size(); ++i) {
    		p[i] = mx > i ? min( p[2*id-i] , mx-i ) : 1 ;
    		while( t[i+p[i]] ) ++p[i];x
    		if( mx < i+p[i] ) {
    			mx = i+p[i];
    			id = i;
    		}
    		if( resLen < p[i] ) {
    			resLen = p[i];
    			resCenter = i;
    		}
    	}
    	return s.substr( (resCenter-resLen)/2 , resLen-1 );
    }
    
    int main(){
        string s;
        cin >> s;
        cout << Manachar(s) << endl;
    
        return 0;
    }
    ```

    输出的字符串长度一定大于等于3

  type: 'SIMPLE'
  options:
    - 正确
    - 错误
  answer:
    - B
  source: 'CSP-J 模拟卷'
  score: 1.5

- description: |
    阅读程序
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    
    string Manachar(string s) {
    	string t = "$#";
    	for(int i=0; i < s.size(); ++i) t+=s[i], t+='#';
    
    	vector<int> p(t.size(),0);
    
    	int mx = 0, id = 0, resLen = 0, resCenter = 0;
    	for(int i = 1; i < t.size(); ++i) {
    		p[i] = mx > i ? min( p[2 * id-i] , mx-i) : 1 ;
    		while( t[i+p[i]] ) ++p[i];x
    		if( mx < i+p[i] ) {
    			mx = i+p[i];
    			id = i;
    		}
    		if( resLen < p[i] ) {
    			resLen = p[i];
    			resCenter = i;
    		}
    	}
    	return s.substr( (resCenter-resLen)/2 , resLen-1 );
    }
    
    int main(){
        string s;
        cin >> s;
        cout << Manachar(s) << endl;
    
        return 0;
    }
    ```
    Manachar 算法的复杂度是

  type: 'SIMPLE'
  options:
    - $O(n)$
    - $O(nlogn)$
    - $O(n^2)$
    - $O(n\sqrt(n))$
  answer:
    - A
  source: 'CSP-J 模拟卷'
  score: 3

- description: |
    阅读程序
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    
    string Manachar(string s) {
    	string t = "$#";
    	for(int i=0; i < s.size(); ++i) t+=s[i], t+='#';
    
    	vector<int> p(t.size(),0);
    
    	int mx = 0, id = 0, resLen = 0, resCenter = 0;
    	for(int i = 1; i < t.size(); ++i) {
    		p[i] = mx > i ? min( p[2*id-i] , mx-i ) : 1 ;
    		while( t[i+p[i]] ) ++p[i];x
    		if( mx < i+p[i] ) {
    			mx = i+p[i];
    			id = i;
    		}
    		if( resLen < p[i] ) {
    			resLen = p[i];
    			resCenter = i;
    		}
    	}
    	return s.substr( (resCenter-resLen)/2 , resLen-1 );
    }
    
    int main(){
        string s;
        cin >> s;
        cout << Manachar(s) << endl;
    
        return 0;
    }
    ```
    输入"manachar" 输出的结果是？

  type: 'SIMPLE'
  options:
    - manachar
    - mana
    - aaa
    - ana
  answer:
    - D
  source: 'CSP-J 模拟卷'
  score: 3

- description: |
    阅读程序
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    
    string Manachar(string s) {
    	string t = "$#";
    	for(int i=0; i < s.size(); ++i) t+=s[i], t+='#';
    
    	vector<int> p(t.size(),0);
    
    	int mx = 0, id = 0, resLen = 0, resCenter = 0;
    	for(int i = 1; i < t.size(); ++i) {
    		p[i] = mx > i ? min( p[2*id-i] , mx-i ) : 1 ;
    		while( t[i+p[i]] ) ++p[i];x
    		if( mx < i+p[i] ) {
    			mx = i+p[i];
    			id = i;
    		}
    		if( resLen < p[i] ) {
    			resLen = p[i];
    			resCenter = i;
    		}
    	}
    	return s.substr( (resCenter-resLen)/2 , resLen-1 );
    }
    
    int main(){
        string s;
        cin >> s;
        cout << Manachar(s) << endl;
    
        return 0;
    }
    ```
    输入"ccfcfc cfc" 输出的结果字符串长度是？

  type: 'SIMPLE'
  options:
    - 3
    - 5
    - 6
    - 7
  answer:
    - D
  source: 'CSP-J 模拟卷'
  score: 3

- description: |
    阅读程序《求解DAG中的最长路径》：
  
    ```cpp
    #include <bits/stdc++.h>
  
    using namespace std;
    
    const int MAXN = 100;
    const int MAXM = 10000;
    
    struct Node {
        int v, w, nxt;
        Node(){}
    
        Node(int v, int w, int nxt):v(v), w(w), nxt(nxt){}
    }G[MAXM << 1];
    
    int head[MAXN+1], tot = 0;
    int deg[MAXN+1], dp[MAXN+1];
    
    void init() {
        memset(head, 0xff, sizeof(head));
        tot = 0;
    }
    
    void add(int u, int v, int w) {
        G[tot] = Node(v, w, head[u]);
        head[u] = tot++;
    }
    
    
    int LongestPath(int n) {
        queue<int> Q;
        int cnt = 0;
        for(int i = 1; i <= n; i++) {
            if(deg[i] == 0) Q.push(i), cnt++;
        }
        while(!Q.empty()) {
            int u = Q.front();
            Q.pop();
            for(int i = head[u]; ~i; i = G[i].nxt) {
                int v = G[i].v;
                dp[v] = max(dp[v], dp[u] + G[i].w);
                deg[v] --;
                if(deg[v] == 0) {
                    Q.push(v);
                    cnt++;
                }
            }
        }
        if(cnt == n) return 1;
        else return 0;
    }
    
    int main(){
        init();
        int n, m;
        cin >> n >> m;
    
        for(int i = 0, u, v, w; i < m; i++) {
            cin >> u >> v >> w;
            add(u, v, w);
            deg[v]++;
        }
    
        int ret = LongestPath(n);
        if(ret) {
            int ans = 0;
            for(int i = 1; i <= n; i++) {
                ans = max(ans, dp[i]);
            }
            cout << ans << endl;
        } else {
            cout << "Not DAG." << endl;
        }
    
        return 0;
    }
  
  
    ```
    如果不调用init() 函数，程序将出现越界错误。

  type: 'SIMPLE'
  options:
    - 正确
    - 错误
  answer:
    - B
  source: 'CSP-J 模拟卷'
  score: 1.5

- description: |
    阅读程序《求解DAG中的最长路径》：
  
    ```cpp
    #include <bits/stdc++.h>
  
    using namespace std;
    
    const int MAXN = 100;
    const int MAXM = 10000;
    
    struct Node {
        int v, w, nxt;
        Node(){}
    
        Node(int v, int w, int nxt):v(v), w(w), nxt(nxt){}
    }G[MAXM << 1];
    
    int head[MAXN+1], tot = 0;
    int deg[MAXN+1], dp[MAXN+1];
    
    void init() {
        memset(head, 0xff, sizeof(head));
        tot = 0;
    }
    
    void add(int u, int v, int w) {
        G[tot] = Node(v, w, head[u]);
        head[u] = tot++;
    }
    
    
    int LongestPath(int n) {
        queue<int> Q;
        int cnt = 0;
        for(int i = 1; i <= n; i++) {
            if(deg[i] == 0) Q.push(i), cnt++;
        }
        while(!Q.empty()) {
            int u = Q.front();
            Q.pop();
            for(int i = head[u]; ~i; i = G[i].nxt) {
                int v = G[i].v;
                dp[v] = max(dp[v], dp[u] + G[i].w);
                deg[v] --;
                if(deg[v] == 0) {
                    Q.push(v);
                    cnt++;
                }
            }
        }
        if(cnt == n) return 1;
        else return 0;
    }
    
    int main(){
        init();
        int n, m;
        cin >> n >> m;
    
        for(int i = 0, u, v, w; i < m; i++) {
            cin >> u >> v >> w;
            add(u, v, w);
            deg[v]++;
        }
    
        int ret = LongestPath(n);
        if(ret) {
            int ans = 0;
            for(int i = 1; i <= n; i++) {
                ans = max(ans, dp[i]);
            }
            cout << ans << endl;
        } else {
            cout << "Not DAG." << endl;
        }
    
        return 0;
    }
  
    ```
    输入的数据中w如果存在负数，程序的结果不一定错误。

  type: 'SIMPLE'
  options:
    - 正确
    - 错误
  answer:
    - A
  source: 'CSP-J 模拟卷'
  score: 1.5

- description: |
    阅读程序《求解DAG中的最长路径》：
  
    ```cpp
    #include <bits/stdc++.h>
  
    using namespace std;
    
    const int MAXN = 100;
    const int MAXM = 10000;
    
    struct Node {
        int v, w, nxt;
        Node(){}
    
        Node(int v, int w, int nxt):v(v), w(w), nxt(nxt){}
    }G[MAXM << 1];
    
    int head[MAXN+1], tot = 0;
    int deg[MAXN+1], dp[MAXN+1];
    
    void init() {
        memset(head, 0xff, sizeof(head));
        tot = 0;
    }
    
    void add(int u, int v, int w) {
        G[tot] = Node(v, w, head[u]);
        head[u] = tot++;
    }
    
    
    int LongestPath(int n) {
        queue<int> Q;
        int cnt = 0;
        for(int i = 1; i <= n; i++) {
            if(deg[i] == 0) Q.push(i), cnt++;
        }
        while(!Q.empty()) {
            int u = Q.front();
            Q.pop();
            for(int i = head[u]; ~i; i = G[i].nxt) {
                int v = G[i].v;
                dp[v] = max(dp[v], dp[u] + G[i].w);
                deg[v] --;
                if(deg[v] == 0) {
                    Q.push(v);
                    cnt++;
                }
            }
        }
        if(cnt == n) return 1;
        else return 0;
    }
    
    int main(){
        init();
        int n, m;
        cin >> n >> m;
    
        for(int i = 0, u, v, w; i < m; i++) {
            cin >> u >> v >> w;
            add(u, v, w);
            deg[v]++;
        }
    
        int ret = LongestPath(n);
        if(ret) {
            int ans = 0;
            for(int i = 1; i <= n; i++) {
                ans = max(ans, dp[i]);
            }
            cout << ans << endl;
        } else {
            cout << "Not DAG." << endl;
        }
    
        return 0;
    }
  
    ```
    将第6行的`10000`替换成`1e4`，程序会编译错误。

  type: 'SIMPLE'
  options:
    - 正确
    - 错误
  answer:
    - B
  source: 'CSP-J 模拟卷'
  score: 1.5

- description: |
    阅读程序《求解DAG中的最长路径》：
  
    ```cpp
    #include <bits/stdc++.h>
  
    using namespace std;
    
    const int MAXN = 100;
    const int MAXM = 10000;
    
    struct Node {
        int v, w, nxt;
        Node(){}
    
        Node(int v, int w, int nxt):v(v), w(w), nxt(nxt){}
    }G[MAXM << 1];
    
    int head[MAXN+1], tot = 0;
    int deg[MAXN+1], dp[MAXN+1];
    
    void init() {
        memset(head, 0xff, sizeof(head));
        tot = 0;
    }
    
    void add(int u, int v, int w) {
        G[tot] = Node(v, w, head[u]);
        head[u] = tot++;
    }
    
    
    int LongestPath(int n) {
        queue<int> Q;
        int cnt = 0;
        for(int i = 1; i <= n; i++) {
            if(deg[i] == 0) Q.push(i), cnt++;
        }
        while(!Q.empty()) {
            int u = Q.front();
            Q.pop();
            for(int i = head[u]; ~i; i = G[i].nxt) {
                int v = G[i].v;
                dp[v] = max(dp[v], dp[u] + G[i].w);
                deg[v] --;
                if(deg[v] == 0) {
                    Q.push(v);
                    cnt++;
                }
            }
        }
        if(cnt == n) return 1;
        else return 0;
    }
    
    int main(){
        init();
        int n, m;
        cin >> n >> m;
    
        for(int i = 0, u, v, w; i < m; i++) {
            cin >> u >> v >> w;
            add(u, v, w);
            deg[v]++;
        }
    
        int ret = LongestPath(n);
        if(ret) {
            int ans = 0;
            for(int i = 1; i <= n; i++) {
                ans = max(ans, dp[i]);
            }
            cout << ans << endl;
        } else {
            cout << "Not DAG." << endl;
        }
    
        return 0;
    }
  
    ```

    程序执行结束后，deg数组将全部变为0

  type: 'SIMPLE'
  options:
    - 正确
    - 错误
  answer:
    - B
  source: 'CSP-J 模拟卷'
  score: 1.5



- description: |
    阅读程序《求解DAG中的最长路径》：
  
    ```cpp
    #include <bits/stdc++.h>
  
    using namespace std;
    
    const int MAXN = 100;
    const int MAXM = 10000;
    
    struct Node {
        int v, w, nxt;
        Node(){}
    
        Node(int v, int w, int nxt):v(v), w(w), nxt(nxt){}
    }G[MAXM << 1];
    
    int head[MAXN+1], tot = 0;
    int deg[MAXN+1], dp[MAXN+1];
    
    void init() {
        memset(head, 0xff, sizeof(head));
        tot = 0;
    }
    
    void add(int u, int v, int w) {
        G[tot] = Node(v, w, head[u]);
        head[u] = tot++;
    }
    
    
    int LongestPath(int n) {
        queue<int> Q;
        int cnt = 0;
        for(int i = 1; i <= n; i++) {
            if(deg[i] == 0) Q.push(i), cnt++;
        }
        while(!Q.empty()) {
            int u = Q.front();
            Q.pop();
            for(int i = head[u]; ~i; i = G[i].nxt) {
                int v = G[i].v;
                dp[v] = max(dp[v], dp[u] + G[i].w);
                deg[v] --;
                if(deg[v] == 0) {
                    Q.push(v);
                    cnt++;
                }
            }
        }
        if(cnt == n) return 1;
        else return 0;
    }
    
    int main(){
        init();
        int n, m;
        cin >> n >> m;
    
        for(int i = 0, u, v, w; i < m; i++) {
            cin >> u >> v >> w;
            add(u, v, w);
            deg[v]++;
        }
    
        int ret = LongestPath(n);
        if(ret) {
            int ans = 0;
            for(int i = 1; i <= n; i++) {
                ans = max(ans, dp[i]);
            }
            cout << ans << endl;
        } else {
            cout << "Not DAG." << endl;
        }
    
        return 0;
    }
  
    ```

    init() 函数执行结束后，head[0] 的值是（）

  type: 'SIMPLE'
  options:
    - 0
    - 0xff
    - 256
    - -1
  answer:
    - D
  source: 'CSP-J 模拟卷'
  score: 3


- description: |
    阅读程序《求解DAG中的最长路径》：
  
    ```cpp
    #include <bits/stdc++.h>
  
    using namespace std;
    
    const int MAXN = 100;
    const int MAXM = 10000;
    
    struct Node {
        int v, w, nxt;
        Node(){}
    
        Node(int v, int w, int nxt):v(v), w(w), nxt(nxt){}
    }G[MAXM << 1];
    
    int head[MAXN+1], tot = 0;
    int deg[MAXN+1], dp[MAXN+1];
    
    void init() {
        memset(head, 0xff, sizeof(head));
        tot = 0;
    }
    
    void add(int u, int v, int w) {
        G[tot] = Node(v, w, head[u]);
        head[u] = tot++;
    }
    
    
    int LongestPath(int n) {
        queue<int> Q;
        int cnt = 0;
        for(int i = 1; i <= n; i++) {
            if(deg[i] == 0) Q.push(i), cnt++;
        }
        while(!Q.empty()) {
            int u = Q.front();
            Q.pop();
            for(int i = head[u]; ~i; i = G[i].nxt) {
                int v = G[i].v;
                dp[v] = max(dp[v], dp[u] + G[i].w);
                deg[v] --;
                if(deg[v] == 0) {
                    Q.push(v);
                    cnt++;
                }
            }
        }
        if(cnt == n) return 1;
        else return 0;
    }
    
    int main(){
        init();
        int n, m;
        cin >> n >> m;
    
        for(int i = 0, u, v, w; i < m; i++) {
            cin >> u >> v >> w;
            add(u, v, w);
            deg[v]++;
        }
    
        int ret = LongestPath(n);
        if(ret) {
            int ans = 0;
            for(int i = 1; i <= n; i++) {
                ans = max(ans, dp[i]);
            }
            cout << ans << endl;
        } else {
            cout << "Not DAG." << endl;
        }
    
        return 0;
    }
  
    ```

    当输入的数据是：`4 5 1 2 1 1 3 2 1 4 1 2 4 1 3 4 1` 则输出的结果是()

  type: 'SIMPLE'
  options:
    - 1
    - 2
    - 3
    - "Not DAG."
  answer:
    - C
  source: 'CSP-J 模拟卷'
  score: 3



- description: |
    (最大子段平均数) 给定一个数组a，由n个整数构成。给定一个数字m，保证$1\leq m \leq n$，请你找出一段长度不小于m，且平均数最大的一段。输出这个平均数，保留整数。
  
    提示：代码的解题思路为：
    1. 二分答案，检验数组中是否存在一段符合条件的子段。
    2. 检验是否存在符合条件的子段使用动态规划的方法。通过先减去平均值，转换为寻找一段长度大于等于m且和为正数的子段。
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int MAXN = 10005;
    int a[MAXN];
    double b[MAXN], c[MAXN], dp[MAXN];
    int n, m;
  
    bool check(double x) {
        for(int i = 1; i <= n; i++) {
            b[i] = ____(1)_____;
            c[i] = c[i-1] + b[i];
        }
    
        for(int i = 1; i <= m; i++) dp[m] += b[i];
        if(____(2)_____) return true;
        for(int i = m+1; i <= n; i++) {
            dp[i] = max(b[i] + dp[i-1], _____(3)_____);
            if(dp[i] >= 0) return true;
        }
        return false;
    }
    
    int main(){
        cin >> n >> m;
        for(int i = 1; i <= n; i++) cin >> a[i];
        
        double L = 0, R = 1e18;
        while(abs(L-R) >= 1e-8) {
            double mid = ____(4)______;
            if(check(mid)) {
                _____(5)______;
            } else {
                ______(6)_____;
            }
        }
    
        cout << L << endl;
    
        return 0;
    }
    
    ```

    (1) 处应填

  type: 'SIMPLE'
  options:
    - a[i] - x
    - a[i] - mid
    - a[i] - a[i-1];
    - a[i];

  answer:
    - A
  source: 'CSP-J 模拟卷'
  score: 3

- description: |
    (最大子段平均数) 给定一个数组a，由n个整数构成。给定一个数字m，保证$1\leq m \leq n$，请你找出一段长度不小于m，且平均数最大的一段。输出这个平均数，保留整数。
  
    提示：代码的解题思路为：
    1. 二分答案，检验数组中是否存在一段符合条件的子段。
    2. 检验是否存在符合条件的子段使用动态规划的方法。通过先减去平均值，转换为寻找一段长度大于等于m且和为正数的子段。
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int MAXN = 10005;
    int a[MAXN];
    double b[MAXN], c[MAXN], dp[MAXN];
    int n, m;
  
    bool check(double x) {
        for(int i = 1; i <= n; i++) {
            b[i] = ____(1)_____;
            c[i] = c[i-1] + b[i];
        }
    
        for(int i = 1; i <= m; i++) dp[m] += b[i];
        if(____(2)_____) return true;
        for(int i = m+1; i <= n; i++) {
            dp[i] = max(b[i] + dp[i-1], _____(3)_____);
            if(dp[i] >= 0) return true;
        }
        return false;
    }
    
    int main(){
        cin >> n >> m;
        for(int i = 1; i <= n; i++) cin >> a[i];
        
        double L = 0, R = 1e18;
        while(abs(L-R) >= 1e-8) {
            double mid = ____(4)______;
            if(check(mid)) {
                _____(5)______;
            } else {
                ______(6)_____;
            }
        }
    
        cout << L << endl;
    
        return 0;
    }
    
    ```

    (2) 处应填

  type: 'SIMPLE'
  options:
    - n == m && dp[m] > 0
    - n == m && dp[m] >= 0
    - dp[m] > 0
    - dp[m] >= 0
  answer:
    - D
  source: 'CSP-J 模拟卷'
  score: 3

- description: |
    (最大子段平均数) 给定一个数组a，由n个整数构成。给定一个数字m，保证$1\leq m \leq n$，请你找出一段长度不小于m，且平均数最大的一段。输出这个平均数，保留整数。
  
    提示：代码的解题思路为：
    1. 二分答案，检验数组中是否存在一段符合条件的子段。
    2. 检验是否存在符合条件的子段使用动态规划的方法。通过先减去平均值，转换为寻找一段长度大于等于m且和为正数的子段。
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int MAXN = 10005;
    int a[MAXN];
    double b[MAXN], c[MAXN], dp[MAXN];
    int n, m;
  
    bool check(double x) {
        for(int i = 1; i <= n; i++) {
            b[i] = ____(1)_____;
            c[i] = c[i-1] + b[i];
        }
    
        for(int i = 1; i <= m; i++) dp[m] += b[i];
        if(____(2)_____) return true;
        for(int i = m+1; i <= n; i++) {
            dp[i] = max(b[i] + dp[i-1], _____(3)_____);
            if(dp[i] >= 0) return true;
        }
        return false;
    }
    
    int main(){
        cin >> n >> m;
        for(int i = 1; i <= n; i++) cin >> a[i];
        
        double L = 0, R = 1e18;
        while(abs(L-R) >= 1e-8) {
            double mid = ____(4)______;
            if(check(mid)) {
                _____(5)______;
            } else {
                ______(6)_____;
            }
        }
    
        cout << L << endl;
    
        return 0;
    }
    
    ```

    (3) 处应填

  type: 'SIMPLE'
  options:
    - dp[i-1] 
    - c[i] + dp[i-1]
    - c[i] - c[i-m]
    - dp[i]
  answer:
    - C
  source: 'CSP-J 模拟卷'
  score: 3

- description: |
    (最大子段平均数) 给定一个数组a，由n个整数构成。给定一个数字m，保证$1\leq m \leq n$，请你找出一段长度不小于m，且平均数最大的一段。输出这个平均数，保留整数。
  
    提示：代码的解题思路为：
    1. 二分答案，检验数组中是否存在一段符合条件的子段。
    2. 检验是否存在符合条件的子段使用动态规划的方法。通过先减去平均值，转换为寻找一段长度大于等于m且和为正数的子段。
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int MAXN = 10005;
    int a[MAXN];
    double b[MAXN], c[MAXN], dp[MAXN];
    int n, m;
  
    bool check(double x) {
        for(int i = 1; i <= n; i++) {
            b[i] = ____(1)_____;
            c[i] = c[i-1] + b[i];
        }
    
        for(int i = 1; i <= m; i++) dp[m] += b[i];
        if(____(2)_____) return true;
        for(int i = m+1; i <= n; i++) {
            dp[i] = max(b[i] + dp[i-1], _____(3)_____);
            if(dp[i] >= 0) return true;
        }
        return false;
    }
    
    int main(){
        cin >> n >> m;
        for(int i = 1; i <= n; i++) cin >> a[i];
        
        double L = 0, R = 1e18;
        while(abs(L-R) >= 1e-8) {
            double mid = ____(4)______;
            if(check(mid)) {
                _____(5)______;
            } else {
                ______(6)_____;
            }
        }
    
        cout << L << endl;
    
        return 0;
    }
    
    ```

    (4) 处应填

  type: 'SIMPLE'
  options:
    - L + (R - L) >> 1
    - (L + R) >> 1
    - L/2 + R/2
    - abs(L-R)/2
  answer:
    - C
  source: 'CSP-J 模拟卷'
  score: 3

- description: |
    (最大子段平均数) 给定一个数组a，由n个整数构成。给定一个数字m，保证$1\leq m \leq n$，请你找出一段长度不小于m，且平均数最大的一段。输出这个平均数，保留整数。
  
    提示：代码的解题思路为：
    1. 二分答案，检验数组中是否存在一段符合条件的子段。
    2. 检验是否存在符合条件的子段使用动态规划的方法。通过先减去平均值，转换为寻找一段长度大于等于m且和为正数的子段。
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int MAXN = 10005;
    int a[MAXN];
    double b[MAXN], c[MAXN], dp[MAXN];
    int n, m;
  
    bool check(double x) {
        for(int i = 1; i <= n; i++) {
            b[i] = ____(1)_____;
            c[i] = c[i-1] + b[i];
        }
    
        for(int i = 1; i <= m; i++) dp[m] += b[i];
        if(____(2)_____) return true;
        for(int i = m+1; i <= n; i++) {
            dp[i] = max(b[i] + dp[i-1], _____(3)_____);
            if(dp[i] >= 0) return true;
        }
        return false;
    }
    
    int main(){
        cin >> n >> m;
        for(int i = 1; i <= n; i++) cin >> a[i];
        
        double L = 0, R = 1e18;
        while(abs(L-R) >= 1e-8) {
            double mid = ____(4)______;
            if(check(mid)) {
                _____(5)______;
            } else {
                ______(6)_____;
            }
        }
    
        cout << L << endl;
    
        return 0;
    }
    
    ```

    (5) 处应填

  type: 'SIMPLE'
  options:
    - L = mid 
    - R = mid
    - L = mid + 1
    - R = mid - 1
  answer:
    - A
  source: 'CSP-J 模拟卷'
  score: 3

- description: |
    (最大子段平均数) 给定一个数组a，由n个整数构成。给定一个数字m，保证$1\leq m \leq n$，请你找出一段长度不小于m，且平均数最大的一段。输出这个平均数，保留整数。
  
    提示：代码的解题思路为：
    1. 二分答案，检验数组中是否存在一段符合条件的子段。
    2. 检验是否存在符合条件的子段使用动态规划的方法。通过先减去平均值，转换为寻找一段长度大于等于m且和为正数的子段。
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int MAXN = 10005;
    int a[MAXN];
    double b[MAXN], c[MAXN], dp[MAXN];
    int n, m;
  
    bool check(double x) {
        for(int i = 1; i <= n; i++) {
            b[i] = ____(1)_____;
            c[i] = c[i-1] + b[i];
        }
    
        for(int i = 1; i <= m; i++) dp[m] += b[i];
        if(____(2)_____) return true;
        for(int i = m+1; i <= n; i++) {
            dp[i] = max(b[i] + dp[i-1], _____(3)_____);
            if(dp[i] >= 0) return true;
        }
        return false;
    }
    
    int main(){
        cin >> n >> m;
        for(int i = 1; i <= n; i++) cin >> a[i];
        
        double L = 0, R = 1e18;
        while(abs(L-R) >= 1e-8) {
            double mid = ____(4)______;
            if(check(mid)) {
                _____(5)______;
            } else {
                ______(6)_____;
            }
        }
    
        cout << L << endl;
    
        return 0;
    }
    
    ```

    (6) 处应填

  type: 'SIMPLE'
  options:
    - L = mid 
    - R = mid
    - L = mid + 1
    - R = mid - 1
  answer:
    - B
  source: 'CSP-J 模拟卷'
  score: 3








- description: |


  type: 'SIMPLE'
  options:
  answer:
    - C
  source: 'CSP-J 模拟卷'
  score: 2

- description: |


  type: 'SIMPLE'
  options:
  answer:
    - C
  source: 'CSP-J 模拟卷'
  score: 2

- description: |


  type: 'SIMPLE'
  options:
  answer:
    - C
  source: 'CSP-J 模拟卷'
  score: 2

- description: |


  type: 'SIMPLE'
  options:
  answer:
    - C
  source: 'CSP-J 模拟卷'
  score: 2

- description: |


  type: 'SIMPLE'
  options:
  answer:
    - C
  source: 'CSP-J 模拟卷'
  score: 2

- description: |


  type: 'SIMPLE'
  options:
  answer:
    - C
  source: 'CSP-J 模拟卷'
  score: 2

- description: |


  type: 'SIMPLE'
  options:
  answer:
    - C
  source: 'CSP-J 模拟卷'
  score: 2

- description: |


  type: 'SIMPLE'
  options:
  answer:
    - C
  source: 'CSP-J 模拟卷'
  score: 2

- description: |


  type: 'SIMPLE'
  options:
  answer:
    - C
  source: 'CSP-J 模拟卷'
  score: 2

- description: |


  type: 'SIMPLE'
  options:
  answer:
    - C
  source: 'CSP-J 模拟卷'
  score: 2

- description: |


  type: 'SIMPLE'
  options:
  answer:
    - C
  source: 'CSP-J 模拟卷'
  score: 2

- description: |


  type: 'SIMPLE'
  options:
  answer:
    - C
  source: 'CSP-J 模拟卷'
  score: 2
