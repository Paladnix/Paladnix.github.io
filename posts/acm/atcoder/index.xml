<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Paladnix Blog Site</title>
    <link>https://Paladnix.github.io/posts/acm/atcoder/</link>
    <description>Recent content on Paladnix Blog Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 23 Jun 2022 17:46:07 +0000</lastBuildDate><atom:link href="https://Paladnix.github.io/posts/acm/atcoder/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ABC-256-F 题解</title>
      <link>https://Paladnix.github.io/posts/acm/atcoder/abc-256-f/</link>
      <pubDate>Thu, 23 Jun 2022 17:46:07 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/acm/atcoder/abc-256-f/</guid>
      <description>题意 # 已知A序列为一个整数序列，B序列是A的前缀和序列，C序列是B的前缀和序列，D序列是C的前缀和序列。
有两种操作：
单点修改A序列。 单点查询D序列。 分析 # 我们可以计算每个A对
对B的后缀序列每个都贡献$x$。 对C的后缀序列，每个位置j都贡献$(j-i+1)x$ 对D的后缀序列，每个位置j都贡献$\sum_{1}^{j-i+1} x$ 因此可以得到表达式：
$$
D_i = $$</description>
    </item>
    
    <item>
      <title>Lucky Number 题解</title>
      <link>https://Paladnix.github.io/posts/acm/atcoder/abc-255_e/</link>
      <pubDate>Thu, 23 Jun 2022 15:46:07 +0000</pubDate>
      
      <guid>https://Paladnix.github.io/posts/acm/atcoder/abc-255_e/</guid>
      <description>题意 # Lucky Number
对于序列A，S序列是A序列的相邻两项之和的序列: $S_i = A_i + A_{i+1}$, S序列已知
给定一个X序列，请你确定一个A序列，使得X序列中的数字出现的次数仅可能的多，输出最多的次数。
分析 # 我们可以很容易的写出A序列：
$$ \begin{aligned} A_1 &amp;amp;= A_1 \\ A_2 &amp;amp;= S_1 - A_1 \\ A_3 &amp;amp;= S_2 - A_2 = S_2 - S_1 + A_1 \\ A_4 &amp;amp;= S_3 - A_3 = S_3 - S_2 + S_1 - A_1 \\ A_5 &amp;amp;= S_4 - A_4 = S_4 - S_3 + S_2 - S_1 + A_1 \\ \end{aligned} $$</description>
    </item>
    
  </channel>
</rss>
